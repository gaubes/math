
version=" "; // $Id$
category=" ";
info="
LIBRARY:  determiantal_resolve.lib 
AUTHOR:  Sabrina Alexandra Gaube, sabrina.gaube@uol.de

PROCEDURES:

	determinantal_resolve(matrix M, int r);
	
	calculate_process_of_center_calculation(matrix M); returns the status of the algorithm as a string
	isSimultaneouslyLocallyMonomial(matrix M); returns if the entries of M are simultaneously locally monomial
	isLocallyMonomial(matrix M); returns if the entries of M are locally monomial
	isMonomial(matrix M); returns if the entries of M are monomial
	isresolvedMonomial(matrix M); returns if the entries of M are monomial and the monomial ideal generated by the entries is non-singular

	GenerateListOfBinomials(matrix M); return a list of entries of M which are not locally monomial
	UpdateListofBinomials(list L); where L is a list which was generated by GenerateListOfBinomials(M) and where we have to delete entries after some blow ups
	CreateBinomialFromMonomialMatrix(matrix M); calculate the binomial ideal (in the monomial case) which determines via black box the resolution process 


	blowUp3(J, C, #); same like blowUp2 but with the subcall blowUpBO(BO,C,2) instead of blowUpBO(BO,C,1);
	main_generic_resolve(mode, m, #); main method for resolution of all generic matrices, with string parameter mode
	generic_resolve(m, n, #); call method for resolution of generic mxn matrices
	skewsymmetric_resolve(m); call method for resolution of generic skewsymmetric mxm matrices
	symmetric_resolve(m); call method for resolution of generic ymmetric mxm matrices
	
	CopyDataInNextChartsAndBlowUp(M, Center, chartnumber); blow up method which copies data in the successor charts
	weakTransformOfMatrix(N); given a blown up matrix N it calculates the weak transform of a matrix with respect to rows and columns 
	
	generic_gauss(N, number_rows, number_cols); calculates the gaussian steps for the generic case
	skewsymmetric_gauss(N, number_rows, number_cols); gaussian steps for the skewsymmetric case 
	symmetric_gauss(N, number_rows, number_cols); gaussian steps for the symmetric case
	
	generic_transformation_of_variables(M); transformation of variables for the generic case
	skewsymmetric_transformation_of_variables(M); transformation of variables for the skewsymmetric case
	symmetric_transformation_of_variables(M); transformation of variables for the symmetric case
	
";

LIB "matrix.lib";
//LIB "resolve.lib";
LIB "hualgorithm.lib";
LIB "general.lib";	//absValue
LIB "test_ring.lib"; 			//covering calculation

LIB "resbinomial_neu.lib"; //only for performancetests

proc blowUp3(ideal J,ideal C,list #)
"USAGE:  blowUp3(J,C[,W][,E]);
         W,J,C = ideals,
         E     = list
ASSUME:  J  = ideal containing W ( W = 0 if not specified)
@*       C  = ideal containing J
@*       E  = list of smooth hypersurfaces (e.g. exceptional divisors)
NOTE:    W the ideal of the ambient space, C the ideal of the center of
         the blowup and J the ideal of the variety
         Important difference to blowUp2:
         - the ambient space V(W) is blown up and V(J) transformed in it
@*         - V(C) is assumed to be non-singular
COMPUTE: the blowing up of W in C, the exceptional locus, the strict
         transform of J and the blowup map
RETURN:  list, say l, of size at most size(C),

         l[i] is the affine ring corresponding to the i-th chart
         each l[i] contains the ideals
         - aS, ideal of the blownup ambient space
         - sT, ideal of the strict transform
         - eD, ideal of the exceptional divisor
         - bM, ideal corresponding to the blowup map

         l[i] also contains a list BO, which can best be viewed with showBO(BO)
         detailed information on the data type BO can be viewed via the
         command showDataTypes();
EXAMPLE: example blowUp;  shows an example
"
{
  def S=basering;
  ideal W;
  list E;
  ideal abb=maxideal(1);
  intvec v;
  intvec bvec;
  intvec w=-1;
  matrix intE;
  if(size(#)>0)
  {
    if(typeof(#[1])=="ideal")
    {
      W=#[1];
    }
    if(typeof(#[1])=="list")
    {
      E=#[1];
    }
    if(size(#)>1)
    {
      if((typeof(#[2])=="list") && (size(E)==0))
      {
        E=#[2];
      }
      if((typeof(#[2])=="ideal") && (size(W)==0))
      {
        W=#[2];
      }
    }
  }
  list BO=W,J,bvec,E,abb,v,w,intE;
  int locaT;
  export locaT;
  list blow=blowUpBO(BO,C,2);
  kill locaT;
  int i;
  for(i=1;i<=size(blow);i++)
  {
     def Q=blow[i];
     setring Q;
     ideal aS=BO[1];
     ideal sT=BO[2];
     ideal eD=BO[4][size(BO[4])];
     ideal bM=BO[5];
     kill lastMap;
     kill thisChart;
     export(aS);
     export(sT);
     export(eD);
     export(bM);
     blow[i]=Q;
     setring S;
     kill Q;
  }
  return(blow);
}
example
{"EXAMPLE:";
   echo = 2;
   ring R=0,(x,y),dp;
   ideal J=x2-y3;
   ideal C=x,y;
   list blow=blowUp3(J,C);
   def Q=blow[1];
   setring Q;
   aS;
   sT;
   eD;
   bM;
}

proc print_determinantal_resolve(matrix M , int sizeOfMinor){
	link l1 = ":w Testfaelle/detresolve.txt";
	
	list L = determinantal_resolve(M ,sizeOfMinor);
	ring r = basering;
	
	int i;int j;
	int sizeL = size(L[2]);
	
	
	for(i=1; i<=sizeL; i++){
		
		if(defined(actual_chart)){kill actual_chart;} 
		def actual_chart = L[2][i];
		setring(actual_chart);
		fprintf(l1,"Chartnumber: %s",i);
		fprintf(l1,"matrix: %s ",print(datalist[2]));
		fprintf(l1,"state: %s ",datalist[3][1]);
		fprintf(l1,"Minorsize: %s ",datalist[3][2]);
		fprintf(l1,"datalist[4]: %s ",datalist[4]);
		if(defined(BO)){
			fprintf(l1,"BO: ");
			fprintf(l1,"BO[1]: %s ",BO[1]);
			fprintf(l1,"BO[2]: %s ",BO[2]);
			fprintf(l1,"BO[3]: %s ",BO[3]);
			fprintf(l1,"BO[4]: %s ",BO[4]);
			fprintf(l1,"BO[5]: %s ",BO[5]);
			fprintf(l1,"BO[6]: %s ",BO[6]);
			fprintf(l1,"BO[7]: %s ",BO[7]);				
		}
		if(defined(HuList)){
			for(j=1;j<=size(HuList[1]);j++){
				fprintf(l1,"centerlist[j]: %s ",HuList[1][j]);
			}
			for(j=1;j<=size(HuList[2][1]);j++){
				fprintf(l1,"CoveringList[j]: %s ",HuList[2][1][j]);
			}
		}
		if(defined(cent)){
			fprintf(l1,"center: %s ",cent);
		}
		fprintf(l1,"path:");
		fprintf(l1,"%p",matrix(path));
		fprintf(l1,"");
	}
	
	setring(r);
	
	fprintf(l1,"Number of total charts: %s", sizeL);
	fprintf(l1,"Number of end charts: %s", size(L[1]));
	//fprintf(l1,"runtime: %s", L[3][1]);
	
	return();
}example{
	ring r = 0,(x,y,z),dp;
	matrix M = genericmat(2,2);
	//M[1,1] = x(1)^2*x(2);
	//M[1,2] = x(2)^3;
	//M[2,1] = x(3)^2;
	//M[2,2] = x(3)*x(4)*x(2);
	M[1,1] = x^2-y^2*z^2;
	M[1,2] = x^3;
	M[2,1] = y^4;
	M[2,2] = z^2;
	print_determinantal_resolve(M,2);	
}

//----------------------------------------------------------------------
//TODO
//BO killen wenn final chart für binresolve ODER det monomial case -> 1 entry
//centerlist nicht killen, wenn leer 
//TODO: erkenne wenn r-minoren aufgelöst sind!
proc determinantal_resolve(matrix M, int sizeOfMinor){
	if(sizeOfMinor > min(nrows(M), ncols(M))){
		ERROR("There are no r-minors in M");
	}
	
	def r = basering;
	
	list datalist = createDatalist(M,sizeOfMinor);	
	//ideal minorideal = minor(M,sizeOfMinor);									// Zusätzlich prüfen ob 'fertig' ???
	
	module path = [0,-1];												//path of the current chart, autoconverted to matrix
	export(path);
	
	list BlowUpTree;
	BlowUpTree[1] = basering;
	list EndCharts;
	
	string stat = datalist[3][1];
	print("stat:");
	stat;
	ideal cent;
	export(cent);
	//------------------------------------------------------------------


	list minorsize  = datalist[3][2];
	export(minorsize);
	
	if((min(ncols(M),nrows(M)) == 1) or (minorsize[1] == 1)){
		return(resbinomial2(minor(M,1)));			//resolve ideal of the (binomial) entries of M
	}
	
	while(stat == "gauss"){			//the only status without centers. Can obtain more than once in a row 
		M = generic_gauss(M, nrows(M), ncols(M));
		stat = calculate_process_of_center_calculation(M);
		datalist[3][2] = minorsize;
	}
	if(stat == "binresol"){
		//create list of binomials
		list binomiallist = GenerateListOfBinomials(M);
		//init  BO in the data type of resbinomial2
		ideal J = binomiallist[1];
		list BO = createBO(J);
		export(BO);
	}
	if(stat == "Hu"){
		//we get a list of centers
		list HuList = HuAlgorithm(M);
		HuList[3] = list();
		export(HuList);
	}
	if(stat == "transformation" or stat == "OneCovering"){
		cent = 0;		//dummy value; in order to identify it in the blow up method. In there we calculate the covering.
	}
	if(stat == "monomial"){
		def rnew = CreateBinomialFromMonomialMatrix(M);
		setring(rnew);
		ideal J = retideal; //was created in method and is global in the ring rnew
		list BO = createBO(J);		 
		export(BO);
		matrix M = datalist[2];
		list minorsize  = datalist[3][2];
		export(minorsize);
		ideal cent;
	}
	
	datalist[3][1] = stat;
	//compute the center
	//IMPORTANT: ONLY HuList OR BO should be defined!!!
	// DELETE BO in final charts of resbinomial2
	//HuList in HU should be automatically deleted

	if(defined(BO)){
		cent = calculate_center(1);
		print(cent);
	}
	if(defined(HuList)){
		if(size(HuList[1])>1){
			cent = calculate_center(1);	//TODO later delete superfluent entries in centerlist
		}else{
			stat = "transformation";
			datalist[3][1] = stat;
		}
	}
	print("cent");
	print(cent);
	BlowUpTree = BlowUpTree +  CopyDataInNextChartsAndBlowUp(datalist,cent,1);
	
	int i,j,k;	
	int mindim;
	int chart_counter = size(BlowUpTree);
	
	int oldsize;	//maybe usefull for optimizations, when checking whether we reach r-minors as entries

	for(i = 2; i<= size(BlowUpTree);i++){
		print("chartnumber");
		i;			
		if(defined(Chart)){
			kill(Chart);
		}
		if(defined(rnew)){
			kill(rnew);
		}
		def Chart = BlowUpTree[i];
		setring(Chart);
		
		print(path);
		matrix M = datalist[2];
		print("Matrix");
		print(M);

		int number_cols = ncols(M);
		int number_rows = nrows(M);
		int mindim = min(ncols(M),nrows(M));
					
		//if we are in the middle of a resolve or a HU resolution, shorten the process and going on!
		if(defined(BO) or defined(HuList)){
			if(defined(BO)){
				print("continue BO");
				BO;
				ideal cent = calculate_center(i);			//BO could be deleted if center equals 1; No center than		
				print("cent berechnet");
				if(EqualityOfIdeal(cent,1) == 1 or EqualityOfIdeal(cent,BO[1]) == 1 or EqualityOfIdeal(cent,BO[2]) == 1){
					kill(cent);
					kill(BO);
				}else{
					export(cent);
				}
				print("exportiert oder gelöscht");
			}
			if(defined(HuList)){
				print("continue Hu");
				if(size(HuList[1]) > 1){
					ideal cent = calculate_center(i);	//TODO later delete superfluent entries in centerlist
					export(cent);
				}else{
					stat = "transformation";
					datalist[3][1] = stat;
					ideal cent = 0;	//go directly to the transformation mode
				}
			}	
		}
		
		if(!defined(cent)){				//new status have to start; no center already choosen

			stat = calculate_process_of_center_calculation(M);
			print("stat");
			print(stat);
			datalist[3][1] = stat;
			ideal cent;
			export(cent);
			list minorsize  = datalist[3][2];
			export(minorsize);
			while(stat == "gauss"){			//the only status without centers. Can obtain more than once in a row 
				M = generic_gauss(M, nrows(M), ncols(M));
				stat = calculate_process_of_center_calculation(M);
				datalist[3][1] = stat;
				datalist[3][2] = minorsize;
				print("Matrix");
				print(M);
				print(stat);
			}
			//init data structure depending on the status
			if(stat == "binresol"){
				//create list of binomials
				list binomiallist = GenerateListOfBinomials(M);
				//init  BO in the data type of resbinomial2
				ideal J = binomiallist[1];
				list BO = createBO(J);
				export(BO);
				cent = calculate_center(i);
				
				//TODO: wir brauchen 1-x^A statt y-x^A; via y^2 - x^2A ?
			}
			if(stat == "Hu"){

				list HuList = HuAlgorithm(M);
				list HuList[3] = list();
				export(HuList);
				cent = calculate_center(i);		
			}
			
			if(stat == "transformation"){
				cent = 0; //No blow up but the covering generates new charts 
				// Only a dummy value
			}
			if(stat == "OneCovering"){
				cent = 0;
			}
			if(stat == "monomial"){

				def rnew = CreateBinomialFromMonomialMatrix(M);	//Modify method s.t. it exports datalist and path automatically
				setring(rnew);
				print("monomial ideal:");
				retideal;
				ideal J = retideal; //was created in method and is global in the ring rnew
				list BO = createBO(J);
				export(BO);

				//substitute actual chart in ringlist:
				BlowUpTree[i] = rnew;
				kill(Chart);
				cent = calculate_center(i);
			}
		
			if(min(ncols(M),nrows(M)) == 1){	// binomial ideal -> resbinomial2
				list BO = createBO(minor(M,1));
				ideal cent = calculate_center(i);
				export(cent);
			}
		}
		print("cent:");
		print(cent);
		if(EqualityOfIdeal(cent,1) == 0 ){
			//TODO: pruefe ob r-minoren resolved sind
			if(rMinorsResolved(datalist) == 0){		
				BlowUpTree = BlowUpTree + CopyDataInNextChartsAndBlowUp(datalist,cent,i);	
			}else{
				EndCharts[size(EndCharts)+1] = BlowUpTree[i];
			}
		}else{
			EndCharts[size(EndCharts)+1] = BlowUpTree[i];
		}
	}
	
	
	//------------------------------------------------------------------
	
	
	setring(r);
	if(defined(Chart)){
		kill(Chart);
	}
	if(defined(rnew)){
		kill(rnew);
	}
	
	return(EndCharts,BlowUpTree);
}example{
	//ring r = 0,(x(1..10)),dp;
	//matrix M = skewmat(6);
	//matrix M = genericmat(3,3);
	ring r = 0,(x,y,z),dp;
	matrix M = genericmat(2,2);
	//M[1,1] = x(1)^2*x(2);
	//M[1,2] = x(2)^3;
	//M[2,1] = x(3)^2;
	//M[2,2] = x(3)*x(4)*x(2);
	M[1,1] = x^2-y^2*z^2;
	M[1,2] = x^3;
	M[2,1] = y^4;
	M[2,2] = z^2;
	determinantal_resolve(M,2);
}
//----------------------------------------------------------------------

proc createDatalist(matrix M, int r ){
	list minorsize = list(r,var(1));			//  variable and list is only technically in order that we can store the list in the ring!!!

	list datalist = list();
	export(datalist);
	datalist[1] = ideal(0);
	datalist[2] = M;
	datalist[4] = list();
	datalist[3] = list(calculate_process_of_center_calculation(M),minorsize);
	ideal abb = maxideal(1);
	datalist[5] = abb;
	datalist[6] = list();
	return(datalist);
}


//----------------------------------------------------------------------
proc rMinorsResolved(list datalist){
	int minorSize = datalist[3][2][1];
	ideal minorideal = minor(datalist[2],minorSize);
	
	return(isSmooth(minorideal));	
}

//----------------------------------------------------------------------
//TODO: Lists BO and centerlist have to be global!
proc calculate_center(int chartnumber){

	int i,j;
	int n = nvars(basering);
	
	ideal center;
	if(defined(HuList)){
		//assume: centerlist is not empty!
		list tmplist = HuList[1][size(HuList[1])];
		print(HuList);
		center = tmplist[size(tmplist)];
		HuList[1][size(HuList[1])] = delete(tmplist,size(tmplist));			//Always choose LAST entry of list and delete it
		
		//if(size(centerlist) == 0){
		//	kill(centerlist);
			//TODO: Tag setzen, damit wir im nächsten Schritt sparen können Hu neu zu berechnen!!!
		//}
	}
	if(defined(BO)){
		list Descendlist = calculate_centerBO(BO, chartnumber);  
		BO = Descendlist[1][1]; 	//Only the first BO needed
		center = Descendlist[3];
		if(EqualityOfIdeal(center,1) == 1){		//final chart in resolve.lib
			kill(BO);													//TODO!!!! neuen status ermitteln und dann dadrin weitermachen
		}
		if(defined(BO)){
			if(datalist[3][1] == "monomial"){
				//remove unneeded charts and center components
				matrix M = datalist[2];
				ideal varmatrix = variables(M);
				for(i = 1; i<=n;i++){
					if(EqualityOfIdeal(reduce(varmatrix,var(i)), varmatrix) == 1){		// var(i) not in matrix
						for(j=1;j<=size(center);j++){
							if(size(center[j]) == 2){
								if(center[j][1] == var(i)){
									center[j] = center[j][2];
								}
								if(center[j][2] == var(i)){
									center[j] = center[j][1];
								}
							}else{
								if(center[j] == var(i)){
									center = delete(center,j);			//remove center component
								}
							}
						}
					}
				}
			}
		}
	}
	print("center:");
	center;
	return(center);
}
//dummy function for later improvements and more flexibility
//TODO: Implement more other methods and add a tag which chooses the right one!
proc calculate_centerBO(list L, int chartnumber){
	return(DescendInDimension(L,chartnumber));
}

//----------------------------------------------------------------------
proc calculate_process_of_center_calculation(matrix M)
"USAGE: calculate_process_of_center_calculation(matrix M); returns the status of the algorithm as a string
RETURN: a string which encodes the status of the resolution process
EXAMPLE: example calculate_process_of_center_calculation; shows an example
"
{	
	
	int i,j,k;
	//Create matrix N wich entries are the strict transforms of the entries of M:
	matrix N = M;
	int numCols = ncols(N);
	int numRows = nrows(N);
	list E = datalist[4];
	int sizeE = size(E);
	
	for(i=1;i<=numRows; i++){
		for(j=1;j<=numCols; j++){
			for(k = 1; k<=sizeE; k++){
				if(E[k] != 1){
					N[i,j] = sat(ideal(N[i,j]),E[k])[1];
				}
			}
		}
	}
	
	
	if(isLocallyMonomial(N) == 0){
		return("binresol");
	}
	if(isMonomial(N) == 1 and isresolvedMonomial(N) == 0){ 
		return("monomial");
	}
	if(isresolvedMonomial(N) == 1){
		return("gauss");
	}
	
	// can assume that entries are at least locally monomial here
	if(isLocallyMonomial(N) == 1 and isSimultaneouslyLocallyMonomial(N) == 0){
		return("Hu");
	}
	if(isSimultaneouslyLocallyMonomial(N) and isMonomial(N) == 0){
		return("transformation");
	}

	return("");
}

//----------------------------------------------------------------------
proc isLocallyMonomial(matrix M)
"USAGE: isLocallyMonomial(matrix M); 
RETURN: 1 if the entries of M are locally monomial, 0 if there is an entry which is not locally monomial
EXAMPLE: example isLocallyMonomial; shows an example
"
{ // only 1-x^A equations allowed //TODO: ausfaktorisieren, da y(1-x^A) vorkommen kann
	int i,j,k;
	int LocallyMonomial = 1;
	int number_cols = ncols(M);
	int number_rows = nrows(M);
	
	for(i=1;i<=number_rows;i++){
		for(j=1; j<= number_cols; j++){
			if(size(M[i,j])>1){				// at least binomial
				if(absValue(M[i,j][1]) != 1 and absValue(M[i,j][2]) != 1){		//M[i,j] = 1-x^A or x^A-1
					LocallyMonomial = 0;
				}
			}
		}
	}	
	return(LocallyMonomial);
}example{
	ring r =0, (x,y,z),dp;
	matrix M[3][2] = x,y,z,xy,1-x*y*z,2x;
	print(M);
	isLocallyMonomial (M);
	
	matrix N[3][2] = x^2+y,y,z,xy,1-x^3*y,2x;
	print(N);
	isLocallyMonomial(N);
}


//----------------------------------------------------------------------
proc isSimultaneouslyLocallyMonomial(matrix M)
"USAGE: isSimultaneouslyLocallyMonomial(matrix M); 
RETURN: 1 if the entries of M are simultaneously locally monomial, 0 if there is an entry which is not simultaneously locally monomial
EXAMPLE: example isSimultaneouslyLocallyMonomial; shows an example
"
{
	int i,j,k;
	
	if(isLocallyMonomial(M) == 0){
		return(0);
	}

	//modifies entries of the form y^C(1-x^B); y^C exceptional 


	list HuList = HuAlgorithm(M);			
	export(HuList);
	if(size(HuList[1]) == 1){				//emptylist is the only entry
		return(1);
	}
	return(0);
}example{
	ring r =0, (x,y,z),dp;
	matrix M[2][2] = 1-x,1-y,1-z,1;
	print(M);
	isSimultaneouslyLocallyMonomial (M);
	
	ring r2 =0, (x,y),dp;
	matrix N[2][2] = 1-x,1-y,1-xy,1-xy;
	print(N);
	isSimultaneouslyLocallyMonomial(N);
}



//----------------------------------------------------------------------
proc isMonomial(matrix M)
"USAGE: isMonomial(matrix M); 
RETURN: 1 if the entries of M are monomial, 0 if there is an entry which is not monomial
EXAMPLE: example isMonomial; shows an example
"
{
	 // only x^A equations allowed
	int i,j,k;
	int Monomial = 1;
	int number_cols = ncols(M);
	int number_rows = nrows(M);
	
	for(i=1;i<=number_rows;i++){
		for(j=1; j<= number_cols; j++){
			if(size(M[i,j]) > 1){				// at least binomial
				Monomial = 0;
			}
		}
	}	
	return(Monomial);
}example{
	ring r =0, (x,y,z),dp;
	matrix M[3][2] = x,y^3,z,xy,x*y*z,2x;
	print(M);
	isMonomial (M);
	
	matrix N[3][2] = x^2,y,z,xy,1-x^3*y,2x;
	print(N);
	isMonomial (N);
}


//----------------------------------------------------------------------
proc isresolvedMonomial(matrix M)
"USAGE: isresolvedMonomial(matrix M); 
RETURN: 1 if the entries of M are monomial and there is at least one 1 entry, 0 otherwise
EXAMPLE: example isresolvedMonomial; shows an example
"
{ // only x^A equations allowed
	int i,j;
	int resolved = 0;
	int number_cols = ncols(M);
	int number_rows = nrows(M);
	
	if(isMonomial(M) == 0){
		return(0);
	}

	ideal J = minor(M,1);					//Maybe ideal equals 1 but matrix has no 1-entry e.g. x and 1-x are in the ideal.... TODO create covering
	resolved = EqualityOfIdeal(J,1);			
	return(resolved);
}example{
	ring r =0, (x,y,z),dp;
	matrix M[3][2] = x,y^3,z,xy,x*y*z,2x;
	print(M);
	isresolvedMonomial(M);
	
	matrix N[3][2] = x^2,y,z,xy,1,2x;
	print(N);
	isresolvedMonomial (N);

}


//----------------------------------------------------------------------
// auxiliary procedures for the binomial case
//----------------------------------------------------------------------
proc GenerateListOfBinomials(matrix M)
"USAGE: GenerateListOfBinomials(matrix M); 
RETURN: a list of entries of M which are not locally monomial
EXAMPLE: example GenerateListOfBinomials; shows an example
"{
	int i,j;
	int number_cols = ncols(M);
	int number_rows = nrows(M);
	list returnlist;
	poly f;
	
	for(i=1;i<=number_rows;i++){
		for(j=1; j<= number_cols; j++){
			if(size(M[i,j])>1){				// at least binomial
				if(absValue(M[i,j][1]) != 1 and absValue(M[i,j][2]) != 1){		//M[i,j] != 1-x^A or x^A-1
					f = M[i,j];
					//Check whether  M[i,j] has the form y-x^A or x^A-y
					if(rvar(f[1]) > 0 or rvar(f[2]) > 0){
						f = (f[1])^2 + (f[2])^2;
						returnlist[size(returnlist)+1] = f;
					}else{	
						returnlist[size(returnlist)+1] = f;
					}
				}
			}
		}
	}			
	return(returnlist);
}example{
	ring r =0, (x,y,z),dp;
	matrix M[3][2] = 1-x,x*z-y^3,z,3xy,x*y*z,2x+z;
	print(M);
	GenerateListOfBinomials(M);
} 

//----------------------------------------------------------------------
proc UpdateListofBinomials(list L)
"USAGE: UpdateListofBinomials(list L); where L is a list which was generated by GenerateListOfBinomials(M) and where we have to delete entries after some blow ups
RETURN: a list of entries of M which are not locally monomial
EXAMPLE: example UpdateListofBinomials; shows an example
"{	
	int i,j;
	int sizeL = size(L);
	
	for(i=1;i<=sizeL;i++){
		if(isLocallyMonomial(L[i]) == 1){
			L = delete(L,i);
			sizeL = size(L);
			i--;
		}
	}				
	
	return(L);
}example{
	ring r =0, (x,y,z),dp;
	list L = 1-x,x*z-y^3,z,3xy,x*y*z,2x+z;
	UpdateListofBinomials(L);
}
	
//----------------------------------------------------------------------
// auxiliary procedures for the monomial case
//----------------------------------------------------------------------	
proc CreateBinomialFromMonomialMatrix(matrix M)
"USAGE: CreateBinomialFromMonomialMatrix(matrix M); calculate the binomial ideal (in the monomial case) which determines via black box the resolution process 
RETURN: the binomial ideal corresponding to the determinantal monomial case
EXAMPLE: example CreateBinomialFromMonomialMatrix; shows an example
"
{		//requires a monomial matrix M
	def r = basering;			//NEIN//TODO: save ring in List of Data in order to change back afterwards
	int n = nvars(r);
	int i;
	
	ideal tmpideal = std(minor(M,1));
	int d = MaxOrd(0,tmpideal)[1];						//TODO: ambient space???
	int idealsize = size(tmpideal);						// we need 2*idealsize many new variables
	
	//ring tmpr = 0,(z(1..2*idealsize)),dp;				//Not necessary in char 0
	execute("ring tmpr=("+charstr(basering)+"),((u(1..n),z(1..idealsize))),(dp(n),dp(idealsize));");
	matrix Mnew = fetch(r,M);	//reihenfolge der variablen wichtig!
	//TODO: fetch whole datalist
	ideal tmpideal = fetch(r,tmpideal);
	ideal retideal;
	for(i=1;i<=idealsize;i++){
		retideal[i] = var(n+i)^d + tmpideal[i];			// J = <y_{2l}^{d-1}y_{2l+1} + x^{A_l}>, but we want to start with y_1 instead of y_2 
	}
	print(retideal);
	export(retideal);
	list datalist = fetch(r,datalist);

	export(datalist);
	def path = fetch(r,path);
	export(path);
	
	return(tmpr);		//seems that is only possible to return the ring and not change the ring in an external method; Everything else have to be exported!
}example{
		//TODO
}


//----------------------------------------------------------------------
proc finishedDetMonomialCase(list datalist){
	int i,j;
	
	def r = basering;
	
	ideal W = datalist[1];
	matrix M = datalist[2];
	list E = datalist[4];
	
	ideal sufficientVars = variables(M)+variables(W);
	for (i=1;i<= size(E);i++){
		if(E[i] != 1){
			sufficientVars = sufficientVars + variables(E[i]);
		}
	}
	int n = size(sufficientVars);
	string StringsufficientVars = string(sufficientVars);
	print("StringsufficientVars");
	StringsufficientVars;
	//Construct new ring with less variables
	execute("ring tmpr=("+charstr(basering)+"),("+StringsufficientVars+"),(dp(n));");
	//TODO: imap, da Reihenfolge unwichtig, gleicher Name auf gleichen Namen abbilden
	list datalist = imap(r,datalist);

	print("datalist: (finished monomial case)");
	datalist;
	export(datalist);
	def path = imap(r,path);
	export(path);
	return(tmpr);
}


//----------------------------------------------------------------------
//			Blow up method
//----------------------------------------------------------------------
//TODO: Ueberarbeiten; datentyp liste 
proc CopyDataInNextChartsAndBlowUp(list datalist, ideal Center, int chartnumber)
"USAGE: CopyDataInNextChartAndBlowUp(matrix M, ideal Center, int chartnumber ); computes the blow up and copies the data (strict transform, ideal and pathmatrix) in the successorcharts
RETURN: list of rings which represent the charts during the whole resolution process
EXAMPLE: example CopyDataInNextChartAndBlowUp; shows an example
"
{
	int j,k, number_cols,number_rows;
	def r = basering;
	int BOdefined, centerlistdefined,coveringlistdefined, HuListdefined;
	if(defined(BO)){BOdefined = 1;}
	if(defined(HuList)){
		if(size(HuList[1]) >=1){
			HuListdefined = 1;
		}else{
			HuListdefined = -1;		//empty list -> change status to transformation
		}
	}

	ideal W = datalist[1];
	matrix M = datalist[2];
	string stat = datalist[3][1];					//Darauf achten, dass das auch immer gesetzt wird!
	list minorsize = datalist[3][2];
	list E = datalist[4];
	ideal abb = datalist[5];
	
	//TODO: Differ center == 0 (only transformation) and center != 0 case
	list successorList;
	if (defined(HuList)){
	print("HuList:");
	HuList;
	}
	if(EqualityOfIdeal(Center,0) == 1){	//Transformation
		print("Transformation wird durchgeführt:");
		if(datalist[3][1] == "OneCovering"){
			successorList = generateOneCovering(datalist,chartnumber);
		}else{	
			successorList = generateCovering(datalist,chartnumber);
		}
		print(successorList);
	}else{	
		successorList = blowUp3(W,Center);	
		int number_center_components = size(successorList);


		for(j = 1;j<=number_center_components; j++){
			if(defined(newring)){kill newring;}
			print(j);
			print(number_center_components);
			def newring = successorList[j];
			setring(newring);
			map BlowUpMap = r,bM;		
			ideal W = BlowUpMap(W);
			//export(W);
			//list datalist = list();
			list datalist = BlowUpMap(datalist);
			//print(datalist);
			export(datalist);
			print("datalist:");
			datalist;
			datalist[1] = W;
			list E = datalist[4];
			E[size(E)+1] = eD[1];
			print("eD");
			eD;
			datalist[4] = E;
		
			if(BOdefined){
				list BO = BlowUpMap(BO);			
				BO[1] = aS;
				BO[2] = sat(BO[2],eD[1])[1];
				print("BO:");
				BO;
				for(k=1; k<=size(BO[4]);k++){
					BO[4][k] = sat(BO[4][k],eD[1])[1];	
				}
				BO[4][size(BO[4])+1] = eD;
				
				BO[5] = bM;
				export(BO);
			}//TODO: strict transforms?
			if(HuListdefined == 1){
				list HuList = BlowUpMap(HuList);
				for(k=1; k<=size(HuList[3]);k++){
					HuList[3][k] = sat(HuList[3][k],eD[1])[1];	
				}
				HuList[3][size(HuList)+1] = eD;
				export(HuList);
			}
			if(HuListdefined == -1){
				string stat = "transformation";
			}
		
			//Noch anderes mit übergeben?
			//alles einzeln abbilden
			//darauf achten, dass alles irgendwie ein ringelement hat
			ideal abb = BlowUpMap(abb);					//abbildung aus resbinomial2.lib //TODO: mit bM verknuepfen!!!!?
			datalist[5] = abb;	
			matrix N = BlowUpMap(M);				// total transform
			matrix Ntmp = weakTransformOfMatrix(N);
			datalist[2] = Ntmp;

			def path = imap(r,path);				//init pathmatrix 
			path=path,[chartnumber,j];
			export(path);
		
			if(coveringlistdefined){
				list CoveringList = BlowUpMap(CoveringList);
				export(CoveringList);	
			}
			//datalist[3] = BlowUpMap(datalist[3]);
			list minorsize = datalist[3][2];
			export(minorsize);
		
			//determinantal monomial case is finished:
			if(datalist[3][1] == "monomial"){
				matrix M = datalist[2];
				ideal Jmonom = minor(M,1);
				if(EqualityOfIdeal(Jmonom,1) == 1){
					kill(BO);
					//reduce variables in the ring
					print("monomial case: reduce number of variables");
					if(defined(rnew)){
						kill(rnew);
					}
					def rnew = finishedDetMonomialCase(datalist);		//method exports, datalist and path
					successorList[j] = rnew;
					setring(rnew);
					if(defined(newring)){
						kill(newring);
					}
					print("monomial case finished");
				}
			}
		
		
			//HU is finished:
			if(defined(stat)){
				if(stat == "transformation"){
					datalist[3][1] = stat;
				}
			}else{
				datalist[3][1] =  calculate_process_of_center_calculation(Ntmp);
			}
		}	
	}
	return(successorList);
}example{
	ring r = 0,(x(1..12)),dp;
	matrix M = genericmat(3,4);
	list datalist = createDatalist(M);
	CopyDataInNextChartsAndBlowUp(datalist,std(minor(M,1)),1);	
}



//----------------------------------------------------------------------

proc generateOneCovering(list datalist, int chartnumber){
	int i,j,k,l;
	ring old_r = basering;
	matrix M = datalist[2];
	
	// ideal generated by the 1-minors equals 1 but no entry is 1
	// matrix to List...
	list L; 
	for(i = 1;i<= nrows(M); i++){
		for(j=1;j<=ncols(M); j++){
			L = AppendListToList(L,list(M[i,j]));		//no duplicates
		}
	}
	
	int sizeL = size(L); 
	list SubsetList;
	ideal SubsetsIdeal;
	int ignoreSubset = 0;
	for(i=2; i<= sizeL; i++){
		if(EqualityOfIdeal(SubsetsIdeal,1) == 1){
			break;
		}
		SubsetList = subsets(sizeL,i);
		SubsetsIdeal = 0;
		ignoreSubset = 0;
		for(j=1; j<=size(SubsetList); j++){
			for(k=1;k<=size(SubsetList[j]); k++){
				if(L[SubsetList[j][k]] == 1){
					ignoreSubset = 1;
				}
				if(ignoreSubset == 0){
					SubsetsIdeal = SubsetsIdeal + L[SubsetList[j][k]];
				}
			}
			if(ignoreSubset == 0){
				if(EqualityOfIdeal(SubsetsIdeal,1) == 1){
					k--;
					break;
				}
			}
		}
		if(EqualityOfIdeal(SubsetsIdeal,1) == 1){
			break;
		}
	}

	//covering by charts:
	list successorlist = list();
	int n = nvars(basering);
	ideal hypersurface;
	
	int poscol;
	int posrow;
	
	//No new parametersystem needed
	for(i=1;i<= size(SubsetsIdeal);i++){
		hypersurface = SubsetsIdeal[i];
		poscol = 0;
		posrow = 0;
		for(k=1;k<=nrows(M); k++){
			for(l=1; l<= ncols(M); l++){
				if(M[k,l] == hypersurface){
					posrow = k;
					poscol = l;
					print("Position:");
					poscol;
					posrow;
				}
			}
		}
		 			
		if(defined(new_r)){kill(new_r);}
		execute("ring new_r=("+charstr(basering)+"),("+varstr(basering)+"),(dp(n));");
		ideal I = fetch(old_r,hypersurface);
		
		list datalist = fetch(old_r,datalist);
		module path = fetch(old_r,path);
		path=path,[chartnumber,i];
		
		export(datalist);
		export(path);
		datalist[1] =  sat(datalist[1],I)[1];
		//datalist[2] =  sat(datalist[2],I)[1];
		matrix N = datalist[2];
		print("old M:");
		print(N);
		if(poscol != 0){
			for(k=1;k<=nrows(N); k++){
				for(l=1; l<= ncols(N); l++){
					if(k!= posrow and l != poscol){
						N[k,l] = I[1] * N[k,l];
					}
				}
			} 			
		//TODO: Matrix abbilden; Alle Einträge mit I multiplizieren und dann für Eintrag (i,j) = 1 column i  und row j weak transformen
		N[posrow,poscol] = 1;
		print("new M:");
		print(N);
		}else{print("Eintrag nicht in Matrix"); ~;}
		
		
		for(j=1;j<=size(datalist[4]);j++){
			datalist[4][j] =  sat(ideal(datalist[4][j]),I)[1];						
		}
		datalist[5] =  sat(datalist[5],I)[1];		
		//saturation: 

		
		setring(old_r);
		successorlist[size(successorlist)+1] = new_r;
	}
	// SubsetList[j] has the entries which generates the 1 --> Hypersurfaces h_k which generates the charts D(h_k).
	//Same as HU Covering 
	
	 return(successorlist);
}



proc generateCovering(list datalist, int chartnumber){
	
	int i,j,k;
	int member;
	//TODO
	
	ring old_r = basering;
	int n = nvars(basering);
	matrix M = datalist[2];
	int numcols = ncols(M);
	int numrows = nrows(M);
	ideal I = generateListsimlocmon(M);
	
	list L1;
	list simlocmon = ListForHU(M);
	print("HuList:");
	HuList;
	for (i=1; i<= size(HuList[2]);i++){
		L1[i] = list();
		L1[i][1] = HuList[2][i][1];
	}
	for (i=1; i <= size(HuList[2]);i++){
		L1[i][2] = HuList[2][i][2];
	}

	if(size(HuList)<3){
		HuList[3] = list();
	}

	//First add exceptional divisors then add x_i+_ci, where c_i = 0,1 or -1
	int sizeL1 = size(L1);
	for(i=1;i<=sizeL1;i++){
		for(j=1;j<=size(HuList[3]); j++){
			sizeL1 = size(L1);
			L1[i][1][size(L1[i][1])+1] = list();
			L1[i][1][size(L1[i][1])] = HuList[3][i];
			//L1[i][2] do not change
		}
		L1[i][1] = AddComponentToSystemOfParameters(L1[i][1], L1[i][2]);
	}
	
	int contained = 0;
	 
	//if(size(HuList[2]) == 0){
	//	if(size(I) == n){
	//		L1[1][1] = I;
	//		L1[1][2] = list();
	//	}else{
			//
	//		list SubsetList = subsets(size(I),n);
			
	//	}
	//} else{
	//	for(i=1; i<= size(HuList[2]);i++){
	//		L1[i][2] = list();
	//		contained = 0;
	//		for(j = 1; j<= size(HuList[2][i]);j++){
	//			for(k=1;k<=size(simlocmon);k++){			//remove dulicates!
	//				if(HuList[2][i][j] == simlocmon[k]){
	//					contained == 1;
	//				}
	//			}
	//			if(contained == 0){
	//				L1[i][2][size(L1[i][2])+1] = simlocmon[k];
	//			}
	//		}
	//	}
	//}
	
	// Diese Liste direkt bei HuAlgorithm mit zurückgeben -> letzte zentrumsstufe [1] und rest [2]	
	// Liste Hyperflächen L1[i][1][j] -> i-te Karte schneidende Hyperflächen
	//	L1[i][2][j] -> i-te Karte nicht-schneidende Hyperflächen (D(hl...hk))
	list successorlist = list();
	list N;
	//int n;
	ideal normcrossideal;
	ideal complementideal;
	print("L1:");
	print(L1);
	//ggf alle hyperflächen einzeln
	for (member = 1; member <= size(L1); member++){ 	 //member stimmt mit i aus L und indices ueberein
		N = L1[member];
		//n = size(N[1]);


		ideal normcrossideal;
		for(i=1;i<=size(N[1]);i++){
			normcrossideal = normcrossideal + N[1][i];
		}
		ideal complementideal = 1;
		for(i=1;i<=size(N[2]);i++){
			complementideal = complementideal * N[2][i];
		}	
		if(defined(new_r)){kill(r_new);}

//First saturate then apply transformation of variables
		
		execute("ring new_r=("+charstr(basering)+"),(t(1..n)),(dp(n));");
		

		
		setring(old_r);
		print("parametersystem:");
		normcrossideal;
		map f = new_r,normcrossideal;
		//saturation:
		

		for(i=1;i<=size(datalist[1]);i++){
			datalist[1][i] =  sat(ideal(datalist[1][i]),complementideal)[1];
		}
		//datalist[2] =  sat(datalist[2],I)[1];
		//TODO: Matrix abbilden; Nachrechnen!!!
		//TODO: weak transform
		ideal eD = complementideal;
		export(eD);
		print("vorher:");
		print(M);
		//M = weakTransformOfMatrix(M);
		for(i=1;i<=nrows(M);i++){
			for(j=1;j<=ncols(M);j++){
				M[i,j] = sat(ideal(M[i,j]),complementideal)[1];
			}
		}
		print("nachher:");
		print(M);
		//datalist[3] =  sat(datalist[3],I)[1];
		for(i=1;i<=size(datalist[4]);i++){
			datalist[4][i] =  sat(ideal(datalist[4][i]),complementideal)[1];						
		}
		datalist[5] =  sat(datalist[5],complementideal)[1];
		//transformation:
		ideal ambientspace = datalist[1];
		matrix m = datalist[2];
		list E = datalist[4];
		ideal abb = datalist[5];
		
		for(i=1;i<=nrows(M);i++){
			for(j=1;j<=ncols(M);j++){
				if(defined(dummy)){
					kill(dummy);
				}
				ideal dummy = M[i,j];
				setring(new_r);
				if(!defined(m)){
					matrix m[numrows][numcols];
				}
				m[i,j] = preimage(old_r,f,dummy);
				setring(old_r);
			}
		}
		
		for(j=1;j<=size(E);j++){
			if(defined(dummy)){
				kill(dummy);
			}
			ideal dummy = E[j];
			setring(new_r);
			if(!defined(E)){
				list E;
			}
			E[j] = preimage(old_r,f,dummy);
			setring(old_r);
		}
		setring(new_r);
		
		list datalist;
		datalist[2] = m;
		print(m);
		~;
		datalist[1] = preimage(old_r,f,ambientspace);
		datalist[5] = preimage(old_r,f,abb);
		//datalist[6] = preimage(old_r,f,datalist[6]);
		module path = fetch(old_r,path);
		path=path,[chartnumber,member];
		
		list dummy = fetch(old_r,datalist);
		datalist[3] = dummy[3];
		export(datalist);
		export(path);
		//ist das alles?
		
		setring(old_r);
		successorlist[size(successorlist)+1] = new_r;
	}
	print("nachfolgekarten:");
	print(size(successorlist));
	successorlist;
	return(successorlist);
}

//----------------------------------------------------------------------
//Requires a simloc matrix M
proc generateListsimlocmon(matrix M){
		//TODO
		int i,j;
		ideal I;
		int maxcol = ncols(M);
		int maxrow = nrows(M);
		
		for(i=1; i<=maxrow; i++){
			for (j=1; j<=maxcol;j++){
				if(M[i,j] != 0 and M[i,j]!= 1){
					I[size(I)+1] = M[i,j];
				}
			}
		}		
		return(I);
}


//----------------------------------------------------------------------
//Sollte nur mit einer L1 stufe passieren und complementliste mitgeben
proc AddComponentToSystemOfParameters(list parametersystem, list complement){
	int i,j,k; 
	int n = nvars(basering);
	if(size(parametersystem) == n){
		return(parametersystem);
	}
	
	
	ideal listideal = 0;
	ideal complementideal = 0;
	for(i = 1; i<= size(parametersystem);i++){
		listideal = listideal + parametersystem[i];
	}
	for(i = 1; i<= size(complement);i++){
		complementideal = complementideal + complement[i];
	}


	// Add f_i = x_i+c_i where c_i = 0,1 or -1 and x_i a variable in the basering
	// f_i has to fullfil the following conditions:
	// 1. has to lie in D(h1...hr)
	// f_i has to intersect each of the other components in the intersection point 
	
	int contained;
	ideal tmplistideal;
	//via bruteforce
	for(i=1; i<=n; i++){
		contained = 0;
		for(j=1; j<= size(parametersystem); j++){
			if(var(i) == parametersystem[j]){
				contained = 1;
			}
		}
		//check  whether it intersects the parametersystem in the right point and lives in the complement
		//var
		if(contained == 0){
			//if(ContainedInLocallyMonomial(var(i),complementideal) == 0){
				tmplistideal = listideal + var(i); 
				if(EqualityOfIdeal(tmplistideal,1) == 0){
					if (size(reduce(1,std(complementideal+tmplistideal))) == 0) { 	// complementideal cap tmplistideal = empty set
						//Add var(i) to list of parametersystems!
						listideal = tmplistideal;
						parametersystem[size(parametersystem)+1] = var(i);
						i++;
						continue;
					}
				}
			//}
		}
		
		
		//var + 1
		if(contained == 0){
			tmplistideal = listideal + (var(i)+1); 
			if(EqualityOfIdeal(tmplistideal,1) == 0){
				if (size(reduce(1,std(complementideal+tmplistideal))) == 0) { 	// complementideal cap tmplistideal = empty set
					//Add var(i)+1 to list of parametersystems!
					listideal = tmplistideal;
					parametersystem[size(parametersystem)+1] = var(i)+1;
					i++;
					continue;
				}
			}
		}
		//var - 1
		if(contained == 0){
			tmplistideal = listideal + (var(i)-1); 
			if(EqualityOfIdeal(tmplistideal,1) == 0){
				if (size(reduce(1,std(complementideal+tmplistideal))) == 0) { 	// complementideal cap tmplistideal = empty set
					//Add var(i)-1 to list of parametersystems!
					listideal = tmplistideal;
					parametersystem[size(parametersystem)+1] = var(i)+1;
					i++;
					continue;
				}
			}
		}
		 //TODO: optimizations
	}
	if(size(parametersystem) != n){
		print("Size of system of parameters:");
		print(parametersystem);
		print("Number of ring variables:");
		print(n);
		~;
	}
	
	
	return(parametersystem);
}
//----------------------------------------------------------------------

proc ContainedInLocallyMonomial(poly v,ideal complementideal){
	int i,j,k;
	int contained = 0;
	
	for(i=1;i<=size(complementideal);i++){
		if(size(complementideal[i]) == 2){
			if(complementideal[i][1] == 1 or complementideal[i][1] == -1){
				if((complementideal[i][2]/ v) != 0){
					return(1);
				}
			}else{
				if((complementideal[i][1]/ v) != 0){
					return(1);
				}
			}
		}
	}
	return(contained);
}



//----------------------------------------------------------------------

// 				generic case

//----------------------------------------------------------------------
proc main_generic_resolve(string mode, int m, list #)
"USAGE:main_generic_resolve(string mode, int m[, int n , int r] ); computes the resolution of the ideal of r-minors of a (skew)-symmetric generic mxm matrix with mode = skew or mode = sym or generic mxn matrix with mode = gen
RETURN: list of rings which represent the charts during the whole resolution process
EXAMPLE: example generic_resolve; shows an example
"
{
	int minsize;
	if(mode == "gen"){
		if(size(#)>0){
			int n = #[1];
		}else{
			int n = m;
		}
		ring r = 0,(x(1..m*n)),dp;
		matrix M = genericmat(m,n);
		minsize = 1;
	}
	if(mode == "sym"){
		ring r = 0,(x(1..m*(m+1) div 2)),dp;
		matrix M = symmat(m);
		minsize = 1;			//TODO???
	}
	if(mode == "skew"){
		ring r = 0,(x(1..m*(m-1)div 2)),dp;
		matrix M = skewmat(m);
		minsize = 2;
	}
	if(!defined(r)){
		ERROR("choose a mode gen,sym or skew followed by the size of your generic matrix");
	}
	
	
	list minorsize = list(min(ncols(M),nrows(M)),var(1) );				// default: resolve maximal minors; variable and list is only technically in order that we can store the list in the ring!!!
	ideal minorideal = radical(minor(M,1));
	if(size(#)>1 and mode == "gen"){
		if(typeof(#[2])=="int"){
			minorsize[1] = #[2];										//calculate how long we have to blow up until the #[1]-minors are resolved
			minorideal = radical(minor(M,minorsize[1]));
		}
	}
	if(size(#)>0 and mode != "gen"){
		if(typeof(#[1])=="int"){
			minorsize[1] = #[1];										//calculate how long we have to blow up until the #[1]-minors are resolved
			minorideal = minor(M,minorsize[1]);
		}
	}
	
	export(minorsize);

	export(minorideal);
	
	module path = [0,-1];												//path of the current chart, autoconverted to matrix
	export(path);
	
	ideal W = ideal(0);													//ambient space; Maybe change this later
	export(W);
	list E = list();													// list of exceptional divisors
	export(E);
	ideal abb=maxideal(1);
	export(abb);
	
	list BlowUpTree;
	BlowUpTree[1] = basering;
	ideal cent = minor(M,1);											//auxiliary data 
	export(cent);
	
	if(minorsize[1] <= minsize){													// ideal of 1 minors is already resolved
		return(BlowUpTree,1,1);
	}
	
	BlowUpTree = BlowUpTree +  CopyDataInNextChartsAndBlowUp_generic(M,radical(minor(M,1)),1);
	int i; int j; int k;
	
	int number_cols, number_rows;
	int mindim;
	int chart_counter = size(BlowUpTree);
	int end_chart_counter;
	
	int oldsize;
	for(i = 2; i<= size(BlowUpTree);i++){			
		if(defined(XijChart)){
			kill(XijChart);
		}
		def XijChart = BlowUpTree[i];
		setring(XijChart);

		number_cols = ncols(N);
		number_rows = nrows(N);
		if(mode == "gen"){
			matrix M = generic_gauss(Ntmp, number_rows,number_cols); 					// Reduction in Dimension
			list transformationlist = generic_transformation_of_variables(M);			//Transformation for the new system of parameters
		}
		if(mode =="sym"){
			matrix M = symmetric_gauss(Ntmp, number_rows,number_cols); 					
			list transformationlist = symmetric_transformation_of_variables(M);			
		}
		if(mode =="skew"){
			matrix M = skewsymmetric_gauss(Ntmp, number_rows,number_cols); 					
			list transformationlist = skewsymmetric_transformation_of_variables(M);			
		}
		M = transformationlist[1];
		ideal minorideal = transformationlist[2];
		export(minorideal); 
		mindim = min(ncols(M),nrows(M));
		
		if(minorsize[1] > minsize){		//TODO!!! depends on the mode
			oldsize = size(BlowUpTree);
			ideal cent = minor(M,1);									//auxiliary data 
			export(cent);
			BlowUpTree = BlowUpTree + CopyDataInNextChartsAndBlowUp_generic(M,radical(minor(M,1)),i);
			chart_counter = chart_counter + size(BlowUpTree) - oldsize;
		}else{
			end_chart_counter++;
		}
	}
	return(BlowUpTree,chart_counter,end_chart_counter);
}

proc generic_resolve(int m, list #)
"USAGE:generic_resolve(int m[, int n , int r] ); computes the resolution of the ideal of r-minors of a generic mxn matrix
RETURN: list of rings which represent the charts during the whole resolution process
EXAMPLE: example generic_resolve; shows an example
"
{						
	int n, r;
	list BlowUpTree;
	if (size(#)>0){
		n = #[1];
		if(size(#)>1){
			r = #[2];
			BlowUpTree = main_generic_resolve("gen",m,n,r);
		}else{
			BlowUpTree = main_generic_resolve("gen",m,n);
		}
	}else{
		BlowUpTree = main_generic_resolve("gen",m,m);
	}
	
	return(BlowUpTree);
}
example{ 	
	generic_resolve(4,3,2);
}


proc skewsymmetric_resolve(int m, list #)
"USAGE:skewsymmetric_resolve(int m [, int r] ); computes the resolution of the ideal of r-minors of a generic skewsymmetric mxm matrix
RETURN: list of rings which represent the charts during the whole resolution process
EXAMPLE: example skewsymmetric_resolve; shows an example
"
{
	int r;
	list BlowUpTree;
	if (size(#)>0){
		r = #[1];
		BlowUpTree = main_generic_resolve("skew",m,r);
	}else{
		BlowUpTree = main_generic_resolve("skew",m);
	}
	
	return(BlowUpTree);
}example{
	skewsymmetric_resolve(4);
}


proc symmetric_resolve(int m, list #)
"USAGE:symmetric_resolve(int m [, int r] ); computes the resolution of the ideal of r-minors of a generic skewsymmetric mxm matrix
RETURN: list of rings which represent the charts during the whole resolution process
EXAMPLE: example skewsymmetric_resolve; shows an example
"
{
	int r;
	list BlowUpTree;
	if (size(#)>0){
		r = #[1];
		BlowUpTree = main_generic_resolve("sym",m,r);
	}else{
		BlowUpTree = main_generic_resolve("sym",m);
	}
	
	return(BlowUpTree);
}example{
	symmetric_resolve(4);
}


proc CopyDataInNextChartsAndBlowUp_generic(matrix M, ideal Center, int chartnumber)
"USAGE: CopyDataInNextChartAndBlowUp(matrix M, ideal Center, int chartnumber ); computes the blow up and copies the data (strict transform, ideal and pathmatrix) in the successorcharts
RETURN: list of rings which represent the charts during the whole resolution process
EXAMPLE: example CopyDataInNextChartAndBlowUp; shows an example
"
{
	int j, number_cols,number_rows;
	int Edefined = 1;
	def r = basering;
	if(size(E) == 0){Edefined = 0;}
	list successorList = blowUp3(W,Center);
	int number_center_components = size(successorList);

	for(j = 1;j<=number_center_components; j++){
		if(defined(newring)){kill newring;}
		
		def newring = successorList[j];
		setring(newring);
		map BlowUpMap = r,bM;		
		ideal W = BlowUpMap(W);
		export(W);
		if(!Edefined){ list E = list();}
		else{list E = BlowUpMap(E);}
		E[size(E)+1] = eD[1];
		export(E);

		ideal abb = BlowUpMap(abb);					//abbildung aus resolve.lib //TODO: mit bM verknuepfen!!!!
		export(abb); 	
		matrix N = BlowUpMap(M);				// total transform
		export(N);
		//matrix Ntmp = sat(N+sT,eD[1])[1];		// Achtung !!! Reihenfolge der Einträge und Dimension der neuen Matrix!!!
		matrix Ntmp = weakTransformOfMatrix(N);
		export(Ntmp);
		number_cols = ncols(N);
		number_rows = nrows(N);

		def path = imap(r,path);				//init pathmatrix 
		path=path,[chartnumber,j];
		export(path);
		
		list minorsize = BlowUpMap(minorsize);
		export(minorsize);
	}
	return(successorList);
}example{
	ring r = 0,(x(1..12)),dp;
	matrix M = genericmat(3,4);
	CopyDataInNextChartsAndBlowUp(M,std(minor(M,1)),1);	
}


proc weakTransformOfMatrix(matrix N)	
"USAGE: weakTransformOfMatrix(matrix N); given a blown up matrix N it calculates the weak transform of a matrix with respect to rows and columns
RETURN: transformed matrix 
EXAMPLE: example weakTransformOfMatrix; shows an example
"
{
	int i,j,k;
	int number_rows = nrows(N);
	int number_cols = ncols(N);
	
	
	//find maximal value  c such that we can factor out eD[1]^c in each row:
	poly tmp_entry;
	poly tmp_eDPowC;
	int eDDividesRow;

	for(i=1; i<= number_rows;i++){
		tmp_eDPowC = eD[1];
		eDDividesRow = 1;
		while(eDDividesRow){
			for(j=1; j<=number_cols; j++){
				if(N[i,j] != 0){									// without this, a skewsymmetric matrix is returned as total transform because of the zero entries
					if(size(N[i,j]) == 1){
						tmp_entry = N[i,j] div tmp_eDPowC;						
						if(tmp_entry == 0){
							eDDividesRow = 0;
							break;
						}
					}else{						
						if(N[i,j][1] div tmp_eDPowC == 0 or N[i,j][2] div tmp_eDPowC == 0){
							eDDividesRow = 0;
							break;
						}	
					}
				}
			}
			if(eDDividesRow){
				tmp_eDPowC = tmp_eDPowC * eD[1];
			}else{
				tmp_eDPowC = tmp_eDPowC div eD[1];
			}
		}
		for(j = 1; j<= number_cols; j++){
			N[i,j] = N[i,j] div tmp_eDPowC;
		}
	}
	//same procedure for each column:
	for(j=1; j<= number_cols;j++){
		tmp_eDPowC = eD[1];
		eDDividesRow = 1;
		while(eDDividesRow){
			for(i=1; i<=number_rows; i++){
				if(size(N[i,j]) == 1){
					tmp_entry = N[i,j] div tmp_eDPowC;						
					if(tmp_entry == 0){
						eDDividesRow = 0;
						break;
					}
				}else{						
					if(N[i,j][1] div tmp_eDPowC == 0 or N[i,j][2] div tmp_eDPowC == 0){
						eDDividesRow = 0;
						break;
					}	
				}
			}
			if(eDDividesRow){
				tmp_eDPowC = tmp_eDPowC * eD[1];
			}else{
				tmp_eDPowC = tmp_eDPowC div eD[1];
			}
		}
		for(i = 1; i<= number_rows; i++){
			N[i,j] = N[i,j] div tmp_eDPowC;
		}
	}
	return(N);
}example{
	ring r = 0,(x(1..9)),dp;
	matrix N[3][3] = x(1),x(1)*x(2),x(1)*x(3),x(1)*x(4),x(1)*x(5),x(1)*x(6),x(1)*x(7),x(1)*x(8),x(1)*x(9); 
	print(N);
	list eD;
	eD[1] = x(1);
	export(eD);
	weakTransformOfMatrix(N);
	
	matrix N[3][3] = x(1)^2,x(1)^2*x(2),x(1)^3*x(3),x(1)*x(4),x(1)*x(5),x(1)*x(6),x(1)^5*x(7),x(1)^4*x(8),x(1)*x(9); 
	print(N);
	weakTransformOfMatrix(N);
}


proc generic_gauss(matrix N, int number_rows, int number_cols)			//TODO: compute the map of abb
"USAGE: generic_gauss(matrix N, int number_rows, int number_cols ); computes the gaussian steps in the resolution process.
RETURN: transformed matrix M
EXAMPLE: example generic_gauss; shows an example
"
{		
	int i,j,k;
	
	intvec newcols, newrows, cols, rows;
	
	cols = 1..number_cols;
	rows = 1..number_rows;
	matrix N2 = submat(N,rows,cols);		//Gaussian steps
	matrix colN = colred(N2);
	matrix redN = rowred(colN);
	
	for(j =1; j<= number_rows;j++){
		for(k = 1; k<= number_cols;k++){
			if(redN[j,k] == 1) {break;}
		}
		if(redN[j,k] == 1) {break;}  
	}										// 1 at position [j,k] -> choose submatrix without this entry
		
	if(j==1){
		newrows = 2..number_rows;
	} else{ 
		if (j == number_rows){
			newrows = 1..number_rows-1; 
		} else{
			newrows = 1..j-1,j+1,,number_rows;
		}
	}
	if(k==1){
		newcols = 2..number_cols;
	} else{ 
		if (k == number_cols){
			newcols = 1..number_cols-1; 
		} else{
			newcols = 1..k-1,k+1,,number_cols;
		}
	}
	matrix M = submat(redN,newrows,newcols);
	
	minorsize[1] = minorsize[1] - 1;	//internal note that the desired minorsize has decrease
	
	return(M);
}example{
	//Todo
}

proc skewsymmetric_gauss(matrix N, int number_rows, int number_cols)	//TODO: compute the map of abb
"USAGE: skewsymmetric_gauss(matrix N, int number_rows, int number_cols ); computes the gaussian steps in the resolution process.
RETURN: transformed matrix M
EXAMPLE: example skewsymmetric_gauss; shows an example
"
{		
	int i,j,k,l;
	intvec newcols, newrows;
	intvec coordinatesOfOne = 0,0;
	
	intvec cols = 1..number_cols;
	intvec rows = 1..number_rows;

	matrix redN = submat(N,rows,cols);
	//destroys the skewsymmetric structure :
	//matrix redN = rowred(colN);
	
	for(j = 1; j<= number_rows;j++){
		for(k = 1; k<= number_cols;k++){
			if(redN[j,k] == 1) {coordinatesOfOne = j,k;}				// 1 at position [j,k] -> choose submatrix without this entry
		} 
	}										
	if(coordinatesOfOne[1] == 0){~;}
	
	matrix Ntemp = redN;
	//[j,k] is the entry which equals 1 -> [k,j] equals -1
	for(i = 1; i <= number_rows; i++){									//row operations for the first 0-column
		for(l = 1; l<=number_cols; l++){
			if(i != coordinatesOfOne[1] and i != coordinatesOfOne[2]){
				redN[i,l] = Ntemp[i,l] - Ntemp[i,coordinatesOfOne[2]] * Ntemp[coordinatesOfOne[1],l];
			}
		}
	}
	Ntemp = redN;

	// let the column entries vanish:
	for(l=1;l<=number_cols;l++){
		if(coordinatesOfOne[2] != l){
			redN[coordinatesOfOne[1],l] = 0;
		}
	}
	Ntemp = redN;
	
	for(i = 1; i <= number_rows; i++){							//column operations for the second 0-row
		for(l = 1; l<=number_cols; l++){
			if(l!= coordinatesOfOne[2] and l!= coordinatesOfOne[1]){
				redN[i,l] = Ntemp[i,l] + Ntemp[i,coordinatesOfOne[1]] * Ntemp[coordinatesOfOne[2],l];
			}
		}
	}
	Ntemp = redN;
	
	// let the column entries vanish:
	for(i=1;i<=number_cols;i++){
		if(coordinatesOfOne[2] != i){
			redN[i,coordinatesOfOne[1]] = 0;
		}
	}
	Ntemp = redN;
	
	int changed = 0;
	for(i=1;i<=number_cols;i++){
		if(i != coordinatesOfOne[1] and i != coordinatesOfOne[2]){
			if(changed == 0){						// because we do not need a leading zero-entry in the intvec newcols
				newcols[1] = i;	
				changed = 1;
			}else{
				newcols = newcols,i;
			}	
		}
	}
	
	minorsize[1] = minorsize[1] - 2;	//internal note that the desired minorsize has decrease
	matrix M = submat(redN,newcols,newcols);
	return(M);
}example{
		//TODO
}

proc symmetric_gauss(matrix N, int number_rows, int number_cols)	//TODO: compute the map of abb
"USAGE: symmetric_gauss(matrix N, int number_rows, int number_cols ); computes the gaussian steps in the resolution process.
RETURN: transformed matrix M
EXAMPLE: example symmetric_gauss; shows an example
"
{		
	int i,j,k,l;
	poly epsilon;
	intvec newcols, newrows, cols, rows;
	intvec coordinatesOfOne;
	
	cols = 1..number_cols;
	rows = 1..number_rows;
	matrix redN = submat(N,rows,cols);
	
	for(j = 1; j<= number_rows;j++){
		for(k = 1; k<= number_cols;k++){
			if(redN[j,k] == 1) {coordinatesOfOne = j,k;}
		} 
	}										// 1 at position [j,k] -> choose submatrix without this entry
	
	epsilon = 1-redN[coordinatesOfOne[1],coordinatesOfOne[1]] * redN[coordinatesOfOne[2],coordinatesOfOne[2]];
	
	matrix Ntemp = redN;

	// distinguish diagonal and non-diagonal entries
	if(coordinatesOfOne[1] == coordinatesOfOne[2]){			
		for(i = 1; i <= number_rows; i++){							//row operations for the first 0-column
			for(l = 1; l <= number_cols; l++){
				if(i != coordinatesOfOne[1]){
					redN[i,l] = Ntemp[i,l] - Ntemp[i,coordinatesOfOne[1]] * Ntemp[coordinatesOfOne[1],l];
				}
			}
		}
		Ntemp = redN;

		// let the column entries vanish:
		for(i=1;i<=number_cols;i++){
			if(coordinatesOfOne[1] != i){
				redN[coordinatesOfOne[1],i] = 0;
			}
		}
		Ntemp = redN;
		minorsize[1] = minorsize[1] - 1;								//internal note that the desired minorsize has decrease
	}else{			//non-diagonal 1-entries [j,k] and [k,j]
		for(i = 1; i <= number_rows; i++){								//row operations for the first 0-column
			for(l = 1; l<=number_cols; l++){
				if(i != coordinatesOfOne[2]){
					redN[i,l] = Ntemp[i,l] - Ntemp[i,coordinatesOfOne[1]] * Ntemp[coordinatesOfOne[2],l];
				}
			}
		}
		Ntemp = redN;
		// let the column entries vanish:
		for(i=1;i<=number_cols;i++){
			if(coordinatesOfOne[1] != i){
				redN[coordinatesOfOne[2],i] = 0;
			}
		}
		Ntemp = redN;
		
		//Divide and multiply with epsilon:
		redN[coordinatesOfOne[1],coordinatesOfOne[2]] = 1;
		Ntemp = redN;
		
		for(i = 1;i<= number_rows; i++){
			if(i!=coordinatesOfOne[1] and i != coordinatesOfOne[2]){
				for(l=1; l<= number_cols; l++){
					if(l!=coordinatesOfOne[1] and l != coordinatesOfOne[2]){
						redN[i,l] = redN[i,l] * epsilon;
					}
				}
			}
		}
		
		Ntemp = redN;
		for(i = 1; i <= number_rows; i++){								//row operations for the second 0-column
			for(l = 1; l<=number_cols; l++){
				if(i != coordinatesOfOne[1]){
					redN[i,l] = Ntemp[i,l] - Ntemp[i,coordinatesOfOne[2]] * Ntemp[coordinatesOfOne[1],l];
				}
			}
		}

		Ntemp = redN;		
		// let the column entries vanish:
		for(i=1;i<=number_cols;i++){
			if(coordinatesOfOne[2] != i){
				redN[coordinatesOfOne[1],i] = 0;
			}
		}
		Ntemp = redN;
		minorsize[1] = minorsize[1] - 2;								//internal note that the desired minorsize has decrease
	}
	
	int changed = 0;
	for(i=1;i<=number_cols;i++){
		if(i != coordinatesOfOne[1] and i != coordinatesOfOne[2]){
			if(changed == 0){											// because we do not need a leading zero-entry in the intvec newcols
				newcols[1] = i;	
				changed = 1;
			}else{
				newcols = newcols,i;
			}	
		}
	}
	
	matrix M = submat(redN,newcols,newcols);
	return(M);
}example{
		//TODO
}


proc generic_transformation_of_variables(matrix M)
"USAGE: generic_transformaion(matrix M); computes the transformation of variables
RETURN: list of matrix M and the ideal of the minors of the desired size
EXAMPLE: example generic_transformation_of_variables; shows an example
"
{
	int i,j;
	
	int number_cols = ncols(M);
	int number_rows = nrows(M);
	int new_nvars = 1; 											
	matrix newM = M;
	
	for(i = 1; i<= number_rows; i++){							
		for(j = 1; j<= number_cols; j++){
			newM[i,j] = var(new_nvars);
			new_nvars++;
		}
	}
	ideal minorideal = minor(newM,minorsize[1]);					//Calculate minor ideal of the right size
					
	return(newM, minorideal);
}example{
		//TODO
}



proc skewsymmetric_transformation_of_variables(matrix M)
"USAGE: skewsymmetric_transformation_of_variables(matrix M); computes the transformation of variables
RETURN: list of matrix M and the ideal of the minors of the desired size
EXAMPLE: example skewsymmetric_transformation_of_variables; shows an example
"
{
	int i,j;
	
	int number_cols = ncols(M);
	int number_rows = nrows(M);
	int new_nvars = 1; 											
	matrix newM = M;

	for(i = 1; i<= number_rows; i++){							
		for(j = i+1; j<= number_cols; j++){
			if(M[i,j] != 0){
				newM[i,j] = var(new_nvars);
				newM[j,i] = -var(new_nvars);
				new_nvars++;
			}
		}
	}
	ideal minorideal = minor(newM,minorsize[1]);						//Calculate minor ideal of the right size
	return(newM, minorideal);	
}example{
	//TODO	
}

proc symmetric_transformation_of_variables(matrix M)
"USAGE: symmetric_transformation_of_variables(matrix M); computes the transformation of variables
RETURN: list of matrix M and the ideal of the minors of the desired size
EXAMPLE: example symmetric_transformation_of_variables; shows an example
"
{
	int i,j;
	
	int number_cols = ncols(M);
	int number_rows = nrows(M);
	int new_nvars = 1; 											
	matrix newM = M;

	for(i = 1; i<= number_rows; i++){							
		for(j = i; j<= number_cols; j++){
			if(M[i,j] != 0){
				newM[i,j] = var(new_nvars);
				newM[j,i] = var(new_nvars);
				new_nvars++;
			}
		}
	}
	ideal minorideal = minor(newM,minorsize[1]);						//Calculate minor ideal of the right size
	return(newM, minorideal);	
}example{
	//TODO	
}

//----------------------------------------------------------------------

proc test_generic_vs_resolve(int m,int n){

	link l2 = ":w Testfaelle/resolve.txt";
	link l1 = ":w Testfaelle/generic_resolve.txt";
	
	list linklist = list(l1,l2);
	int i; int j;
	ring r = 0,(x(1..m*n)),dp;
	matrix M = genericmat(m,n);
	int minorsize = min(m,n);
	ideal I = minor(M,minorsize);		//maximal minors
	list blowuplist;
	
	list sum_runtime = list(0,0,0,0);
	list sum_endcharts = list(0,0,0,0);
	list sum_charts = list(0,0,0,0);
	int runningtime = 0;
	int whole_runningtime = 0;
	int tmp_runningtime = 0;
	
	//Test binomial-calculations:
	for(minorsize=3;minorsize<=min(m,n); minorsize++){
		//f = create_test_binomial(maxdegree, mode);
		I = minor(M,minorsize);
		tmp_runningtime = rtimer;
		blowuplist = generic_resolve(m,n,minorsize);
		runningtime = rtimer - tmp_runningtime;	
		//fprintf(linklist[i],"binomial: %l	endcharts: %s	charts: %s	runtime: %s",f,blowuplist[2],size(blowuplist[1]),blowuplist[4]);	
		fprintf(linklist[1]," Matrix: %s	minorsize: %s	endcharts: %s	charts: %s	running time: %s",M,minorsize,blowuplist[3],blowuplist[2], runningtime);	
		// only for later stats calculations:
		
		//sum_runtime[i] = sum_runtime[i] + blowuplist[4];
		//sum_endcharts[i] = sum_endcharts[i] + blowuplist[2];
		//sum_charts[i] = sum_charts[i] + size(blowuplist[1]);
		tmp_runningtime = rtimer;
		blowuplist = resolve(I);
		runningtime = rtimer - tmp_runningtime;	
		fprintf(linklist[2]," Matrix: %s	minorsize: %s	endcharts: %s	charts: %s	running time: %s", M,minorsize,size(blowuplist[1]),size(blowuplist[2]), runningtime);
		
	}
	
	
	//compute average values:
	//list average_runtime 	= list(sum_runtime[1] div binomialcount, sum_runtime[2] div binomialcount, sum_runtime[3] div binomialcount, sum_runtime[4] div binomialcount); 
	//list average_endcharts 	= list(sum_endcharts[1] div binomialcount, sum_endcharts[2] div binomialcount, sum_endcharts[3] div binomialcount, sum_endcharts[4] div binomialcount);
	//list average_charts 	= list(sum_charts[1] div binomialcount, sum_charts[2] div binomialcount, sum_endcharts[3] div binomialcount, sum_endcharts[4] div binomialcount);
	
	//compute the stats:
	//for(i = 1;i<=size(linklist);i++){
	//	fprintf(linklist[i],"average-endcharts: %s	average-charts: %s	average-runtime: %s",average_endcharts[i],average_charts[i],average_runtime[i]);	
	//}
	
	//close files:
	close(l1);
	close(l2);
	//close(l3);
	//close(l4);
}


proc test_skew_vs_resolve(int m){

	link l2 = ":w Testfaelle/resolve_skew.txt";
	link l1 = ":w Testfaelle/skew_generic.txt";
	
	list linklist = list(l1,l2);
	int i; int j;
	ring r = 0,(x(1..m*(m-1)div 2)),dp;
	matrix M = skewmat(m);
	int minorsize = m;
	ideal I = minor(M,minorsize);		//maximal minors
	list blowuplist;
	
	int runningtime = 0;
	int whole_runningtime = 0;
	int tmp_runningtime = 0;
	
	//Test binomial-calculations:
	for(minorsize=4;minorsize<=m; minorsize=minorsize+2){
		//f = create_test_binomial(maxdegree, mode);
		I = radical(std(minor(M,minorsize)));
		tmp_runningtime = rtimer;
		blowuplist = skewsymmetric_resolve(m,minorsize);
		runningtime = rtimer - tmp_runningtime;	
		//fprintf(linklist[i],"binomial: %l	endcharts: %s	charts: %s	runtime: %s",f,blowuplist[2],size(blowuplist[1]),blowuplist[4]);	
		fprintf(linklist[1]," Matrix: %s	minorsize: %s	endcharts: %s	charts: %s	running time: %s",M,minorsize,blowuplist[3],blowuplist[2], runningtime);	
		// only for later stats calculations:
		
		//sum_runtime[i] = sum_runtime[i] + blowuplist[4];
		//sum_endcharts[i] = sum_endcharts[i] + blowuplist[2];
		//sum_charts[i] = sum_charts[i] + size(blowuplist[1]);
		tmp_runningtime = rtimer;
		blowuplist = resolve(I);
		runningtime = rtimer - tmp_runningtime;	
		fprintf(linklist[2]," Matrix: %s	minorsize: %s	endcharts: %s	charts: %s	running time: %s", M,minorsize,size(blowuplist[1]),size(blowuplist[2]), runningtime);
		
	}
	
	
	//compute average values:
	//list average_runtime 	= list(sum_runtime[1] div binomialcount, sum_runtime[2] div binomialcount, sum_runtime[3] div binomialcount, sum_runtime[4] div binomialcount); 
	//list average_endcharts 	= list(sum_endcharts[1] div binomialcount, sum_endcharts[2] div binomialcount, sum_endcharts[3] div binomialcount, sum_endcharts[4] div binomialcount);
	//list average_charts 	= list(sum_charts[1] div binomialcount, sum_charts[2] div binomialcount, sum_endcharts[3] div binomialcount, sum_endcharts[4] div binomialcount);
	
	//compute the stats:
	//for(i = 1;i<=size(linklist);i++){
	//	fprintf(linklist[i],"average-endcharts: %s	average-charts: %s	average-runtime: %s",average_endcharts[i],average_charts[i],average_runtime[i]);	
	//}
	
	//close files:
	close(l1);
	close(l2);
	//close(l3);
	//close(l4);
}

proc test_skew(int m){
	link l1 = ":w Testfaelle/skew_generic_number_charts.txt";
	
	list linklist = list(l1);
	int i; int j;
	ring r = 0,(x(1..m*(m-1)div 2)),dp;
	matrix M = skewmat(m);
	int minorsize = m;
	ideal I = minor(M,minorsize);		//maximal minors
	list blowuplist;
	
	int runningtime = 0;
	int whole_runningtime = 0;
	int tmp_runningtime = 0;
	
	//Test binomial-calculations:
	for(minorsize=4;minorsize<=m; minorsize=minorsize+2){
		tmp_runningtime = rtimer;
		blowuplist = skewsymmetric_resolve(minorsize,minorsize);
		runningtime = rtimer - tmp_runningtime;	
	
		fprintf(linklist[1],"	minorsize: %s	endcharts: %s	charts: %s	running time: %s",minorsize,blowuplist[3],blowuplist[2], runningtime);	

	}

	close(l1);
}



proc binomial_test_generic_vs_resbinomial(int m){		//only 2-minors of generic jxj matrices for 2<=j<=m

	link l3 = ":w Testfaelle/resbinomial2.txt";
	
	link l2 = ":w Testfaelle/binomial_resolve.txt";
	link l1 = ":w Testfaelle/binomial_generic_resolve.txt";
	
	list linklist = list(l1,l2,l3);
	int i; int j;
	ring r = 0,(x(1..m*2)),dp;
	matrix M = genericmat(m,2);
	int minorsize = 2;
	ideal I = minor(M,minorsize);		//maximal minors
	list blowuplist;
	
	list sum_runtime = list(0,0,0,0);
	list sum_endcharts = list(0,0,0,0);
	list sum_charts = list(0,0,0,0);
	int runningtime = 0;
	int whole_runningtime = 0;
	int tmp_runningtime = 0;
	
	//Test binomial-calculations:
	for(j=4;j<=m;j++){
		//f = create_test_binomial(maxdegree, mode);
		M = genericmat(j,2);
		I = minor(M,minorsize);
		tmp_runningtime = rtimer;
		blowuplist = generic_resolve(j,j,minorsize);
		runningtime = rtimer - tmp_runningtime;	
		//fprintf(linklist[i],"binomial: %l	endcharts: %s	charts: %s	runtime: %s",f,blowuplist[2],size(blowuplist[1]),blowuplist[4]);	
		fprintf(linklist[1]," Matrix: %s	minorsize: %s	endcharts: %s	charts: %s	running time: %s",M,minorsize,blowuplist[3],blowuplist[2], runningtime);	
		
		tmp_runningtime = rtimer;
		blowuplist = resbinomial2(I);
		runningtime = rtimer - tmp_runningtime;	
		fprintf(linklist[3]," Matrix: %s	minorsize: %s	endcharts: %s	charts: %s	running time: %s", M,minorsize,size(blowuplist[1]),size(blowuplist[2]), runningtime);

	}
	
	//close files:
	close(l1);
	close(l2);
	close(l3);

}


