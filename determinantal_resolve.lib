version=" "; // $Id$
category=" ";
info="
LIBRARY:  determiantal_resolve.lib 
AUTHOR:  Sabrina Alexandra Gaube, sabrina.gaube@uol.de

PROCEDURES:

	determinantal_resolve(matrix M, int r);
	
	calculate_process_of_center_calculation(matrix M); returns the status of the algorithm as a string
	isSimultaneouslyLocallyMonomial(matrix M); returns if the entries of M are simultaneously locally monomial
	isLocallyMonomial(matrix M); returns if the entries of M are locally monomial
	isMonomial(matrix M); returns if the entries of M are monomial
	isresolvedMonomial(matrix M); returns if the entries of M are monomial and the monomial ideal generated by the entries is non-singular

	GenerateListOfBinomials(matrix M); return a list of entries of M which are not locally monomial
	UpdateListofBinomials(list L); where L is a list which was generated by GenerateListOfBinomials(M) and where we have to delete entries after some blow ups
	CreateBinomialFromMonomialMatrix(matrix M); calculate the binomial ideal (in the monomial case) which determines via black box the resolution process 


	blowUp3(J, C, #); same like blowUp2 but with the subcall blowUpBO(BO,C,2) instead of blowUpBO(BO,C,1);
	main_generic_resolve(mode, m, #); main method for resolution of all generic matrices, with string parameter mode
	generic_resolve(m, n, #); call method for resolution of generic mxn matrices
	skewsymmetric_resolve(m); call method for resolution of generic skewsymmetric mxm matrices
	symmetric_resolve(m); call method for resolution of generic ymmetric mxm matrices
	
	CopyDataInNextChartsAndBlowUp(M, Center, chartnumber); blow up method which copies data in the successor charts
	weakTransformOfMatrix(N); given a blown up matrix N it calculates the weak transform of a matrix with respect to rows and columns 
	
	generic_gauss(N, number_rows, number_cols); calculates the gaussian steps for the generic case
	skewsymmetric_gauss(N, number_rows, number_cols); gaussian steps for the skewsymmetric case 
	symmetric_gauss(N, number_rows, number_cols); gaussian steps for the symmetric case
	
	generic_transformation_of_variables(M); transformation of variables for the generic case
	skewsymmetric_transformation_of_variables(M); transformation of variables for the skewsymmetric case
	symmetric_transformation_of_variables(M); transformation of variables for the symmetric case
	
";

LIB "matrix.lib";
//LIB "resolve.lib";
LIB "hualgorithm.lib";
LIB "general.lib";	//absValue
LIB "test_ring.lib"; 			//covering calculation

LIB "resbinomial_neu.lib"; //only for performancetests

proc blowUp3(ideal J,ideal C,list #)
"USAGE:  blowUp3(J,C[,W][,E]);
         W,J,C = ideals,
         E     = list
ASSUME:  J  = ideal containing W ( W = 0 if not specified)
@*       C  = ideal containing J
@*       E  = list of smooth hypersurfaces (e.g. exceptional divisors)
NOTE:    W the ideal of the ambient space, C the ideal of the center of
         the blowup and J the ideal of the variety
         Important difference to blowUp2:
         - the ambient space V(W) is blown up and V(J) transformed in it
@*         - V(C) is assumed to be non-singular
COMPUTE: the blowing up of W in C, the exceptional locus, the strict
         transform of J and the blowup map
RETURN:  list, say l, of size at most size(C),

         l[i] is the affine ring corresponding to the i-th chart
         each l[i] contains the ideals
         - aS, ideal of the blownup ambient space
         - sT, ideal of the strict transform
         - eD, ideal of the exceptional divisor
         - bM, ideal corresponding to the blowup map

         l[i] also contains a list BO, which can best be viewed with showBO(BO)
         detailed information on the data type BO can be viewed via the
         command showDataTypes();
EXAMPLE: example blowUp;  shows an example
"
{
  def S=basering;
  ideal W;
  list E;
  ideal abb=maxideal(1);
  intvec v;
  intvec bvec;
  intvec w=-1;
  matrix intE;
  if(size(#)>0)
  {
    if(typeof(#[1])=="ideal")
    {
      W=#[1];
    }
    if(typeof(#[1])=="list")
    {
      E=#[1];
    }
    if(size(#)>1)
    {
      if((typeof(#[2])=="list") && (size(E)==0))
      {
        E=#[2];
      }
      if((typeof(#[2])=="ideal") && (size(W)==0))
      {
        W=#[2];
      }
    }
  }
  list BO=W,J,bvec,E,abb,v,w,intE;
  int locaT;
  export locaT;
  list blow=blowUpBO(BO,C,2);
  kill locaT;
  int i;
  for(i=1;i<=size(blow);i++)
  {
     def Q=blow[i];
     setring Q;
     ideal aS=BO[1];
     ideal sT=BO[2];
     ideal eD=BO[4][size(BO[4])];
     ideal bM=BO[5];
     kill lastMap;
     kill thisChart;
     export(aS);
     export(sT);
     export(eD);
     export(bM);
     blow[i]=Q;
     setring S;
     kill Q;
  }
  return(blow);
}
example
{"EXAMPLE:";
   echo = 2;
   ring R=0,(x,y),dp;
   ideal J=x2-y3;
   ideal C=x,y;
   list blow=blowUp3(J,C);
   def Q=blow[1];
   setring Q;
   aS;
   sT;
   eD;
   bM;
}
//----------------------------------------------------------------------
//TODO
//BO killen wenn final chart für binresolve ODER det monomial case -> 1 entry
//centerlist nicht killen, wenn leer 
//TODO: erkenne wenn r-minoren aufgelöst sind!
proc determinantal_resolve(matrix M, int sizeOfMinor){
	if(sizeOfMinor > min(nrows(M), ncols(M))){
		ERROR("There are no r-minors in M");
	}
	
	list datalist = createDatalist(M,sizeOfMinor);	
	//ideal minorideal = minor(M,sizeOfMinor);									// Zusätzlich prüfen ob 'fertig' ???
	
	module path = [0,-1];												//path of the current chart, autoconverted to matrix
	export(path);
	
	list BlowUpTree;
	BlowUpTree[1] = basering;
	list EndCharts;
	
	string stat = datalist[3][1];
	ideal cent;
	export(cent);
	//------------------------------------------------------------------
	//TODO 
	//init data structure depending on the status
	list minorsize  = datalist[3][2];
	export(minorsize);
	while(stat == "gauss"){			//the only status without centers. Can obtain more than once in a row 
		M = generic_gauss(M, nrows(M), ncols(M));
		stat = calculate_process_of_center_calculation(M);
		datalist[3][2] = minorsize;
	}
	if(stat == "binresol"){
		//create list of binomials
		list binomiallist = GenerateListOfBinomials(M);
		//init  BO in the data type of resbinomial2
		ideal J = binomiallist[1];
		list BO = createBO(J);
	}
	if(stat == "Hu"){
		//we get a list of centers
		list centerlist = HuAlgorithm(M);
		//first centers are the centers on level????
		//TODO Optimation: Only add necessary centers to centerlist
	}
	if(stat == "transformation"){
		cent = 0;		//dummy value; in order to identify it in the blow up method. In there we calculate the covering.
	}
	if(stat == "monomial"){
		def r = basering;
		ring rnew = CreateBinomialFromMonomialMatrix(M);
		ideal J = retideal; //was created in method and is global in the ring rnew
		list BO = createBO(J);
		
		//TODO: fetch everything
		//fetch datalist:
		list datalist;
		datalist[1] = fetch(r,datalist[1]);
		datalist[2] = fetch(r,datalist[2]);		
		datalist[3] = fetch(r,datalist[3]);		
		datalist[4] = fetch(r,datalist[4]);
		datalist[5] = fetch(r,datalist[5]);
		datalist[6] = fetch(r,datalist[6]);
		def path = fetch(r,path);				 
		export(BO);
		export(datalist);
		export(path);
	}
	
	if((min(ncols(M),nrows(M)) == 1) or (minorsize[1] == 1)){
		return(resbinomial2(minor(M,1)));			//resolve ideal of the (binomial) entries of M
	}
	
	datalist[3][1] = stat;
	//compute the center
	//IMPORTANT: ONLY centerlist OR BO should be defined!!!
	// DELETE BO in final charts of resbinomial2
	//centerlist in HU should be automatically deleted

	if(defined(BO)){
		cent = calculate_center(BO,"BO");	
	}
	if(defined(centerlist)){
		if(size(centerlist)>1){
			cent = calculate_center(centerlist,"Hu");	//TODO later delete superfluent entries in centerlist
		}else{
			stat = "transformation";
			datalist[3][1] = stat;
		}
	}

	BlowUpTree = BlowUpTree +  CopyDataInNextChartsAndBlowUp(M,cent,1);
	
	int i,j,k;	
	int number_cols, number_rows;
	int mindim;
	int chart_counter = size(BlowUpTree);
	
	int oldsize;	//maybe usefull for optimizations, when checking whether we reach r-minors as entries

	for(i = 2; i<= size(BlowUpTree);i++){			
		if(defined(Chart)){
			kill(Chart);
		}
		if(defined(rnew)){
			kill(rnew);
		}
		def Chart = BlowUpTree[i];
		setring(Chart);
		
		matrix M = datalist[2];
		int number_cols = ncols(M);
		int number_rows = nrows(M);
		int mindim = min(ncols(M),nrows(M));
					
		//if we are in the middle of a resolve or a HU resolution, shorten the process and going on!
		if(defined(BO) or defined(centerlist)){
			if(defined(BO)){
				ideal cent = compute_center();			//BO could be deleted if center equals 1; No center than
				if(EqualityOfIdeal(cent,1) == 1){
					kill(center);
				}else{
					export(cent);
				}
			}
			if(defined(centerlist)){
				if(size(centerlist) > 1){
					ideal cent = calculate_center(centerlist,"Hu");	//TODO later delete superfluent entries in centerlist
					export(cent);
				}else{
					stat = "transformation";
					datalist[3][1] = stat;
				}
			}	
		}
		
		if(!defined(cent)){				//new status have to start; no center already choosen
			stat = calculate_process_of_center_calculation(M);
			datalist[3][1] = stat;
			ideal cent;
			export(cent);
			list minorsize  = datalist[3][2];
			export(minorsize);
			while(stat == "gauss"){			//the only status without centers. Can obtain more than once in a row 
				M = generic_gauss(M, nrows(M), ncols(M));
				stat = calculate_process_of_center_calculation(M);
				datalist[3][1] = stat;
				datalist[3][2] = minorsize;
			}
			//init data structure depending on the status
			if(stat == "binresol"){
				//create list of binomials
				list binomiallist = GenerateListOfBinomials(M);
				//init  BO in the data type of resbinomial2
				ideal J = binomiallist[1];
				list BO = createBO(J);
				cent = compute_center(BO,"BO");
			}
			if(stat == "Hu"){
				list centerlist = HuAlgorithm(M);
				cent = compute_center(centerlist,"Hu");		
			}
			//TODO Optimation: Only add necessary centers to centerlist
			
			if(stat == "transformation"){
				cent = 0; //No blow up but the covering generates new charts 
				// Only a dummy value
			}
			if(stat == "monomial"){

				ring rnew = CreateBinomialFromMonomialMatrix(M);	//Modify method s.t. it exports datalist and path automatically

				ideal J = retideal; //was created in method and is global in the ring rnew
				list BO = createBO(J);
		
				//TODO: fetch everything
				//fetch datalist:
				list datalist;
				datalist[1] = fetch(Chart,datalist[1]);
				datalist[2] = fetch(Chart,datalist[2]);		
				datalist[3] = fetch(Chart,datalist[3]);		
				datalist[4] = fetch(Chart,datalist[4]);
				datalist[5] = fetch(Chart,datalist[5]);
				datalist[6] = fetch(Chart,datalist[6]);		
				def path = fetch(r,path);		 
				export(BO);
				export(datalist);
				export(path);
				//substitute achtual chart in ringlist:
				kill(Chart);
				BlowUpTree[i] = rnew;
				cent = compute_center(BO,"BO");
			}
		
			if(min(ncols(M),nrows(M)) == 1){	// binomial ideal -> resbinomial2
				list BO = createBO(minor(M,1));
				ideal cent = calculate_center(BO);
				export(cent);
			}
		}
		if(EqualityOfIdeal(cent,1) == 0 ){
			//TODO: pruefe ob r-minoren resolved sind
			if(rMinorsResolved(datalist) == 0){		
				BlowUpTree = BlowUpTree + CopyDataInNextChartsAndBlowUp(datalist,cent,i);	
			}else{
				EndCharts[size(EndCharts)+1] = BlowUpTree[i];
			}
		}else{
			EndCharts[size(EndCharts)+1] = BlowUpTree[i];
		}
	}
	
	
	//------------------------------------------------------------------
	
	
	setring(r);
	if(defined(Chart)){
		kill(Chart);
	}
	if(defined(rnew)){
		kill(rnew);
	}
	
	return(EndCharts,BlowUpTree);
}example{
	ring r = 0,(x(1..4)),dp;
	matrix M = genericmat(2,2);
	determinantal_resolve(M,2);
}
//----------------------------------------------------------------------

proc createDatalist(matrix M, int r ){
	list minorsize = list(r,var(1));			//  variable and list is only technically in order that we can store the list in the ring!!!

	list datalist = list();
	datalist[1] = ideal(0);
	datalist[2] = M;
	datalist[3] = list(calculate_process_of_center_calculation(M),minorsize);
	datalist[4] = list();
	ideal abb = maxideal(1);
	datalist[5] = abb;
	datalist[6] = list();
	return(datalist);
}



proc rMinorsResolved(list datalist){
	int r = datalist[3][2][1];
	ideal minorideal = minor(datalist[2],r);
	
	return(isSmooth(minorideal));	
}

//----------------------------------------------------------------------
//TODO: Lists BO and centerlist have to be global!
proc calculate_center(){

	int i,j;
	int n = nvars(basering);
	
	ideal center;
	if(defined(centerlist)){
		//assume: centerlist is not empty!
		list tmplist = centerlist[size(centerlist)];
		center = tmplist[size(tmplist)];
		centerlist[1] = delete(tmplist,size());			//Always choose LAST entry of list and delete it
		if(size(centerlist) == 0){
			kill(centerlist);
			//TODO: Tag setzen, damit wir im nächsten Schritt sparen können Hu neu zu berechnen!!!
		}
	}
	if(defined(BO)){
		list Descendlist = calculate_centerBO(BO, 1);  
		BO = Descendlist[1][1]; 	//Only the first BO needed
		center = Descendlist[3];
		if(EqualityOfIdeal(center,1) == 1){		//final chart in resolve.lib
			kill(BO);													//TODO!!!! neuen status ermitteln und dann dadrin weitermachen
		}
		if(defined(BO)){
			if(datalist[3][1] == "monomial"){
				//remove unneeded charts and center components
				matrix M = datalist[2];
				ideal varmatrix = variables(M);
				for(i = 1; i<=n;i++){
					if(EqualityOfIdeal(reduce(varmatrix,var(i)), varmatrix) == 1){		// var(i) not in matrix
						for(j=1;j<=size(center);j++){
							if(center[j] == var(i)){
								center = delete(center,j);			//remove center component
							}
						}
					}
				}
			}
		}
	}
	
	
	return(center);
}
//dummy function for later improvements and more flexibility
//TODO: Implement more other methods and add a tag which chooses the right one!
proc calculate_centerBO(list L, int chartnumber){
	return(DescendInDimension(L,chartnumber));
}

//----------------------------------------------------------------------
proc calculate_process_of_center_calculation(matrix M)
"USAGE: calculate_process_of_center_calculation(matrix M); returns the status of the algorithm as a string
RETURN: a string which encodes the status of the resolution process
EXAMPLE: example calculate_process_of_center_calculation; shows an example
"
{	
	if(isLocallyMonomial(M) == 0){
		return("binresol");
	}
	if(isMonomial(M) == 1 and isresolvedMonomial(M) == 0){ 
		return("monomial");
	}
	if(isresolvedMonomial(M) == 1){
		return("gauss");
	}
	//TODO: Check if only the ideal of minors equals <1> or if there is a 1-entry!!!
	// can assume that entries are at least locally monomial here
	if(isLocallyMonomial(M) == 1 and isSimultaneouslyLocallyMonomial(M) == 0){
		return("Hu");
	}
	if(isSimultaneouslyLocallyMonomial(M) and isMonomial(M) == 0){
		return("transformation");
	}

	return("");
}

//----------------------------------------------------------------------
proc isLocallyMonomial(matrix M)
"USAGE: isLocallyMonomial(matrix M); 
RETURN: 1 if the entries of M are locally monomial, 0 if there is an entry which is not locally monomial
EXAMPLE: example isLocallyMonomial; shows an example
"
{ // only 1-x^A equations allowed //TODO: ausfaktorisieren, da y(1-x^A) vorkommen kann
	int i,j,k;
	int LocallyMonomial = 1;
	int number_cols = ncols(M);
	int number_rows = nrows(M);
	list factorlist;
	
	for(i=1;i<=number_rows;i++){
		for(j=1; j<= number_cols; j++){
			if(size(M[i,j])>1){				// at least binomial
				factorlist = factorize(M[i,j]);
				if(size(factorlist[1]) == 2){					//nothing to factor out
					if(absValue(M[i,j][1]) != 1 and absValue(M[i,j][2]) != 1){		//M[i,j] = 1-x^A or x^A-1
						LocallyMonomial = 0;
					}
				}else{	//(x^A-x^B) factor out and search the binomial factor
					for(k=2;k<=size(factorlist[1]);k++){
						if(size(factorlist[1][k]) >1){			
							if(absValue(factorlist[1][k][1]) != 1 and absValue(factorlist[1][k][2]) != 1){		//M[i,j] = y^C(1-x^A) or y^C(x^A-1)
								LocallyMonomial = 0;
							}
						}
					}
				}
			}
		}
	}	
	return(LocallyMonomial);
}example{
	ring r =0, (x,y,z),dp;
	matrix M[3][2] = x,y,z,xy,1-x*y*z,2x;
	print(M);
	isLocallyMonomial (M);
	
	matrix N[3][2] = x^2+y,y,z,xy,1-x^3*y,2x;
	print(N);
	isLocallyMonomial(N);
}


//----------------------------------------------------------------------
proc isSimultaneouslyLocallyMonomial(matrix M)
"USAGE: isSimultaneouslyLocallyMonomial(matrix M); 
RETURN: 1 if the entries of M are simultaneously locally monomial, 0 if there is an entry which is not simultaneously locally monomial
EXAMPLE: example isSimultaneouslyLocallyMonomial; shows an example
"
{
	int i,j,k;
	
	if(isLocallyMonomial(M) == 0){
		return(0);
	}
	for(i=1;i<=number_rows;i++){
		for(j=1; j<= number_cols; j++){
			factorlist = factorize(M[i,j]);
			if(size(factorlist[1]) > 2){			//modify element and factor out! TODO: Only exceptional components?!?!
				for(k=2;k<=size(factorlist[1]);k++){
					if(size(factorlist[1][k]) >1){			
						M[i,j] = factorlist[1][k];
					}
				}
			}		
		}
	}
	print(M);
	//modifies entries of the form y^C(1-x^B); y^C exceptional 
	list centerlist = HuAlgorithm(M);			
	if(size(centerlist) == 1){				//emptylist is the only entry
		return(1);
	}
	return(0);
}example{
	ring r =0, (x,y,z),dp;
	matrix M[2][2] = 1-x,1-y,1-z,1;
	print(M);
	isSimultaneouslyLocallyMonomial (M);
	
	ring r2 =0, (x,y),dp;
	matrix N[2][2] = 1-x,1-y,1-xy,1-xy;
	print(N);
	isSimultaneouslyLocallyMonomial(N);
}



//----------------------------------------------------------------------
proc isMonomial(matrix M)
"USAGE: isMonomial(matrix M); 
RETURN: 1 if the entries of M are monomial, 0 if there is an entry which is not monomial
EXAMPLE: example isMonomial; shows an example
"
{
	 // only x^A equations allowed
	int i,j,k;
	int Monomial = 1;
	int number_cols = ncols(M);
	int number_rows = nrows(M);
	
	for(i=1;i<=number_rows;i++){
		for(j=1; j<= number_cols; j++){
			if(size(M[i,j]) > 1){				// at least binomial
				Monomial = 0;
			}
		}
	}	
	return(Monomial);
}example{
	ring r =0, (x,y,z),dp;
	matrix M[3][2] = x,y^3,z,xy,x*y*z,2x;
	print(M);
	isMonomial (M);
	
	matrix N[3][2] = x^2,y,z,xy,1-x^3*y,2x;
	print(N);
	isMonomial (N);
}


//----------------------------------------------------------------------
proc isresolvedMonomial(matrix M)
"USAGE: isresolvedMonomial(matrix M); 
RETURN: 1 if the entries of M are monomial and there is at least one 1 entry, 0 otherwise
EXAMPLE: example isresolvedMonomial; shows an example
"
{ // only x^A equations allowed
	int i,j;
	int resolved = 0;
	int number_cols = ncols(M);
	int number_rows = nrows(M);
	
	if(isMonomial(M) == 0){
		return(0);
	}

	ideal J = minor(M,1);					//Maybe ideal equals 1 but matrix has no 1-entry e.g. x and 1-x are in the ideal.... TODO create covering
	resolved = EqualityOfIdeal(J,1);			
	return(resolved);
}example{
	ring r =0, (x,y,z),dp;
	matrix M[3][2] = x,y^3,z,xy,x*y*z,2x;
	print(M);
	isresolvedMonomial(M);
	
	matrix N[3][2] = x^2,y,z,xy,1,2x;
	print(N);
	isresolvedMonomial (N);

}


//----------------------------------------------------------------------
// auxiliary procedures for the binomial case
//----------------------------------------------------------------------
proc GenerateListOfBinomials(matrix M)
"USAGE: GenerateListOfBinomials(matrix M); 
RETURN: a list of entries of M which are not locally monomial
EXAMPLE: example GenerateListOfBinomials; shows an example
"{
	int i,j;
	int number_cols = ncols(M);
	int number_rows = nrows(M);
	list returnlist;
	
	for(i=1;i<=number_rows;i++){
		for(j=1; j<= number_cols; j++){
			factorlist = factorize(M[i,j]);
			if(size(factorlist[1]) > 2){			//modify element and factor out! TODO: Only exceptional components?!?!
				for(k=2;k<=size(factorlist[1]);k++){
					if(size(factorlist[1][k]) >1){
						if(absValue(factorlist[1][k][1]) != 1 and absValue(factorlist[1][k][2]) != 1){			
							returnlist[size(returnlist)+1] = factorlist[1][k];	// -x(3)^4+x(2)^2 wird auch factorisiert!!!

						}
					}
				}
			} else{
				if(size(M[i,j])>1){				// at least binomial
					if(absValue(M[i,j][1]) != 1 and absValue(M[i,j][2]) != 1){		//M[i,j] != 1-x^A or x^A-1
						returnlist[size(returnlist)+1] = M[i,j];
					}
				}
			}
		}
	}				
	
	return(returnlist);
}example{
	ring r =0, (x,y,z),dp;
	matrix M[3][2] = 1-x,x*z-y^3,z,3xy,x*y*z,2x+z;
	print(M);
	GenerateListOfBinomials(M);
} 

proc UpdateListofBinomials(list L)
"USAGE: UpdateListofBinomials(list L); where L is a list which was generated by GenerateListOfBinomials(M) and where we have to delete entries after some blow ups
RETURN: a list of entries of M which are not locally monomial
EXAMPLE: example UpdateListofBinomials; shows an example
"{	
	int i,j;
	int sizeL = size(L);
	
	for(i=1;i<=sizeL;i++){
		if(isLocallyMonomial(L[i]) == 1){
			L = delete(L,i);
			sizeL = size(L);
			i--;
		}
	}				
	
	return(L);
}example{
	ring r =0, (x,y,z),dp;
	list L = 1-x,x*z-y^3,z,3xy,x*y*z,2x+z;
	UpdateListofBinomials(L);
}
	
//----------------------------------------------------------------------
// auxiliary procedures for the monomial case
//----------------------------------------------------------------------	
proc CreateBinomialFromMonomialMatrix(matrix M)
"USAGE: CreateBinomialFromMonomialMatrix(matrix M); calculate the binomial ideal (in the monomial case) which determines via black box the resolution process 
RETURN: the binomial ideal corresponding to the determinantal monomial case
EXAMPLE: example CreateBinomialFromMonomialMatrix; shows an example
"
{		//requires a monomial matrix M
	def r = basering;			//TODO: save ring in List of Data in order to change back afterwards
	int n = nvars(r);
	int i;
	
	
	ideal tmpideal = std(minor(M,1));
	int d = MaxOrd(0,tmpideal)[1];						//TODO: ambient space???
	int idealsize = size(tmpideal);						// we need 2*idealsize many new variables
	
	//ring tmpr = 0,(z(1..2*idealsize)),dp;				//Not necessary in char 0
	execute("ring tmpr=("+charstr(basering)+"),((u(1..n),z(1..idealsize))),(dp(n),dp(idealsize));");
	matrix Mnew = fetch(r,M);	//reihenfolge der variablen wichtig!
	//TODO: fetch whole datalist
	ideal tmpideal = fetch(r,tmpideal);
	ideal retideal;
	for(i=1;i<=idealsize;i++){
		retideal[i] = var(n+i)^d + tmpideal[i];			// J = <y_{2l}^{d-1}y_{2l+1} + x^{A_l}>, but we want to start with y_1 instead of y_2 
	}
	print(retideal);
	export(retideal);
	
	list datalist;
	datalist[1] = fetch(r,datalist[1]);
	datalist[2] = fetch(r,datalist[2]);
	datalist[3] = fetch(r,datalist[3]);
	datalist[4] = fetch(r,datalist[4]);
	datalist[5] = fetch(r,datalist[5]);
	datalist[6] = fetch(r,datalist[6]);
	export(datalist);
	def path = fetch(r,path);
	export(path);
	
	return(tmpr);		//seems that is only possible to return the ring and not change the ring in an external method; Everything else have to be exported!
}example{
		//TODO
}


proc finishedDetMonomialCase(list datalist){
	int i,j;
	
	def r = basering;
	
	ideal W = datalist[1];
	matrix M = datalist[2];
	list E = datalist[4];
	
	ideal sufficientVars = variables(M)+variables(W);
	for (i=1;i<= size(E);i++){
		sufficientVars = sufficientVars + variables(E);
	}
	int n = size(sufficientVars);
	string StringsufficientVars = string(sufficientVars);
	
	//Construct new ring with less variables
	execute("ring tmpr=("+charstr(basering)+"),("+StringsufficientVars+"),(dp(n));");
	
	//TODO: imap, da Reihenfolge unwichtig, gleicher Name auf gleichen Namen abbilden
	list datalist;
	datalist[1] = imap(r,datalist[1]);
	datalist[2] = imap(r,datalist[2]);
	datalist[3] = imap(r,datalist[3]);
	datalist[4] = imap(r,datalist[4]);
	datalist[5] = imap(r,datalist[5]);
	datalist[6] = imap(r,datalist[6]);
	export(datalist);
	def path = imap(r,path);
	export(path);
	return(tmpr);
}


//----------------------------------------------------------------------
//TODO: Ueberarbeiten; datentyp liste 
proc CopyDataInNextChartsAndBlowUp(list datalist, ideal Center, int chartnumber)
"USAGE: CopyDataInNextChartAndBlowUp(matrix M, ideal Center, int chartnumber ); computes the blow up and copies the data (strict transform, ideal and pathmatrix) in the successorcharts
RETURN: list of rings which represent the charts during the whole resolution process
EXAMPLE: example CopyDataInNextChartAndBlowUp; shows an example
"
{
	int j, number_cols,number_rows;
	def r = basering;
	int BOdefined, centerlistdefined;
	if(defined(BO)){BOdefined = 1;}
	if(defined(centerlist)){
		if(size(centerlist) >=1){
			centerlistdefined = 1;
		}else{
			centerlistdefined = -1;		//empty list -> change status
		}
	}
	
	ideal W = datalist[1];
	matrix M = datalist[2];
	string stat = datalist[3][1];					//Darauf achten, dass das auch immer gesetzt wird!
	list minorsize = datalist[3][2];
	list E = datalist[4];
	ideal abb = datalist[5];
	
	//TODO: Differ center == 0 (only transformation) and center != 0 case
	list successorList;
	
	if(EqualityOfIdeal(Center,0) == 1){	//Transformation status
		//TODO: generate a covering which are the next charts without a blow up!
		list covering = generateCovering(datalist);
		// auch unten in der for-schleife gesondert behandeln
	}else{	
		successorList = blowUp3(W,Center);
	}
	
	int number_center_components = size(successorList);

	


	for(j = 1;j<=number_center_components; j++){
		if(defined(newring)){kill newring;}
		
		def newring = successorList[j];
		setring(newring);
		map BlowUpMap = r,bM;		
		ideal W = BlowUpMap(W);
		//export(W);
		list datalist = list();
		export(datalist);
		datalist[1] = W;
		list E = BlowUpMap(E);
		E[size(E)+1] = eD[1];
		datalist[4] = E;
		
		if(BOdefined){ 
			list BO;			
			BO[1] = aS;
			BO[2] = sT;
			BO[4] = BlowUpMap(BO[4]);
			BO[4][size(BO[4])+1] = eD;
			BO[5] = bM;
			export(BO);
		}
		else{
			if(centerlistdefined == 1){
				list centerlist = BlowUpMap(centerlist);
				export(centerlist);
			}
			if(centerlistdefined == 1){
				string stat = "transformation";
			}
		}
		//Noch anderes mit übergeben?
		//alles einzeln abbilden
		//darauf achten, dass alles irgendwie ein ringelement hat
		ideal abb = BlowUpMap(abb);					//abbildung aus resbinomial2.lib //TODO: mit bM verknuepfen!!!!?
		datalist[5] = abb;	
		matrix N = BlowUpMap(M);				// total transform
		matrix Ntmp = weakTransformOfMatrix(N);
		datalist[2] = Ntmp;

		def path = imap(r,path);				//init pathmatrix 
		path=path,[chartnumber,j];
		export(path);
		

		datalist[3] = BlowUpMap(datalist[3]);
		datalist[3][2] = minorsize();
		list minorsize = datalist[3][2];
		export(minorsize);
		
		//determinantal monomial case is finished:
		if(datalist[3][1] == "monomial"){
			ideal Jmonom = minor(M,1);
			if(EqualityOfIdeal(Jmonom,1) == 1){
				kill(BO);
				//reduce variables in the ring
				def rnew = finishedDetMonomialCase(datalist);		//method exports, datalist and path
				setring(rnew);
				if(defined(newring)){
					kill(newring);
				}
			}
		}
		
		
		//HU is finished:
		if(defined(stat)){
			if(stat == "transformation"){
				datalist[3][1] = stat;
			}
		}else{
			datalist[3][1] =  calculate_process_of_center_calculation(Ntmp);
		}
		
	}
	return(successorList);
}example{
	ring r = 0,(x(1..12)),dp;
	matrix M = genericmat(3,4);
	CopyDataInNextChartsAndBlowUp(M,std(minor(M,1)),1);	
}




//TODO!!!
proc generateCovering(list datalist){
	//TODO
	matrix M = datalist[2];
	ideal I = generateListsimlocmon(M);
	
	
	int CoDimI = Codimension(I);
	//Berechnung der Menge L:
	matrix JI = jacob(I);
	list GeneratorList = GenerateL1(CoDimZ, J,I,0);
	list L1 = GeneratorList[1];
	list vectorsL1 = GeneratorList[2];
  
	ideal polynomialFi;
	int s; poly detM; list y; int member;
	matrix N;
	//matrix A;
	ideal Iold;
		
	for (member = 1; member <= size(L1); member++){ 	 //member stimmt mit i aus L und indices ueberein
		N = L1[member];
		detN = det(N);
		if(detN != 0){									//only need calculations if detM != 0
			y = SystemOfParameters( member, vectorsL1, CoDimI);  
			s = size(y);
			//Itemp = I;
			//A = inverse_L(N)[1]; 				//A is matrix of cofactors of M
			//TODO: I bzw. M mit neuen variablen darstellen
			//TODO Ring basteln
		}
	}
	
	//TODO:
	// generate ringlist and return it
	return(L1);
}


//Requires a simloc matrix M
proc generateListsimlocmon(matrix M){
		//TODO
		int i,j;
		ideal I;
		int maxcol = ncols(M);
		int maxrow = nrows(M);
		
		for(i=1; i<=maxrow; i++){
			for (j=1; j<=maxcol;j++){
				if(M[i,j] != 0 and M[i,j]!= 1){
					I[size(I)+1] = M[i,j];
				}
			}
		}		
		return(I);
}



//----------------------------------------------------------------------

// 				generic case

//----------------------------------------------------------------------
proc main_generic_resolve(string mode, int m, list #)
"USAGE:main_generic_resolve(string mode, int m[, int n , int r] ); computes the resolution of the ideal of r-minors of a (skew)-symmetric generic mxm matrix with mode = skew or mode = sym or generic mxn matrix with mode = gen
RETURN: list of rings which represent the charts during the whole resolution process
EXAMPLE: example generic_resolve; shows an example
"
{
	int minsize;
	if(mode == "gen"){
		if(size(#)>0){
			int n = #[1];
		}else{
			int n = m;
		}
		ring r = 0,(x(1..m*n)),dp;
		matrix M = genericmat(m,n);
		minsize = 1;
	}
	if(mode == "sym"){
		ring r = 0,(x(1..m*(m+1) div 2)),dp;
		matrix M = symmat(m);
		minsize = 1;			//TODO???
	}
	if(mode == "skew"){
		ring r = 0,(x(1..m*(m-1)div 2)),dp;
		matrix M = skewmat(m);
		minsize = 2;
	}
	if(!defined(r)){
		ERROR("choose a mode gen,sym or skew followed by the size of your generic matrix");
	}
	
	
	list minorsize = list(min(ncols(M),nrows(M)),var(1) );				// default: resolve maximal minors; variable and list is only technically in order that we can store the list in the ring!!!
	ideal minorideal = radical(minor(M,1));
	if(size(#)>1 and mode == "gen"){
		if(typeof(#[2])=="int"){
			minorsize[1] = #[2];										//calculate how long we have to blow up until the #[1]-minors are resolved
			minorideal = radical(minor(M,minorsize[1]));
		}
	}
	if(size(#)>0 and mode != "gen"){
		if(typeof(#[1])=="int"){
			minorsize[1] = #[1];										//calculate how long we have to blow up until the #[1]-minors are resolved
			minorideal = minor(M,minorsize[1]);
		}
	}
	
	export(minorsize);

	export(minorideal);
	
	module path = [0,-1];												//path of the current chart, autoconverted to matrix
	export(path);
	
	ideal W = ideal(0);													//ambient space; Maybe change this later
	export(W);
	list E = list();													// list of exceptional divisors
	export(E);
	ideal abb=maxideal(1);
	export(abb);
	
	list BlowUpTree;
	BlowUpTree[1] = basering;
	ideal cent = minor(M,1);											//auxiliary data 
	export(cent);
	
	if(minorsize[1] <= minsize){													// ideal of 1 minors is already resolved
		return(BlowUpTree,1,1);
	}
	
	BlowUpTree = BlowUpTree +  CopyDataInNextChartsAndBlowUp_generic(M,radical(minor(M,1)),1);
	int i; int j; int k;
	
	int number_cols, number_rows;
	int mindim;
	int chart_counter = size(BlowUpTree);
	int end_chart_counter;
	
	int oldsize;
	for(i = 2; i<= size(BlowUpTree);i++){			
		if(defined(XijChart)){
			kill(XijChart);
		}
		def XijChart = BlowUpTree[i];
		setring(XijChart);

		number_cols = ncols(N);
		number_rows = nrows(N);
		if(mode == "gen"){
			matrix M = generic_gauss(Ntmp, number_rows,number_cols); 					// Reduction in Dimension
			list transformationlist = generic_transformation_of_variables(M);			//Transformation for the new system of parameters
		}
		if(mode =="sym"){
			matrix M = symmetric_gauss(Ntmp, number_rows,number_cols); 					
			list transformationlist = symmetric_transformation_of_variables(M);			
		}
		if(mode =="skew"){
			matrix M = skewsymmetric_gauss(Ntmp, number_rows,number_cols); 					
			list transformationlist = skewsymmetric_transformation_of_variables(M);			
		}
		M = transformationlist[1];
		ideal minorideal = transformationlist[2];
		export(minorideal); 
		mindim = min(ncols(M),nrows(M));
		
		if(minorsize[1] > minsize){		//TODO!!! depends on the mode
			oldsize = size(BlowUpTree);
			ideal cent = minor(M,1);									//auxiliary data 
			export(cent);
			BlowUpTree = BlowUpTree + CopyDataInNextChartsAndBlowUp_generic(M,radical(minor(M,1)),i);
			chart_counter = chart_counter + size(BlowUpTree) - oldsize;
		}else{
			end_chart_counter++;
		}
	}
	return(BlowUpTree,chart_counter,end_chart_counter);
}

proc generic_resolve(int m, list #)
"USAGE:generic_resolve(int m[, int n , int r] ); computes the resolution of the ideal of r-minors of a generic mxn matrix
RETURN: list of rings which represent the charts during the whole resolution process
EXAMPLE: example generic_resolve; shows an example
"
{						
	int n, r;
	list BlowUpTree;
	if (size(#)>0){
		n = #[1];
		if(size(#)>1){
			r = #[2];
			BlowUpTree = main_generic_resolve("gen",m,n,r);
		}else{
			BlowUpTree = main_generic_resolve("gen",m,n);
		}
	}else{
		BlowUpTree = main_generic_resolve("gen",m,m);
	}
	
	return(BlowUpTree);
}
example{ 	
	generic_resolve(4,3,2);
}


proc skewsymmetric_resolve(int m, list #)
"USAGE:skewsymmetric_resolve(int m [, int r] ); computes the resolution of the ideal of r-minors of a generic skewsymmetric mxm matrix
RETURN: list of rings which represent the charts during the whole resolution process
EXAMPLE: example skewsymmetric_resolve; shows an example
"
{
	int r;
	list BlowUpTree;
	if (size(#)>0){
		r = #[1];
		BlowUpTree = main_generic_resolve("skew",m,r);
	}else{
		BlowUpTree = main_generic_resolve("skew",m);
	}
	
	return(BlowUpTree);
}example{
	skewsymmetric_resolve(4);
}


proc symmetric_resolve(int m, list #)
"USAGE:symmetric_resolve(int m [, int r] ); computes the resolution of the ideal of r-minors of a generic skewsymmetric mxm matrix
RETURN: list of rings which represent the charts during the whole resolution process
EXAMPLE: example skewsymmetric_resolve; shows an example
"
{
	int r;
	list BlowUpTree;
	if (size(#)>0){
		r = #[1];
		BlowUpTree = main_generic_resolve("sym",m,r);
	}else{
		BlowUpTree = main_generic_resolve("sym",m);
	}
	
	return(BlowUpTree);
}example{
	symmetric_resolve(4);
}


proc CopyDataInNextChartsAndBlowUp_generic(matrix M, ideal Center, int chartnumber)
"USAGE: CopyDataInNextChartAndBlowUp(matrix M, ideal Center, int chartnumber ); computes the blow up and copies the data (strict transform, ideal and pathmatrix) in the successorcharts
RETURN: list of rings which represent the charts during the whole resolution process
EXAMPLE: example CopyDataInNextChartAndBlowUp; shows an example
"
{
	int j, number_cols,number_rows;
	int Edefined = 1;
	def r = basering;
	if(size(E) == 0){Edefined = 0;}
	list successorList = blowUp3(W,Center);
	int number_center_components = size(successorList);

	for(j = 1;j<=number_center_components; j++){
		if(defined(newring)){kill newring;}
		
		def newring = successorList[j];
		setring(newring);
		map BlowUpMap = r,bM;		
		ideal W = BlowUpMap(W);
		export(W);
		if(!Edefined){ list E = list();}
		else{list E = BlowUpMap(E);}
		E[size(E)+1] = eD[1];
		export(E);

		ideal abb = BlowUpMap(abb);					//abbildung aus resolve.lib //TODO: mit bM verknuepfen!!!!
		export(abb); 	
		matrix N = BlowUpMap(M);				// total transform
		export(N);
		//matrix Ntmp = sat(N+sT,eD[1])[1];		// Achtung !!! Reihenfolge der Einträge und Dimension der neuen Matrix!!!
		matrix Ntmp = weakTransformOfMatrix(N);
		export(Ntmp);
		number_cols = ncols(N);
		number_rows = nrows(N);

		def path = imap(r,path);				//init pathmatrix 
		path=path,[chartnumber,j];
		export(path);
		
		list minorsize = BlowUpMap(minorsize);
		export(minorsize);
	}
	return(successorList);
}example{
	ring r = 0,(x(1..12)),dp;
	matrix M = genericmat(3,4);
	CopyDataInNextChartsAndBlowUp(M,std(minor(M,1)),1);	
}


proc weakTransformOfMatrix(matrix N)	
"USAGE: weakTransformOfMatrix(matrix N); given a blown up matrix N it calculates the weak transform of a matrix with respect to rows and columns
RETURN: transformed matrix 
EXAMPLE: example weakTransformOfMatrix; shows an example
"
{
	int i,j,k;
	int number_rows = nrows(N);
	int number_cols = ncols(N);
	
	
	//find maximal value  c such that we can factor out eD[1]^c in each row:
	poly tmp_entry;
	poly tmp_eDPowC;
	int eDDividesRow;
	
	for(i=1; i<= number_rows;i++){
		tmp_eDPowC = eD[1];
		eDDividesRow = 1;
		while(eDDividesRow){
			for(j=1; j<=number_cols; j++){
				if(N[i,j] != 0){									// without this, a skewsymmetric matrix is returned as total transform because of the zero entries
					tmp_entry = N[i,j] div tmp_eDPowC;						
					if(tmp_entry == 0){
						eDDividesRow = 0;
						break;
					}
				}
			}
			if(eDDividesRow){
				tmp_eDPowC = tmp_eDPowC * eD[1];
			}else{
				tmp_eDPowC = tmp_eDPowC div eD[1];
			}
		}
		for(j = 1; j<= number_cols; j++){
			N[i,j] = N[i,j] div tmp_eDPowC;
		}
	}
	
	//same procedure for each column:
	for(j=1; j<= number_cols;j++){
		tmp_eDPowC = eD[1];
		eDDividesRow = 1;
		while(eDDividesRow){
			for(i=1; i<=number_rows; i++){
				tmp_entry = N[i,j] div tmp_eDPowC;						
				if(tmp_entry == 0){
					eDDividesRow = 0;
					break;
				}
			}
			if(eDDividesRow){
				tmp_eDPowC = tmp_eDPowC * eD[1];
			}else{
				tmp_eDPowC = tmp_eDPowC div eD[1];
			}
		}
		for(i = 1; i<= number_rows; i++){
			N[i,j] = N[i,j] div tmp_eDPowC;
		}
	}
	
	return(N);
}example{
	ring r = 0,(x(1..9)),dp;
	matrix N[3][3] = x(1),x(1)*x(2),x(1)*x(3),x(1)*x(4),x(1)*x(5),x(1)*x(6),x(1)*x(7),x(1)*x(8),x(1)*x(9); 
	print(N);
	list eD;
	eD[1] = x(1);
	export(eD);
	weakTransformOfMatrix(N);
	
	matrix N[3][3] = x(1)^2,x(1)^2*x(2),x(1)^3*x(3),x(1)*x(4),x(1)*x(5),x(1)*x(6),x(1)^5*x(7),x(1)^4*x(8),x(1)*x(9); 
	print(N);
	weakTransformOfMatrix(N);
}


proc generic_gauss(matrix N, int number_rows, int number_cols)			//TODO: compute the map of abb
"USAGE: generic_gauss(matrix N, int number_rows, int number_cols ); computes the gaussian steps in the resolution process.
RETURN: transformed matrix M
EXAMPLE: example generic_gauss; shows an example
"
{		
	int i,j,k;
	
	intvec newcols, newrows, cols, rows;
	
	cols = 1..number_cols;
	rows = 1..number_rows;
	matrix N2 = submat(N,rows,cols);		//Gaussian steps
	matrix colN = colred(N2);
	matrix redN = rowred(colN);
	
	for(j =1; j<= number_rows;j++){
		for(k = 1; k<= number_cols;k++){
			if(redN[j,k] == 1) {break;}
		}
		if(redN[j,k] == 1) {break;}  
	}										// 1 at position [j,k] -> choose submatrix without this entry
		
	if(j==1){
		newrows = 2..number_rows;
	} else{ 
		if (j == number_rows){
			newrows = 1..number_rows-1; 
		} else{
			newrows = 1..j-1,j+1,,number_rows;
		}
	}
	if(k==1){
		newcols = 2..number_cols;
	} else{ 
		if (k == number_cols){
			newcols = 1..number_cols-1; 
		} else{
			newcols = 1..k-1,k+1,,number_cols;
		}
	}
	matrix M = submat(redN,newrows,newcols);
	
	minorsize[1] = minorsize[1] - 1;	//internal note that the desired minorsize has decrease
	
	return(M);
}example{
	//Todo
}

proc skewsymmetric_gauss(matrix N, int number_rows, int number_cols)	//TODO: compute the map of abb
"USAGE: skewsymmetric_gauss(matrix N, int number_rows, int number_cols ); computes the gaussian steps in the resolution process.
RETURN: transformed matrix M
EXAMPLE: example skewsymmetric_gauss; shows an example
"
{		
	int i,j,k,l;
	intvec newcols, newrows;
	intvec coordinatesOfOne = 0,0;
	
	intvec cols = 1..number_cols;
	intvec rows = 1..number_rows;

	matrix redN = submat(N,rows,cols);
	//destroys the skewsymmetric structure :
	//matrix redN = rowred(colN);
	
	for(j = 1; j<= number_rows;j++){
		for(k = 1; k<= number_cols;k++){
			if(redN[j,k] == 1) {coordinatesOfOne = j,k;}				// 1 at position [j,k] -> choose submatrix without this entry
		} 
	}										
	if(coordinatesOfOne[1] == 0){~;}
	
	matrix Ntemp = redN;
	//[j,k] is the entry which equals 1 -> [k,j] equals -1
	for(i = 1; i <= number_rows; i++){									//row operations for the first 0-column
		for(l = 1; l<=number_cols; l++){
			if(i != coordinatesOfOne[1] and i != coordinatesOfOne[2]){
				redN[i,l] = Ntemp[i,l] - Ntemp[i,coordinatesOfOne[2]] * Ntemp[coordinatesOfOne[1],l];
			}
		}
	}
	Ntemp = redN;

	// let the column entries vanish:
	for(l=1;l<=number_cols;l++){
		if(coordinatesOfOne[2] != l){
			redN[coordinatesOfOne[1],l] = 0;
		}
	}
	Ntemp = redN;
	
	for(i = 1; i <= number_rows; i++){							//column operations for the second 0-row
		for(l = 1; l<=number_cols; l++){
			if(l!= coordinatesOfOne[2] and l!= coordinatesOfOne[1]){
				redN[i,l] = Ntemp[i,l] + Ntemp[i,coordinatesOfOne[1]] * Ntemp[coordinatesOfOne[2],l];
			}
		}
	}
	Ntemp = redN;
	
	// let the column entries vanish:
	for(i=1;i<=number_cols;i++){
		if(coordinatesOfOne[2] != i){
			redN[i,coordinatesOfOne[1]] = 0;
		}
	}
	Ntemp = redN;
	
	int changed = 0;
	for(i=1;i<=number_cols;i++){
		if(i != coordinatesOfOne[1] and i != coordinatesOfOne[2]){
			if(changed == 0){						// because we do not need a leading zero-entry in the intvec newcols
				newcols[1] = i;	
				changed = 1;
			}else{
				newcols = newcols,i;
			}	
		}
	}
	
	minorsize[1] = minorsize[1] - 2;	//internal note that the desired minorsize has decrease
	matrix M = submat(redN,newcols,newcols);
	return(M);
}example{
		//TODO
}

proc symmetric_gauss(matrix N, int number_rows, int number_cols)	//TODO: compute the map of abb
"USAGE: symmetric_gauss(matrix N, int number_rows, int number_cols ); computes the gaussian steps in the resolution process.
RETURN: transformed matrix M
EXAMPLE: example symmetric_gauss; shows an example
"
{		
	int i,j,k,l;
	poly epsilon;
	intvec newcols, newrows, cols, rows;
	intvec coordinatesOfOne;
	
	cols = 1..number_cols;
	rows = 1..number_rows;
	matrix redN = submat(N,rows,cols);
	
	for(j = 1; j<= number_rows;j++){
		for(k = 1; k<= number_cols;k++){
			if(redN[j,k] == 1) {coordinatesOfOne = j,k;}
		} 
	}										// 1 at position [j,k] -> choose submatrix without this entry
	
	epsilon = 1-redN[coordinatesOfOne[1],coordinatesOfOne[1]] * redN[coordinatesOfOne[2],coordinatesOfOne[2]];
	
	matrix Ntemp = redN;

	// distinguish diagonal and non-diagonal entries
	if(coordinatesOfOne[1] == coordinatesOfOne[2]){			
		for(i = 1; i <= number_rows; i++){							//row operations for the first 0-column
			for(l = 1; l <= number_cols; l++){
				if(i != coordinatesOfOne[1]){
					redN[i,l] = Ntemp[i,l] - Ntemp[i,coordinatesOfOne[1]] * Ntemp[coordinatesOfOne[1],l];
				}
			}
		}
		Ntemp = redN;

		// let the column entries vanish:
		for(i=1;i<=number_cols;i++){
			if(coordinatesOfOne[1] != i){
				redN[coordinatesOfOne[1],i] = 0;
			}
		}
		Ntemp = redN;
		minorsize[1] = minorsize[1] - 1;								//internal note that the desired minorsize has decrease
	}else{			//non-diagonal 1-entries [j,k] and [k,j]
		for(i = 1; i <= number_rows; i++){								//row operations for the first 0-column
			for(l = 1; l<=number_cols; l++){
				if(i != coordinatesOfOne[2]){
					redN[i,l] = Ntemp[i,l] - Ntemp[i,coordinatesOfOne[1]] * Ntemp[coordinatesOfOne[2],l];
				}
			}
		}
		Ntemp = redN;
		// let the column entries vanish:
		for(i=1;i<=number_cols;i++){
			if(coordinatesOfOne[1] != i){
				redN[coordinatesOfOne[2],i] = 0;
			}
		}
		Ntemp = redN;
		
		//Divide and multiply with epsilon:
		redN[coordinatesOfOne[1],coordinatesOfOne[2]] = 1;
		Ntemp = redN;
		
		for(i = 1;i<= number_rows; i++){
			if(i!=coordinatesOfOne[1] and i != coordinatesOfOne[2]){
				for(l=1; l<= number_cols; l++){
					if(l!=coordinatesOfOne[1] and l != coordinatesOfOne[2]){
						redN[i,l] = redN[i,l] * epsilon;
					}
				}
			}
		}
		
		Ntemp = redN;
		for(i = 1; i <= number_rows; i++){								//row operations for the second 0-column
			for(l = 1; l<=number_cols; l++){
				if(i != coordinatesOfOne[1]){
					redN[i,l] = Ntemp[i,l] - Ntemp[i,coordinatesOfOne[2]] * Ntemp[coordinatesOfOne[1],l];
				}
			}
		}

		Ntemp = redN;		
		// let the column entries vanish:
		for(i=1;i<=number_cols;i++){
			if(coordinatesOfOne[2] != i){
				redN[coordinatesOfOne[1],i] = 0;
			}
		}
		Ntemp = redN;
		minorsize[1] = minorsize[1] - 2;								//internal note that the desired minorsize has decrease
	}
	
	int changed = 0;
	for(i=1;i<=number_cols;i++){
		if(i != coordinatesOfOne[1] and i != coordinatesOfOne[2]){
			if(changed == 0){											// because we do not need a leading zero-entry in the intvec newcols
				newcols[1] = i;	
				changed = 1;
			}else{
				newcols = newcols,i;
			}	
		}
	}
	
	matrix M = submat(redN,newcols,newcols);
	return(M);
}example{
		//TODO
}


proc generic_transformation_of_variables(matrix M)
"USAGE: generic_transformaion(matrix M); computes the transformation of variables
RETURN: list of matrix M and the ideal of the minors of the desired size
EXAMPLE: example generic_transformation_of_variables; shows an example
"
{
	int i,j;
	
	int number_cols = ncols(M);
	int number_rows = nrows(M);
	int new_nvars = 1; 											
	matrix newM = M;
	
	for(i = 1; i<= number_rows; i++){							
		for(j = 1; j<= number_cols; j++){
			newM[i,j] = var(new_nvars);
			new_nvars++;
		}
	}
	ideal minorideal = minor(newM,minorsize[1]);					//Calculate minor ideal of the right size
					
	return(newM, minorideal);
}example{
		//TODO
}



proc skewsymmetric_transformation_of_variables(matrix M)
"USAGE: skewsymmetric_transformation_of_variables(matrix M); computes the transformation of variables
RETURN: list of matrix M and the ideal of the minors of the desired size
EXAMPLE: example skewsymmetric_transformation_of_variables; shows an example
"
{
	int i,j;
	
	int number_cols = ncols(M);
	int number_rows = nrows(M);
	int new_nvars = 1; 											
	matrix newM = M;

	for(i = 1; i<= number_rows; i++){							
		for(j = i+1; j<= number_cols; j++){
			if(M[i,j] != 0){
				newM[i,j] = var(new_nvars);
				newM[j,i] = -var(new_nvars);
				new_nvars++;
			}
		}
	}
	ideal minorideal = minor(newM,minorsize[1]);						//Calculate minor ideal of the right size
	return(newM, minorideal);	
}example{
	//TODO	
}

proc symmetric_transformation_of_variables(matrix M)
"USAGE: symmetric_transformation_of_variables(matrix M); computes the transformation of variables
RETURN: list of matrix M and the ideal of the minors of the desired size
EXAMPLE: example symmetric_transformation_of_variables; shows an example
"
{
	int i,j;
	
	int number_cols = ncols(M);
	int number_rows = nrows(M);
	int new_nvars = 1; 											
	matrix newM = M;

	for(i = 1; i<= number_rows; i++){							
		for(j = i; j<= number_cols; j++){
			if(M[i,j] != 0){
				newM[i,j] = var(new_nvars);
				newM[j,i] = var(new_nvars);
				new_nvars++;
			}
		}
	}
	ideal minorideal = minor(newM,minorsize[1]);						//Calculate minor ideal of the right size
	return(newM, minorideal);	
}example{
	//TODO	
}

//----------------------------------------------------------------------

proc test_generic_vs_resolve(int m,int n){

	link l2 = ":w Testfaelle/resolve.txt";
	link l1 = ":w Testfaelle/generic_resolve.txt";
	
	list linklist = list(l1,l2);
	int i; int j;
	ring r = 0,(x(1..m*n)),dp;
	matrix M = genericmat(m,n);
	int minorsize = min(m,n);
	ideal I = minor(M,minorsize);		//maximal minors
	list blowuplist;
	
	list sum_runtime = list(0,0,0,0);
	list sum_endcharts = list(0,0,0,0);
	list sum_charts = list(0,0,0,0);
	int runningtime = 0;
	int whole_runningtime = 0;
	int tmp_runningtime = 0;
	
	//Test binomial-calculations:
	for(minorsize=3;minorsize<=min(m,n); minorsize++){
		//f = create_test_binomial(maxdegree, mode);
		I = minor(M,minorsize);
		tmp_runningtime = rtimer;
		blowuplist = generic_resolve(m,n,minorsize);
		runningtime = rtimer - tmp_runningtime;	
		//fprintf(linklist[i],"binomial: %l	endcharts: %s	charts: %s	runtime: %s",f,blowuplist[2],size(blowuplist[1]),blowuplist[4]);	
		fprintf(linklist[1]," Matrix: %s	minorsize: %s	endcharts: %s	charts: %s	running time: %s",M,minorsize,blowuplist[3],blowuplist[2], runningtime);	
		// only for later stats calculations:
		
		//sum_runtime[i] = sum_runtime[i] + blowuplist[4];
		//sum_endcharts[i] = sum_endcharts[i] + blowuplist[2];
		//sum_charts[i] = sum_charts[i] + size(blowuplist[1]);
		tmp_runningtime = rtimer;
		blowuplist = resolve(I);
		runningtime = rtimer - tmp_runningtime;	
		fprintf(linklist[2]," Matrix: %s	minorsize: %s	endcharts: %s	charts: %s	running time: %s", M,minorsize,size(blowuplist[1]),size(blowuplist[2]), runningtime);
		
	}
	
	
	//compute average values:
	//list average_runtime 	= list(sum_runtime[1] div binomialcount, sum_runtime[2] div binomialcount, sum_runtime[3] div binomialcount, sum_runtime[4] div binomialcount); 
	//list average_endcharts 	= list(sum_endcharts[1] div binomialcount, sum_endcharts[2] div binomialcount, sum_endcharts[3] div binomialcount, sum_endcharts[4] div binomialcount);
	//list average_charts 	= list(sum_charts[1] div binomialcount, sum_charts[2] div binomialcount, sum_endcharts[3] div binomialcount, sum_endcharts[4] div binomialcount);
	
	//compute the stats:
	//for(i = 1;i<=size(linklist);i++){
	//	fprintf(linklist[i],"average-endcharts: %s	average-charts: %s	average-runtime: %s",average_endcharts[i],average_charts[i],average_runtime[i]);	
	//}
	
	//close files:
	close(l1);
	close(l2);
	//close(l3);
	//close(l4);
}


proc test_skew_vs_resolve(int m){

	link l2 = ":w Testfaelle/resolve_skew.txt";
	link l1 = ":w Testfaelle/skew_generic.txt";
	
	list linklist = list(l1,l2);
	int i; int j;
	ring r = 0,(x(1..m*(m-1)div 2)),dp;
	matrix M = skewmat(m);
	int minorsize = m;
	ideal I = minor(M,minorsize);		//maximal minors
	list blowuplist;
	
	int runningtime = 0;
	int whole_runningtime = 0;
	int tmp_runningtime = 0;
	
	//Test binomial-calculations:
	for(minorsize=4;minorsize<=m; minorsize=minorsize+2){
		//f = create_test_binomial(maxdegree, mode);
		I = radical(std(minor(M,minorsize)));
		tmp_runningtime = rtimer;
		blowuplist = skewsymmetric_resolve(m,minorsize);
		runningtime = rtimer - tmp_runningtime;	
		//fprintf(linklist[i],"binomial: %l	endcharts: %s	charts: %s	runtime: %s",f,blowuplist[2],size(blowuplist[1]),blowuplist[4]);	
		fprintf(linklist[1]," Matrix: %s	minorsize: %s	endcharts: %s	charts: %s	running time: %s",M,minorsize,blowuplist[3],blowuplist[2], runningtime);	
		// only for later stats calculations:
		
		//sum_runtime[i] = sum_runtime[i] + blowuplist[4];
		//sum_endcharts[i] = sum_endcharts[i] + blowuplist[2];
		//sum_charts[i] = sum_charts[i] + size(blowuplist[1]);
		tmp_runningtime = rtimer;
		blowuplist = resolve(I);
		runningtime = rtimer - tmp_runningtime;	
		fprintf(linklist[2]," Matrix: %s	minorsize: %s	endcharts: %s	charts: %s	running time: %s", M,minorsize,size(blowuplist[1]),size(blowuplist[2]), runningtime);
		
	}
	
	
	//compute average values:
	//list average_runtime 	= list(sum_runtime[1] div binomialcount, sum_runtime[2] div binomialcount, sum_runtime[3] div binomialcount, sum_runtime[4] div binomialcount); 
	//list average_endcharts 	= list(sum_endcharts[1] div binomialcount, sum_endcharts[2] div binomialcount, sum_endcharts[3] div binomialcount, sum_endcharts[4] div binomialcount);
	//list average_charts 	= list(sum_charts[1] div binomialcount, sum_charts[2] div binomialcount, sum_endcharts[3] div binomialcount, sum_endcharts[4] div binomialcount);
	
	//compute the stats:
	//for(i = 1;i<=size(linklist);i++){
	//	fprintf(linklist[i],"average-endcharts: %s	average-charts: %s	average-runtime: %s",average_endcharts[i],average_charts[i],average_runtime[i]);	
	//}
	
	//close files:
	close(l1);
	close(l2);
	//close(l3);
	//close(l4);
}

proc test_skew(int m){
	link l1 = ":w Testfaelle/skew_generic_number_charts.txt";
	
	list linklist = list(l1);
	int i; int j;
	ring r = 0,(x(1..m*(m-1)div 2)),dp;
	matrix M = skewmat(m);
	int minorsize = m;
	ideal I = minor(M,minorsize);		//maximal minors
	list blowuplist;
	
	int runningtime = 0;
	int whole_runningtime = 0;
	int tmp_runningtime = 0;
	
	//Test binomial-calculations:
	for(minorsize=4;minorsize<=m; minorsize=minorsize+2){
		tmp_runningtime = rtimer;
		blowuplist = skewsymmetric_resolve(minorsize,minorsize);
		runningtime = rtimer - tmp_runningtime;	
	
		fprintf(linklist[1],"	minorsize: %s	endcharts: %s	charts: %s	running time: %s",minorsize,blowuplist[3],blowuplist[2], runningtime);	

	}

	close(l1);
}



proc binomial_test_generic_vs_resbinomial(int m){		//only 2-minors of generic jxj matrices for 2<=j<=m

	link l3 = ":w Testfaelle/resbinomial2.txt";
	
	link l2 = ":w Testfaelle/binomial_resolve.txt";
	link l1 = ":w Testfaelle/binomial_generic_resolve.txt";
	
	list linklist = list(l1,l2,l3);
	int i; int j;
	ring r = 0,(x(1..m*2)),dp;
	matrix M = genericmat(m,2);
	int minorsize = 2;
	ideal I = minor(M,minorsize);		//maximal minors
	list blowuplist;
	
	list sum_runtime = list(0,0,0,0);
	list sum_endcharts = list(0,0,0,0);
	list sum_charts = list(0,0,0,0);
	int runningtime = 0;
	int whole_runningtime = 0;
	int tmp_runningtime = 0;
	
	//Test binomial-calculations:
	for(j=4;j<=m;j++){
		//f = create_test_binomial(maxdegree, mode);
		M = genericmat(j,2);
		I = minor(M,minorsize);
		tmp_runningtime = rtimer;
		blowuplist = generic_resolve(j,j,minorsize);
		runningtime = rtimer - tmp_runningtime;	
		//fprintf(linklist[i],"binomial: %l	endcharts: %s	charts: %s	runtime: %s",f,blowuplist[2],size(blowuplist[1]),blowuplist[4]);	
		fprintf(linklist[1]," Matrix: %s	minorsize: %s	endcharts: %s	charts: %s	running time: %s",M,minorsize,blowuplist[3],blowuplist[2], runningtime);	
		
		tmp_runningtime = rtimer;
		blowuplist = resbinomial2(I);
		runningtime = rtimer - tmp_runningtime;	
		fprintf(linklist[3]," Matrix: %s	minorsize: %s	endcharts: %s	charts: %s	running time: %s", M,minorsize,size(blowuplist[1]),size(blowuplist[2]), runningtime);

	}
	
	//close files:
	close(l1);
	close(l2);
	close(l3);

}


