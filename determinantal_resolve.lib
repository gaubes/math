version=" "; // $Id$
category=" ";
info="
LIBRARY:  determiantal_resolve.lib 
AUTHOR:  Sabrina Alexandra Gaube, sabrina.gaube@uol.de

PROCEDURES:
	blowUp3(J, C, #); same like blowUp2 but with the subcall blowUpBO(BO,C,2) instead of blowUpBO(BO,C,1);
	main_generic_resolve(mode, m, #); main method for resolution of all generic matrices, with string parameter mode
	generic_resolve(m, n, #); call method for resolution of generic mxn matrices
	skewsymmetric_resolve(m); call method for resolution of generic skewsymmetric mxm matrices
	symmetric_resolve(m); call method for resolution of generic ymmetric mxm matrices
	
	CopyDataInNextChartsAndBlowUp(M, Center, chartnumber); blow up method which copies data in the successor charts
	weakTransformOfMatrix(N); given a blown up matrix N it calculates the weak transform of a matrix with respect to rows and columns 
	
	generic_gauss(N, number_rows, number_cols); calculates the gaussian steps for the generic case
	skewsymmetric_gauss(N, number_rows, number_cols); gaussian steps for the skewsymmetric case 
	symmetric_gauss(N, number_rows, number_cols); gaussian steps for the symmetric case
	
	generic_transformation_of_variables(M); transformation of variables for the generic case
	skewsymmetric_transformation_of_variables(M); transformation of variables for the skewsymmetric case
	symmetric_transformation_of_variables(M); transformation of variables for the symmetric case
	
";

LIB "matrix.lib";
LIB "resolve.lib";


proc blowUp3(ideal J,ideal C,list #)
"USAGE:  blowUp3(J,C[,W][,E]);
         W,J,C = ideals,
         E     = list
ASSUME:  J  = ideal containing W ( W = 0 if not specified)
@*       C  = ideal containing J
@*       E  = list of smooth hypersurfaces (e.g. exceptional divisors)
NOTE:    W the ideal of the ambient space, C the ideal of the center of
         the blowup and J the ideal of the variety
         Important difference to blowUp2:
         - the ambient space V(W) is blown up and V(J) transformed in it
@*         - V(C) is assumed to be non-singular
COMPUTE: the blowing up of W in C, the exceptional locus, the strict
         transform of J and the blowup map
RETURN:  list, say l, of size at most size(C),

         l[i] is the affine ring corresponding to the i-th chart
         each l[i] contains the ideals
         - aS, ideal of the blownup ambient space
         - sT, ideal of the strict transform
         - eD, ideal of the exceptional divisor
         - bM, ideal corresponding to the blowup map

         l[i] also contains a list BO, which can best be viewed with showBO(BO)
         detailed information on the data type BO can be viewed via the
         command showDataTypes();
EXAMPLE: example blowUp;  shows an example
"
{
  def S=basering;
  ideal W;
  list E;
  ideal abb=maxideal(1);
  intvec v;
  intvec bvec;
  intvec w=-1;
  matrix intE;
  if(size(#)>0)
  {
    if(typeof(#[1])=="ideal")
    {
      W=#[1];
    }
    if(typeof(#[1])=="list")
    {
      E=#[1];
    }
    if(size(#)>1)
    {
      if((typeof(#[2])=="list") && (size(E)==0))
      {
        E=#[2];
      }
      if((typeof(#[2])=="ideal") && (size(W)==0))
      {
        W=#[2];
      }
    }
  }
  list BO=W,J,bvec,E,abb,v,w,intE;
  int locaT;
  export locaT;
  list blow=blowUpBO(BO,C,2);
  kill locaT;
  int i;
  for(i=1;i<=size(blow);i++)
  {
     def Q=blow[i];
     setring Q;
     ideal aS=BO[1];
     ideal sT=BO[2];
     ideal eD=BO[4][size(BO[4])];
     ideal bM=BO[5];
     kill lastMap;
     kill thisChart;
     export(aS);
     export(sT);
     export(eD);
     export(bM);
     blow[i]=Q;
     setring S;
     kill Q;
  }
  return(blow);
}
example
{"EXAMPLE:";
   echo = 2;
   ring R=0,(x,y),dp;
   ideal J=x2-y3;
   ideal C=x,y;
   list blow=blowUp3(J,C);
   def Q=blow[1];
   setring Q;
   aS;
   sT;
   eD;
   bM;
}

proc main_generic_resolve(string mode, int m, list #)
"USAGE:main_generic_resolve(string mode, int m[, int n , int r] ); computes the resolution of the ideal of r-minors of a (skew)-symmetric generic mxm matrix with mode = skew or mode = sym or generic mxn matrix with mode = gen
RETURN: list of rings which represent the charts during the whole resolution process
EXAMPLE: example generic_resolve; shows an example
"
{
	if(mode == "gen"){
		if(size(#)>0){
			int n = #[1];
		}else{
			int n = m;
		}
		ring r = 0,(x(1..m*n)),dp;
		matrix M = genericmat(m,n);
	}
	if(mode == "sym"){
		ring r = 0,(x(1..m*(m+1) div 2)),dp;
		matrix M = symmat(m);
	}
	if(mode == "skew"){
		ring r = 0,(x(1..m*(m-1)div 2)),dp;
		matrix M = skewmat(m);
	}
	if(!defined(r)){
		ERROR("choose a mode gen,sym or skew followed by the size of your generic matrix");
	}
	
	list minorsize = list(min(ncols(M),nrows(M)),var(1) );				// default: resolve maximal minors; variable and list is only technically in order that we can store the list in the ring!!!
	ideal minorideal = minor(M,1);
	if(size(#)>1 and mode == "gen"){
		if(typeof(#[2])=="int"){
			minorsize[1] = #[2];										//calculate how long we have to blow up until the #[1]-minors are resolved
			minorideal = minor(M,minorsize[1]);
		}
	}
	if(size(#)>0 and mode != "gen"){
		if(typeof(#[1])=="int"){
			minorsize[1] = #[1];										//calculate how long we have to blow up until the #[1]-minors are resolved
			minorideal = minor(M,minorsize[1]);
		}
	}
	
	export(minorsize);

	export(minorideal);
	
	module path = [0,-1];												//path of the current chart, autoconverted to matrix
	export(path);
	
	list BlowUpTree;
	BlowUpTree[1] = basering;
	BlowUpTree = BlowUpTree +  CopyDataInNextChartsAndBlowUp(M,minor(M,1),1);
	int i; int j; int k;
	
	int number_cols, number_rows;
	int mindim;
	int chart_counter = size(BlowUpTree);
	
	int oldsize;
	for(i = 2; i<= size(BlowUpTree);i++){			
		if(defined(XijChart)){
			kill(XijChart);
		}
		def XijChart = BlowUpTree[i];
		setring(XijChart);

		number_cols = ncols(N);
		number_rows = nrows(N);
		if(mode == "gen"){
			matrix M = generic_gauss(Ntmp, number_rows,number_cols); 					// Reduction in Dimension
			list transformationlist = generic_transformation_of_variables(M);			//Transformation for the new system of parameters
		}
		if(mode =="sym"){
			matrix M = symmetric_gauss(Ntmp, number_rows,number_cols); 					
			list transformationlist = symmetric_transformation_of_variables(M);			
		}
		if(mode =="skew"){
			matrix M = skewsymmetric_gauss(Ntmp, number_rows,number_cols); 					
			list transformationlist = skewsymmetric_transformation_of_variables(M);			
		}
		M = transformationlist[1];
		ideal minorideal = transformationlist[2];
		export(minorideal); 
		mindim = min(ncols(M),nrows(M));
		if(minorsize[1] > 2){		//TODO!!! change value 2 ?
			oldsize = size(BlowUpTree);
			BlowUpTree = BlowUpTree + CopyDataInNextChartsAndBlowUp(M,minor(M,1),i);
			chart_counter = chart_counter + size(BlowUpTree) - oldsize;
		}
	}
	return(BlowUpTree,chart_counter);
	
	
	
	return(1);
}
proc generic_resolve(int m, list #)
"USAGE:generic_resolve(int m[, int n , int r] ); computes the resolution of the ideal of r-minors of a generic mxn matrix
RETURN: list of rings which represent the charts during the whole resolution process
EXAMPLE: example generic_resolve; shows an example
"
{							//generic matrix with m rows and n columns
	int n, r;
	list BlowUpTree;
	if (size(#)>0){
		n = #[1];
		if(size(#)>1){
			r = #[2];
			BlowUpTree = main_generic_resolve("gen",m,n,r);
		}else{
			BlowUpTree = main_generic_resolve("gen",m,n);
		}
	}else{
		BlowUpTree = main_generic_resolve("gen",m,m);
	}
	
	return(BlowUpTree);
}
example{ 	
	generic_resolve(4,3,2);
}


proc skewsymmetric_resolve(int m, list #)
"USAGE:skewsymmetric_resolve(int m [, int r] ); computes the resolution of the ideal of r-minors of a generic skewsymmetric mxm matrix
RETURN: list of rings which represent the charts during the whole resolution process
EXAMPLE: example skewsymmetric_resolve; shows an example
"
{
	int r;
	list BlowUpTree;
	if (size(#)>0){
		r = #[1];
		BlowUpTree = main_generic_resolve("skew",m,r);
	}else{
		BlowUpTree = main_generic_resolve("skew",m);
	}
	
	return(BlowUpTree);
}example{
	skewsymmetric_resolve(4);
}


proc symmetric_resolve(int m, list #)
"USAGE:symmetric_resolve(int m [, int r] ); computes the resolution of the ideal of r-minors of a generic skewsymmetric mxm matrix
RETURN: list of rings which represent the charts during the whole resolution process
EXAMPLE: example skewsymmetric_resolve; shows an example
"
{
	int r;
	list BlowUpTree;
	if (size(#)>0){
		r = #[1];
		BlowUpTree = main_generic_resolve("sym",m,r);
	}else{
		BlowUpTree = main_generic_resolve("sym",m);
	}
	
	return(BlowUpTree);
}example{
	symmetric_resolve(4);
}


proc CopyDataInNextChartsAndBlowUp(matrix M, ideal Center, int chartnumber)
"USAGE: CopyDataInNextChartAndBlowUp(matrix M, ideal Center, int chartnumber ); computes the blow up and copies the data (strict transform, ideal and pathmatrix) in the successorcharts
RETURN: list of rings which represent the charts during the whole resolution process
EXAMPLE: example CopyDataInNextChartAndBlowUp; shows an example
"
{
	int j, number_cols,number_rows;
	def r = basering;
	
	list successorList = blowUp3(ideal(0),Center);
	int number_center_components = size(successorList);

	for(j = 1;j<=number_center_components; j++){
		if(defined(newring)){kill newring;}
		
		def newring = successorList[j];
		setring(newring);
		map BlowUpMap = r,bM;					
		matrix N = BlowUpMap(M);				// total transform
		export(N);
		//matrix Ntmp = sat(N+sT,eD[1])[1];		// Achtung !!! Reihenfolge der EintrÃ¤ge und Dimension der neuen Matrix!!!
		matrix Ntmp = weakTransformOfMatrix(N);
		export(Ntmp);
		number_cols = ncols(N);
		number_rows = nrows(N);

		def path = imap(r,path);				//init pathmatrix 
		path=path,[chartnumber,j];
		export(path);
		
		list minorsize = BlowUpMap(minorsize);
		export(minorsize);
	}
	return(successorList);
}example{
	ring r = 0,(x(1..12)),dp;
	matrix M = genericmat(3,4);
	CopyDataInNextChartsAndBlowUp(M,std(minor(M,1)),1);	
}

//TODO:
proc weakTransformOfMatrix(matrix N)	
"USAGE: weakTransformOfMatrix(matrix N); given a blown up matrix N it calculates the weak transform of a matrix with respect to rows and columns
RETURN: transformed matrix 
EXAMPLE: example weakTransformOfMatrix; shows an example
"
{
	int i,j,k;
	int number_rows = nrows(N);
	int number_cols = ncols(N);
	
	
	//find maximal value  c such that we can factor out eD[1]^c in each row:
	poly tmp_entry;
	poly tmp_eDPowC;
	int eDDividesRow;
	
	for(i=1; i<= number_rows;i++){
		tmp_eDPowC = eD[1];
		eDDividesRow = 1;
		while(eDDividesRow){
			for(j=1; j<=number_cols; j++){
				tmp_entry = N[i,j] div tmp_eDPowC;						
				if(tmp_entry == 0){
					eDDividesRow = 0;
					break;
				}
			}
			if(eDDividesRow){
				tmp_eDPowC = tmp_eDPowC * eD[1];
			}else{
				tmp_eDPowC = tmp_eDPowC div eD[1];
			}
		}
		for(j = 1; j<= number_cols; j++){
			N[i,j] = N[i,j] div tmp_eDPowC;
		}
	}
	
	//same factor out procedure for each column:
	poly tmp_entry;
	poly tmp_eDPowC;
	int eDDividesRow;
	
	for(j=1; j<= number_cols;j++){
		tmp_eDPowC = eD[1];
		eDDividesRow = 1;
		while(eDDividesRow){
			for(i=1; i<=number_rows; i++){
				tmp_entry = N[i,j] div tmp_eDPowC;						
				if(tmp_entry == 0){
					eDDividesRow = 0;
					break;
				}
			}
			if(eDDividesRow){
				tmp_eDPowC = tmp_eDPowC * eD[1];
			}else{
				tmp_eDPowC = tmp_eDPowC div eD[1];
			}
		}
		for(i = 1; i<= number_rows; i++){
			N[i,j] = N[i,j] div tmp_eDPowC;
		}
	}
	
	return(N);
}example{
	ring r = 0,(x(1..9)),dp;
	matrix N[3][3] = x(1),x(1)*x(2),x(1)*x(3),x(1)*x(4),x(1)*x(5),x(1)*x(6),x(1)*x(7),x(1)*x(8),x(1)*x(9); 
	print(N);
	list eD;
	eD[1] = x(1);
	export(eD);
	weakTransformOfMatrix(N);
	
	matrix N[3][3] = x(1)^2,x(1)^2*x(2),x(1)^3*x(3),x(1)*x(4),x(1)*x(5),x(1)*x(6),x(1)^5*x(7),x(1)^4*x(8),x(1)*x(9); 
	print(N);
	weakTransformOfMatrix(N);
}


proc generic_gauss(matrix N, int number_rows, int number_cols)
"USAGE: generic_gauss(matrix N, int number_rows, int number_cols ); computes the gaussian steps in the resolution process.
RETURN: transformed matrix M
EXAMPLE: example generic_gauss; shows an example
"
{		
	int i,j,k;
	
	intvec newcols, newrows, cols, rows;
	
	cols = 1..number_cols;
	rows = 1..number_rows;
	matrix N2 = submat(N,rows,cols);		//Gaussian steps
	matrix colN = colred(N2);
	matrix redN = rowred(colN);
	
	for(j =1; j<= number_rows;j++){
		for(k = 1; k<= number_cols;k++){
			if(redN[j,k] == 1) {break;}
		}
		if(redN[j,k] == 1) {break;}  
	}										// 1 at position [j,k] -> choose submatrix without this entry
		
	if(j==1){
		newrows = 2..number_rows;
	} else{ 
		if (j == number_rows){
			newrows = 1..number_rows-1; 
		} else{
			newrows = 1..j-1,j+1,,number_rows;
		}
	}
	if(k==1){
		newcols = 2..number_cols;
	} else{ 
		if (k == number_cols){
			newcols = 1..number_cols-1; 
		} else{
			newcols = 1..k-1,k+1,,number_cols;
		}
	}
	matrix M = submat(redN,newrows,newcols);
	
	minorsize[1] = minorsize[1] - 1;	//internal note that the desired minorsize has decrease
	
	return(M);
}example{
	//Todo
}

proc skewsymmetric_gauss(matrix N, int number_rows, int number_cols)
"USAGE: skewsymmetric_gauss(matrix N, int number_rows, int number_cols ); computes the gaussian steps in the resolution process.
RETURN: transformed matrix M
EXAMPLE: example skewsymmetric_gauss; shows an example
"
{		
	int i,j,k,l;
	intvec newcols, newrows, cols, rows;
	intvec coordinatesOfOne;
	
	cols = 1..number_cols;
	rows = 1..number_rows;

	matrix redN = submat(N,rows,cols);
	//destroys the skewsymmetric structure :
	//matrix redN = rowred(colN);
	
	for(j = 1; j<= number_rows;j++){
		for(k = 1; k<= number_cols;k++){
			if(redN[j,k] == 1) {coordinatesOfOne = j,k;}				// 1 at position [j,k] -> choose submatrix without this entry
		} 
	}										
	
	matrix Ntemp = redN;
	//[j,k] is the entry which equals 1 -> [k,j] equals -1
	for(i = 1; i <= number_rows; i++){									//row operations for the first 0-column
		for(l = 1; l<=number_cols; l++){
			if(i != coordinatesOfOne[1] and i != coordinatesOfOne[2]){
				redN[i,l] = Ntemp[i,l] - Ntemp[i,coordinatesOfOne[2]] * Ntemp[coordinatesOfOne[1],l];
			}
		}
	}
	Ntemp = redN;


	// let the column entries vanish:
	for(l=1;l<=number_cols;l++){
		if(coordinatesOfOne[2] != l){
			redN[coordinatesOfOne[1],l] = 0;
		}
	}
	
	Ntemp = redN;

	
	for(i = 1; i <= number_rows; i++){							//column operations for the second 0-row
		for(l = 1; l<=number_cols; l++){
			if(l!= coordinatesOfOne[2] and l!= coordinatesOfOne[1]){
				redN[i,l] = Ntemp[i,l] + Ntemp[i,coordinatesOfOne[1]] * Ntemp[coordinatesOfOne[2],l];
			}
		}
	}
	Ntemp = redN;

	
	// let the column entries vanish:
	for(i=1;i<=number_cols;i++){
		if(coordinatesOfOne[2] != i){
			redN[i,coordinatesOfOne[1]] = 0;
		}
	}
	Ntemp = redN;
	
	int changed = 0;
	for(i=1;i<=number_cols;i++){
		if(i != coordinatesOfOne[1] and i != coordinatesOfOne[2]){
			if(changed == 0){						// because we do not need a leading zero-entry in the intvec newcols
				newcols[1] = i;	
				changed = 1;
			}else{
				newcols = newcols,i;
			}	
		}
	}
	
	minorsize[1] = minorsize[1] - 2;	//internal note that the desired minorsize has decrease
	matrix M = submat(redN,newcols,newcols);
	return(M);
}example{
		//TODO
}

proc symmetric_gauss(matrix N, int number_rows, int number_cols)
"USAGE: symmetric_gauss(matrix N, int number_rows, int number_cols ); computes the gaussian steps in the resolution process.
RETURN: transformed matrix M
EXAMPLE: example symmetric_gauss; shows an example
"
{		
	int i,j,k,l;
	poly epsilon;
	intvec newcols, newrows, cols, rows;
	intvec coordinatesOfOne;
	
	cols = 1..number_cols;
	rows = 1..number_rows;
	matrix redN = submat(N,rows,cols);
	
	for(j = 1; j<= number_rows;j++){
		for(k = 1; k<= number_cols;k++){
			if(redN[j,k] == 1) {coordinatesOfOne = j,k;}
		} 
	}										// 1 at position [j,k] -> choose submatrix without this entry
	
	epsilon = 1-redN[coordinatesOfOne[1],coordinatesOfOne[1]] * redN[coordinatesOfOne[2],coordinatesOfOne[2]];
	
	matrix Ntemp = redN;

	// distinguish diagonal and non-diagonal entries
	if(coordinatesOfOne[1] == coordinatesOfOne[2]){			
		for(i = 1; i <= number_rows; i++){							//row operations for the first 0-column
			for(l = 1; l <= number_cols; l++){
				if(i != coordinatesOfOne[1]){
					redN[i,l] = Ntemp[i,l] - Ntemp[i,coordinatesOfOne[1]] * Ntemp[coordinatesOfOne[1],l];
				}
			}
		}
		Ntemp = redN;

		// let the column entries vanish:
		for(i=1;i<=number_cols;i++){
			if(coordinatesOfOne[1] != i){
				redN[coordinatesOfOne[1],i] = 0;
			}
		}
		Ntemp = redN;
		minorsize[1] = minorsize[1] - 1;								//internal note that the desired minorsize has decrease
	}else{			//non-diagonal 1-entries [j,k] and [k,j]
		for(i = 1; i <= number_rows; i++){								//row operations for the first 0-column
			for(l = 1; l<=number_cols; l++){
				if(i != coordinatesOfOne[2]){
					redN[i,l] = Ntemp[i,l] - Ntemp[i,coordinatesOfOne[1]] * Ntemp[coordinatesOfOne[2],l];
				}
			}
		}
		Ntemp = redN;
		// let the column entries vanish:
		for(i=1;i<=number_cols;i++){
			if(coordinatesOfOne[1] != i){
				redN[coordinatesOfOne[2],i] = 0;
			}
		}
		Ntemp = redN;
		
		//Divide and multiply with epsilon:
		redN[coordinatesOfOne[1],coordinatesOfOne[2]] = 1;
		Ntemp = redN;
		
		for(i = 1;i<= number_rows; i++){
			if(i!=coordinatesOfOne[1] and i != coordinatesOfOne[2]){
				for(l=1; l<= number_cols; l++){
					if(l!=coordinatesOfOne[1] and l != coordinatesOfOne[2]){
						redN[i,l] = redN[i,l] * epsilon;
					}
				}
			}
		}
		
		Ntemp = redN;
		for(i = 1; i <= number_rows; i++){								//row operations for the second 0-column
			for(l = 1; l<=number_cols; l++){
				if(i != coordinatesOfOne[1]){
					redN[i,l] = Ntemp[i,l] - Ntemp[i,coordinatesOfOne[2]] * Ntemp[coordinatesOfOne[1],l];
				}
			}
		}

		Ntemp = redN;		
		// let the column entries vanish:
		for(i=1;i<=number_cols;i++){
			if(coordinatesOfOne[2] != i){
				redN[coordinatesOfOne[1],i] = 0;
			}
		}
		Ntemp = redN;
		minorsize[1] = minorsize[1] - 2;								//internal note that the desired minorsize has decrease
	}
	
	int changed = 0;
	for(i=1;i<=number_cols;i++){
		if(i != coordinatesOfOne[1] and i != coordinatesOfOne[2]){
			if(changed == 0){											// because we do not need a leading zero-entry in the intvec newcols
				newcols[1] = i;	
				changed = 1;
			}else{
				newcols = newcols,i;
			}	
		}
	}
	
	matrix M = submat(redN,newcols,newcols);
	return(M);
}example{
		//TODO
}


proc generic_transformation_of_variables(matrix M)
"USAGE: generic_transformaion(matrix M); computes the transformation of variables
RETURN: list of matrix M and the ideal of the minors of the desired size
EXAMPLE: example generic_transformation_of_variables; shows an example
"
{
	int i,j;
	
	int number_cols = ncols(M);
	int number_rows = nrows(M);
	int new_nvars = 1; 											
	matrix newM = M;
	
	for(i = 1; i<= number_rows; i++){							
		for(j = 1; j<= number_cols; j++){
			newM[i,j] = var(new_nvars);
			new_nvars++;
		}
	}
	ideal minorideal = minor(newM,minorsize[1]);					//Calculate minor ideal of the right size
					
	return(newM, minorideal);
}example{
		//TODO
}



proc skewsymmetric_transformation_of_variables(matrix M)
"USAGE: skewsymmetric_transformation_of_variables(matrix M); computes the transformation of variables
RETURN: list of matrix M and the ideal of the minors of the desired size
EXAMPLE: example skewsymmetric_transformation_of_variables; shows an example
"
{
	int i,j;
	
	int number_cols = ncols(M);
	int number_rows = nrows(M);
	int new_nvars = 1; 											
	matrix newM = M;

	for(i = 1; i<= number_rows; i++){							
		for(j = i+1; j<= number_cols; j++){
			if(M[i,j] != 0){
				newM[i,j] = var(new_nvars);
				newM[j,i] = -var(new_nvars);
				new_nvars++;
			}
		}
	}
	ideal minorideal = minor(newM,minorsize[1]);						//Calculate minor ideal of the right size
	return(newM, minorideal);	
}example{
	//TODO	
}

proc symmetric_transformation_of_variables(matrix M)
"USAGE: symmetric_transformation_of_variables(matrix M); computes the transformation of variables
RETURN: list of matrix M and the ideal of the minors of the desired size
EXAMPLE: example symmetric_transformation_of_variables; shows an example
"
{
	int i,j;
	
	int number_cols = ncols(M);
	int number_rows = nrows(M);
	int new_nvars = 1; 											
	matrix newM = M;

	for(i = 1; i<= number_rows; i++){							
		for(j = i; j<= number_cols; j++){
			if(M[i,j] != 0){
				newM[i,j] = var(new_nvars);
				newM[j,i] = var(new_nvars);
				new_nvars++;
			}
		}
	}
	ideal minorideal = minor(newM,minorsize[1]);						//Calculate minor ideal of the right size
	return(newM, minorideal);	
}example{
	//TODO	
}
