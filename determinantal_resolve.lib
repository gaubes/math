version=" "; // $Id$
category=" ";
info="
LIBRARY:  determiantal_resolve.lib 
AUTHOR:  Sabrina Alexandra Gaube, sabrina.gaube@uol.de

PROCEDURES:

	determinantal_resolve(matrix M, int r);
	
	calculate_process_of_center_calculation(matrix M); returns the status of the algorithm as a string
	isSimultaneouslyLocallyMonomial(matrix M); returns if the entries of M are simultaneously locally monomial
	isLocallyMonomial(matrix M); returns if the entries of M are locally monomial
	isMonomial(matrix M); returns if the entries of M are monomial
	isresolvedMonomial(matrix M); returns if the entries of M are monomial and the monomial ideal generated by the entries is non-singular

	GenerateListOfBinomials(matrix M); return a list of entries of M which are not locally monomial
	UpdateListofBinomials(list L); where L is a list which was generated by GenerateListOfBinomials(M) and where we have to delete entries after some blow ups
	CreateBinomialFromMonomialMatrix(matrix M); calculate the binomial ideal (in the monomial case) which determines via black box the resolution process 


	blowUp3(J, C, #); same like blowUp2 but with the subcall blowUpBO(BO,C,2) instead of blowUpBO(BO,C,1);
	main_generic_resolve(mode, m, #); main method for resolution of all generic matrices, with string parameter mode
	generic_resolve(m, n, #); call method for resolution of generic mxn matrices
	skewsymmetric_resolve(m); call method for resolution of generic skewsymmetric mxm matrices
	symmetric_resolve(m); call method for resolution of generic ymmetric mxm matrices
	
	CopyDataInNextChartsAndBlowUp(M, Center, chartnumber); blow up method which copies data in the successor charts
	weakTransformOfMatrix(N); given a blown up matrix N it calculates the weak transform of a matrix with respect to rows and columns 
	
	generic_gauss(N, number_rows, number_cols); calculates the gaussian steps for the generic case
	skewsymmetric_gauss(N, number_rows, number_cols); gaussian steps for the skewsymmetric case 
	symmetric_gauss(N, number_rows, number_cols); gaussian steps for the symmetric case
	
	generic_transformation_of_variables(M); transformation of variables for the generic case
	skewsymmetric_transformation_of_variables(M); transformation of variables for the skewsymmetric case
	symmetric_transformation_of_variables(M); transformation of variables for the symmetric case
	
";

LIB "matrix.lib";
LIB "resolve.lib";
LIB "general.lib";	//absValue

LIB "resbinomial.lib"; //only for performancetests

proc blowUp3(ideal J,ideal C,list #)
"USAGE:  blowUp3(J,C[,W][,E]);
         W,J,C = ideals,
         E     = list
ASSUME:  J  = ideal containing W ( W = 0 if not specified)
@*       C  = ideal containing J
@*       E  = list of smooth hypersurfaces (e.g. exceptional divisors)
NOTE:    W the ideal of the ambient space, C the ideal of the center of
         the blowup and J the ideal of the variety
         Important difference to blowUp2:
         - the ambient space V(W) is blown up and V(J) transformed in it
@*         - V(C) is assumed to be non-singular
COMPUTE: the blowing up of W in C, the exceptional locus, the strict
         transform of J and the blowup map
RETURN:  list, say l, of size at most size(C),

         l[i] is the affine ring corresponding to the i-th chart
         each l[i] contains the ideals
         - aS, ideal of the blownup ambient space
         - sT, ideal of the strict transform
         - eD, ideal of the exceptional divisor
         - bM, ideal corresponding to the blowup map

         l[i] also contains a list BO, which can best be viewed with showBO(BO)
         detailed information on the data type BO can be viewed via the
         command showDataTypes();
EXAMPLE: example blowUp;  shows an example
"
{
  def S=basering;
  ideal W;
  list E;
  ideal abb=maxideal(1);
  intvec v;
  intvec bvec;
  intvec w=-1;
  matrix intE;
  if(size(#)>0)
  {
    if(typeof(#[1])=="ideal")
    {
      W=#[1];
    }
    if(typeof(#[1])=="list")
    {
      E=#[1];
    }
    if(size(#)>1)
    {
      if((typeof(#[2])=="list") && (size(E)==0))
      {
        E=#[2];
      }
      if((typeof(#[2])=="ideal") && (size(W)==0))
      {
        W=#[2];
      }
    }
  }
  list BO=W,J,bvec,E,abb,v,w,intE;
  int locaT;
  export locaT;
  list blow=blowUpBO(BO,C,2);
  kill locaT;
  int i;
  for(i=1;i<=size(blow);i++)
  {
     def Q=blow[i];
     setring Q;
     ideal aS=BO[1];
     ideal sT=BO[2];
     ideal eD=BO[4][size(BO[4])];
     ideal bM=BO[5];
     kill lastMap;
     kill thisChart;
     export(aS);
     export(sT);
     export(eD);
     export(bM);
     blow[i]=Q;
     setring S;
     kill Q;
  }
  return(blow);
}
example
{"EXAMPLE:";
   echo = 2;
   ring R=0,(x,y),dp;
   ideal J=x2-y3;
   ideal C=x,y;
   list blow=blowUp3(J,C);
   def Q=blow[1];
   setring Q;
   aS;
   sT;
   eD;
   bM;
}
//----------------------------------------------------------------------
//TODO
proc determinantal_resolve(matrix M, int r){
	
	
	ideal minorideal = minor(M,r);
	list minorsize = list(min(ncols(M),nrows(M)),var(1) );				//  variable and list is only technically in order that we can store the list in the ring!!!
	export(minorideal);
	export(minorsize);
	
	module path = [0,-1];												//path of the current chart, autoconverted to matrix
	export(path);
	
	ideal W = ideal(0);													//ambient space; Maybe change this later
	export(W);
	list E = list();													// list of exceptional divisors
	export(E);
	ideal abb=maxideal(1);
	export(abb);
	
	list BlowUpTree;
	BlowUpTree[1] = basering;
	
	string status;
	//------------------------------------------------------------------
	//TODO
	status = calculate_process_of_center_calculation(M);
	//TODO 
	//compute the center
	ideal cent = minor(M,1);	//TODO ersetzen!!! //maybe a list? only for Hu ? and a flag for 'Hu is finished'
	export(cent);
	BlowUpTree = BlowUpTree +  CopyDataInNextChartsAndBlowUp(M,cent,1);
	
	int i; int j; int k;
	
	int number_cols, number_rows;
	int mindim;
	int chart_counter = size(BlowUpTree);
	
	int oldsize;
	
	for(i = 2; i<= size(BlowUpTree);i++){			
		if(defined(XijChart)){
			kill(XijChart);
		}
		def XijChart = BlowUpTree[i];
		setring(XijChart);

		number_cols = ncols(N);
		number_rows = nrows(N);
	
	
		//compute in which stadium we are
		// if simultaneously locally monomial ... calculate a covering and a system of parameters like in the general case 
		// if gauss do generic gauss  
		ideal minorideal = transformationlist[2];
		export(minorideal); 
		mindim = min(ncols(M),nrows(M));
					
		list BOList = generate_BOList(M);
		export(BOList);
		
		//TODO:
		status = calculate_process_of_center_calculation(M);
		if(minorsize[1] > 2){		//TODO!!! change value 2 ?
			oldsize = size(BlowUpTree);
			ideal cent = minor(M,1);									//TODO: ersetzen
			export(cent);
			BlowUpTree = BlowUpTree + CopyDataInNextChartsAndBlowUp(M,cent,i);
			chart_counter = chart_counter + size(BlowUpTree) - oldsize;
		}
	}
	
	
	
	//TODO
	//------------------------------------------------------------------
	return(BlowUpTree);
}

//----------------------------------------------------------------------
proc calculate_process_of_center_calculation(matrix M)
"USAGE: calculate_process_of_center_calculation(matrix M); returns the status of the algorithm as a string
RETURN: a string which encodes the status of the resolution process
EXAMPLE: example calculate_process_of_center_calculation; shows an example
"
{
	int i,j,k;
	
	int number_cols = ncols(M);
	int number_rows = nrows(M);
	
	string mode;
	
	if(isLocallyMonomial(M) == 0){
		mode = "binresol";
		return(mode);
	}
	if(isLocallyMonomial(M) == 1 and isSimultaneouslyLocallyMonomial(M) == 0){
		mode = "Hu";
		return(mode);
	}
	if(isSimultaneouslyLocallyMonomial(M) and isMonomial(M) == 0){
		mode = "transformation";
		return(mode);
	}
	if(isMonomial(M) == 1 and isresolvedMonomial(M) == 0){ 
		mode = "monomial";
		return(mode);
	}
	if(isresolvedMonomial(M) == 1){
		mode = "gauss";
		return(mode);
	}
	return(mode);
}

//----------------------------------------------------------------------
proc isLocallyMonomial(matrix M)
"USAGE: isLocallyMonomial(matrix M); 
RETURN: 1 if the entries of M are locally monomial, 0 if there is an entry which is not locally monomial
EXAMPLE: example isLocallyMonomial; shows an example
"
{ // only 1-x^A equations allowed
	int i,j,k;
	int LocallyMonomial = 1;
	int number_cols = ncols(M);
	int number_rows = nrows(M);
	
	for(i=1;i<=number_rows;i++){
		for(j=1; j<= number_cols; j++){
			if(size(M[i,j])>1){				// at least binomial
				if(absValue(M[i,j][1]) != 1 and absValue(M[i,j][2]) != 1){		//M[i,j] = 1-x^A or x^A-1
					LocallyMonomial = 0;
				}
			}
		}
	}	
	return(LocallyMonomial);
}example{
	ring r =0, (x,y,z),dp;
	matrix M[3][2] = x,y,z,xy,1-x*y*z,2x;
	print(M);
	isLocallyMonomial (M);
	
	matrix N[3][2] = x^2+y,y,z,xy,1-x^3*y,2x;
	print(N);
	isLocallyMonomial (N);
}
//----------------------------------------------------------------------
proc isSimultaneouslyLocallyMonomial(matrix M)
"USAGE: isSimultaneouslyLocallyMonomial(matrix M); 
RETURN: 1 if the entries of M are simultaneously locally monomial, 0 if there is an entry which is not simultaneously locally monomial
EXAMPLE: example isSimultaneouslyLocallyMonomial; shows an example
"
{
	//TODO
	//something with normalcrossings and transversal components...
	return(0);
}


//----------------------------------------------------------------------
proc isMonomial(matrix M)
"USAGE: isMonomial(matrix M); 
RETURN: 1 if the entries of M are monomial, 0 if there is an entry which is not monomial
EXAMPLE: example isMonomial; shows an example
"
{ // only x^A equations allowed
	int i,j,k;
	int Monomial = 1;
	int number_cols = ncols(M);
	int number_rows = nrows(M);
	
	for(i=1;i<=number_rows;i++){
		for(j=1; j<= number_cols; j++){
			if(size(M[i,j]) > 1){				// at least binomial
				Monomial = 0;
			}
		}
	}	
	return(Monomial);
}example{
	ring r =0, (x,y,z),dp;
	matrix M[3][2] = x,y^3,z,xy,x*y*z,2x;
	print(M);
	isMonomial (M);
	
	matrix N[3][2] = x^2,y,z,xy,1-x^3*y,2x;
	print(N);
	isMonomial (N);
}
//----------------------------------------------------------------------
proc isresolvedMonomial(matrix M)
"USAGE: isresolvedMonomial(matrix M); 
RETURN: 1 if the entries of M are monomial and there is at least one 1 entry, 0 otherwise
EXAMPLE: example isresolvedMonomial; shows an example
"
{ // only x^A equations allowed
	int i,j;
	int resolved = 0;
	int number_cols = ncols(M);
	int number_rows = nrows(M);
	
	if(isMonomial(M) == 0){
		Error("Not monomial Matrix");
	}
	for(i=1;i<=number_rows;i++){
		for(j=1; j<= number_cols; j++){
			if(size(M[i,j])==1){				// at least binomial
				resolved = 1;
			}
		}
	}				
	return(resolved);
}example{
	ring r =0, (x,y,z),dp;
	matrix M[3][2] = x,y^3,z,xy,x*y*z,2x;
	print(M);
	isresolvedMonomial (M);
	
	matrix N[3][2] = x^2,y,z,xy,1,2x;
	print(N);
	isresolvedMonomial (N);

}
//----------------------------------------------------------------------
// auxiliary procedures for the binomial case
//----------------------------------------------------------------------
proc GenerateListOfBinomials(matrix M)
"USAGE: GenerateListOfBinomials(matrix M); 
RETURN: a list of entries of M which are not locally monomial
EXAMPLE: example GenerateListOfBinomials; shows an example
"{
	int i,j;
	int number_cols = ncols(M);
	int number_rows = nrows(M);
	list returnlist;
	
	for(i=1;i<=number_rows;i++){
		for(j=1; j<= number_cols; j++){
			if(isLocallyMonomial(M[i,j])==0){				// at least binomial
				returnlist[size(returnlist)+1] = M[i,j];
			}
		}
	}				
	
	return(returnlist);
}example{
	ring r =0, (x,y,z),dp;
	matrix M[3][2] = 1-x,x*z-y^3,z,3xy,x*y*z,2x+z;
	print(M);
	GenerateListOfBinomials(M);
} 
proc UpdateListofBinomials(list L)
"USAGE: UpdateListofBinomials(list L); where L is a list which was generated by GenerateListOfBinomials(M) and where we have to delete entries after some blow ups
RETURN: a list of entries of M which are not locally monomial
EXAMPLE: example UpdateListofBinomials; shows an example
"{	
	int i,j;
	int sizeL = size(L);
	
	for(i=1;i<=sizeL;i++){
		if(isLocallyMonomial(L[i]) == 1){
			L = delete(L,i);
			sizeL = size(L);
			i--;
		}
	}				
	
	return(L);
}example{
	ring r =0, (x,y,z),dp;
	list L = 1-x,x*z-y^3,z,3xy,x*y*z,2x+z;
	UpdateListofBinomials(L);
}
	
//----------------------------------------------------------------------
// auxiliary procedures for the monomial case
//----------------------------------------------------------------------	
proc CreateBinomialFromMonomialMatrix(matrix M)
"USAGE: CreateBinomialFromMonomialMatrix(matrix M); calculate the binomial ideal (in the monomial case) which determines via black box the resolution process 
RETURN: the binomial ideal corresponding to the determinantal monomial case
EXAMPLE: example CreateBinomialFromMonomialMatrix; shows an example
"
{		//requires a monomial matrix M
	def r = basering;			//TODO: save ring in List of Data in order to change back afterwards
	int n = nvars(r);
	ideal retideal;
	int i;
	
	ideal tmpideal = std(minor(M,1));
	int d = Maxord(0,tmpideal)[1];						//TODO: ambient space???
	int idealsize = size(tmpideal);						// we need 2*idealsize many new variables
	
	ring tmpr = 0,(z(1..2*idealsize)),dp;
	def newr = r + tmpr;								// TODO: Is this a good method to construct the new ring? 
	setring(newr);
	matrix Mnew = fetch(r,M);
	ideal tmpideal = fetch(r,tmpideal);
	
	for(i=1;i<=idealsize;i++){
		retideal[i] = var(n+2*i-1)^d * var(n+2*i ) + tmpideal[i];			// J = <y_{2l}^{d-1}y_{2l+1} + x^{A_l}>, but we want to start with y_1 instead of y_2 
	}
	
	return(retideal);									//maybe return more data, like r and new basering 
}example{
		//TODO
}





//----------------------------------------------------------------------

// 				generic case

//----------------------------------------------------------------------
proc main_generic_resolve(string mode, int m, list #)
"USAGE:main_generic_resolve(string mode, int m[, int n , int r] ); computes the resolution of the ideal of r-minors of a (skew)-symmetric generic mxm matrix with mode = skew or mode = sym or generic mxn matrix with mode = gen
RETURN: list of rings which represent the charts during the whole resolution process
EXAMPLE: example generic_resolve; shows an example
"
{
	int minsize;
	if(mode == "gen"){
		if(size(#)>0){
			int n = #[1];
		}else{
			int n = m;
		}
		ring r = 0,(x(1..m*n)),dp;
		matrix M = genericmat(m,n);
		minsize = 1;
	}
	if(mode == "sym"){
		ring r = 0,(x(1..m*(m+1) div 2)),dp;
		matrix M = symmat(m);
		minsize = 1;			//TODO???
	}
	if(mode == "skew"){
		ring r = 0,(x(1..m*(m-1)div 2)),dp;
		matrix M = skewmat(m);
		minsize = 2;
	}
	if(!defined(r)){
		ERROR("choose a mode gen,sym or skew followed by the size of your generic matrix");
	}
	
	list minorsize = list(min(ncols(M),nrows(M)),var(1) );				// default: resolve maximal minors; variable and list is only technically in order that we can store the list in the ring!!!
	ideal minorideal = radical(minor(M,1));
	if(size(#)>1 and mode == "gen"){
		if(typeof(#[2])=="int"){
			minorsize[1] = #[2];										//calculate how long we have to blow up until the #[1]-minors are resolved
			minorideal = radical(minor(M,minorsize[1]));
		}
	}
	if(size(#)>0 and mode != "gen"){
		if(typeof(#[1])=="int"){
			minorsize[1] = #[1];										//calculate how long we have to blow up until the #[1]-minors are resolved
			minorideal = minor(M,minorsize[1]);
		}
	}
	
	export(minorsize);

	export(minorideal);
	
	module path = [0,-1];												//path of the current chart, autoconverted to matrix
	export(path);
	
	ideal W = ideal(0);													//ambient space; Maybe change this later
	export(W);
	list E = list();													// list of exceptional divisors
	export(E);
	ideal abb=maxideal(1);
	export(abb);
	
	list BlowUpTree;
	BlowUpTree[1] = basering;
	ideal cent = minor(M,1);											//auxiliary data 
	export(cent);
	
	if(minorsize[1] <= minsize){													// ideal of 1 minors is already resolved
		return(BlowUpTree,1,1);
	}
	
	BlowUpTree = BlowUpTree +  CopyDataInNextChartsAndBlowUp(M,radical(minor(M,1)),1);
	int i; int j; int k;
	
	int number_cols, number_rows;
	int mindim;
	int chart_counter = size(BlowUpTree);
	int end_chart_counter;
	
	int oldsize;
	for(i = 2; i<= size(BlowUpTree);i++){			
		if(defined(XijChart)){
			kill(XijChart);
		}
		def XijChart = BlowUpTree[i];
		setring(XijChart);

		number_cols = ncols(N);
		number_rows = nrows(N);
		if(mode == "gen"){
			matrix M = generic_gauss(Ntmp, number_rows,number_cols); 					// Reduction in Dimension
			list transformationlist = generic_transformation_of_variables(M);			//Transformation for the new system of parameters
		}
		if(mode =="sym"){
			matrix M = symmetric_gauss(Ntmp, number_rows,number_cols); 					
			list transformationlist = symmetric_transformation_of_variables(M);			
		}
		if(mode =="skew"){
			matrix M = skewsymmetric_gauss(Ntmp, number_rows,number_cols); 					
			list transformationlist = skewsymmetric_transformation_of_variables(M);			
		}
		M = transformationlist[1];
		ideal minorideal = transformationlist[2];
		export(minorideal); 
		mindim = min(ncols(M),nrows(M));
					
		list BOList = generate_BOList(M);
		export(BOList);
		
		if(minorsize[1] > minsize){		//TODO!!! depends on the mode
			oldsize = size(BlowUpTree);
			ideal cent = minor(M,1);									//auxiliary data 
			export(cent);
			BlowUpTree = BlowUpTree + CopyDataInNextChartsAndBlowUp(M,radical(minor(M,1)),i);
			chart_counter = chart_counter + size(BlowUpTree) - oldsize;
		}else{
			end_chart_counter++;
		}
	}
	return(BlowUpTree,chart_counter,end_chart_counter);
	
	
	
	return(1);
}
proc generic_resolve(int m, list #)
"USAGE:generic_resolve(int m[, int n , int r] ); computes the resolution of the ideal of r-minors of a generic mxn matrix
RETURN: list of rings which represent the charts during the whole resolution process
EXAMPLE: example generic_resolve; shows an example
"
{						
	int n, r;
	list BlowUpTree;
	if (size(#)>0){
		n = #[1];
		if(size(#)>1){
			r = #[2];
			BlowUpTree = main_generic_resolve("gen",m,n,r);
		}else{
			BlowUpTree = main_generic_resolve("gen",m,n);
		}
	}else{
		BlowUpTree = main_generic_resolve("gen",m,m);
	}
	
	return(BlowUpTree);
}
example{ 	
	generic_resolve(4,3,2);
}


proc skewsymmetric_resolve(int m, list #)
"USAGE:skewsymmetric_resolve(int m [, int r] ); computes the resolution of the ideal of r-minors of a generic skewsymmetric mxm matrix
RETURN: list of rings which represent the charts during the whole resolution process
EXAMPLE: example skewsymmetric_resolve; shows an example
"
{
	int r;
	list BlowUpTree;
	if (size(#)>0){
		r = #[1];
		BlowUpTree = main_generic_resolve("skew",m,r);
	}else{
		BlowUpTree = main_generic_resolve("skew",m);
	}
	
	return(BlowUpTree);
}example{
	skewsymmetric_resolve(4);
}


proc symmetric_resolve(int m, list #)
"USAGE:symmetric_resolve(int m [, int r] ); computes the resolution of the ideal of r-minors of a generic skewsymmetric mxm matrix
RETURN: list of rings which represent the charts during the whole resolution process
EXAMPLE: example skewsymmetric_resolve; shows an example
"
{
	int r;
	list BlowUpTree;
	if (size(#)>0){
		r = #[1];
		BlowUpTree = main_generic_resolve("sym",m,r);
	}else{
		BlowUpTree = main_generic_resolve("sym",m);
	}
	
	return(BlowUpTree);
}example{
	symmetric_resolve(4);
}


proc CopyDataInNextChartsAndBlowUp(matrix M, ideal Center, int chartnumber)
"USAGE: CopyDataInNextChartAndBlowUp(matrix M, ideal Center, int chartnumber ); computes the blow up and copies the data (strict transform, ideal and pathmatrix) in the successorcharts
RETURN: list of rings which represent the charts during the whole resolution process
EXAMPLE: example CopyDataInNextChartAndBlowUp; shows an example
"
{
	int j, number_cols,number_rows;
	int Edefined = 1;
	def r = basering;
	if(size(E) == 0){Edefined = 0;}
	list successorList = blowUp3(W,Center);
	int number_center_components = size(successorList);

	for(j = 1;j<=number_center_components; j++){
		if(defined(newring)){kill newring;}
		
		def newring = successorList[j];
		setring(newring);
		map BlowUpMap = r,bM;		
		ideal W = BlowUpMap(W);
		export(W);
		if(!Edefined){ list E = list();}
		else{list E = BlowUpMap(E);}
		E[size(E)+1] = eD[1];
		export(E);

		ideal abb = BlowUpMap(abb);					//abbildung aus resolve.lib //TODO: mit bM verknuepfen!!!!
		export(abb); 	
		matrix N = BlowUpMap(M);				// total transform
		export(N);
		//matrix Ntmp = sat(N+sT,eD[1])[1];		// Achtung !!! Reihenfolge der EintrÃ¤ge und Dimension der neuen Matrix!!!
		matrix Ntmp = weakTransformOfMatrix(N);
		export(Ntmp);
		number_cols = ncols(N);
		number_rows = nrows(N);

		def path = imap(r,path);				//init pathmatrix 
		path=path,[chartnumber,j];
		export(path);
		
		list minorsize = BlowUpMap(minorsize);
		export(minorsize);
	}
	return(successorList);
}example{
	ring r = 0,(x(1..12)),dp;
	matrix M = genericmat(3,4);
	CopyDataInNextChartsAndBlowUp(M,std(minor(M,1)),1);	
}


proc weakTransformOfMatrix(matrix N)	
"USAGE: weakTransformOfMatrix(matrix N); given a blown up matrix N it calculates the weak transform of a matrix with respect to rows and columns
RETURN: transformed matrix 
EXAMPLE: example weakTransformOfMatrix; shows an example
"
{
	int i,j,k;
	int number_rows = nrows(N);
	int number_cols = ncols(N);
	
	
	//find maximal value  c such that we can factor out eD[1]^c in each row:
	poly tmp_entry;
	poly tmp_eDPowC;
	int eDDividesRow;
	
	for(i=1; i<= number_rows;i++){
		tmp_eDPowC = eD[1];
		eDDividesRow = 1;
		while(eDDividesRow){
			for(j=1; j<=number_cols; j++){
				if(N[i,j] != 0){									// without this, a skewsymmetric matrix is returned as total transform because of the zero entries
					tmp_entry = N[i,j] div tmp_eDPowC;						
					if(tmp_entry == 0){
						eDDividesRow = 0;
						break;
					}
				}
			}
			if(eDDividesRow){
				tmp_eDPowC = tmp_eDPowC * eD[1];
			}else{
				tmp_eDPowC = tmp_eDPowC div eD[1];
			}
		}
		for(j = 1; j<= number_cols; j++){
			N[i,j] = N[i,j] div tmp_eDPowC;
		}
	}
	
	//same procedure for each column:
	for(j=1; j<= number_cols;j++){
		tmp_eDPowC = eD[1];
		eDDividesRow = 1;
		while(eDDividesRow){
			for(i=1; i<=number_rows; i++){
				tmp_entry = N[i,j] div tmp_eDPowC;						
				if(tmp_entry == 0){
					eDDividesRow = 0;
					break;
				}
			}
			if(eDDividesRow){
				tmp_eDPowC = tmp_eDPowC * eD[1];
			}else{
				tmp_eDPowC = tmp_eDPowC div eD[1];
			}
		}
		for(i = 1; i<= number_rows; i++){
			N[i,j] = N[i,j] div tmp_eDPowC;
		}
	}
	
	return(N);
}example{
	ring r = 0,(x(1..9)),dp;
	matrix N[3][3] = x(1),x(1)*x(2),x(1)*x(3),x(1)*x(4),x(1)*x(5),x(1)*x(6),x(1)*x(7),x(1)*x(8),x(1)*x(9); 
	print(N);
	list eD;
	eD[1] = x(1);
	export(eD);
	weakTransformOfMatrix(N);
	
	matrix N[3][3] = x(1)^2,x(1)^2*x(2),x(1)^3*x(3),x(1)*x(4),x(1)*x(5),x(1)*x(6),x(1)^5*x(7),x(1)^4*x(8),x(1)*x(9); 
	print(N);
	weakTransformOfMatrix(N);
}


proc generic_gauss(matrix N, int number_rows, int number_cols)			//TODO: compute the map of abb
"USAGE: generic_gauss(matrix N, int number_rows, int number_cols ); computes the gaussian steps in the resolution process.
RETURN: transformed matrix M
EXAMPLE: example generic_gauss; shows an example
"
{		
	int i,j,k;
	
	intvec newcols, newrows, cols, rows;
	
	cols = 1..number_cols;
	rows = 1..number_rows;
	matrix N2 = submat(N,rows,cols);		//Gaussian steps
	matrix colN = colred(N2);
	matrix redN = rowred(colN);
	
	for(j =1; j<= number_rows;j++){
		for(k = 1; k<= number_cols;k++){
			if(redN[j,k] == 1) {break;}
		}
		if(redN[j,k] == 1) {break;}  
	}										// 1 at position [j,k] -> choose submatrix without this entry
		
	if(j==1){
		newrows = 2..number_rows;
	} else{ 
		if (j == number_rows){
			newrows = 1..number_rows-1; 
		} else{
			newrows = 1..j-1,j+1,,number_rows;
		}
	}
	if(k==1){
		newcols = 2..number_cols;
	} else{ 
		if (k == number_cols){
			newcols = 1..number_cols-1; 
		} else{
			newcols = 1..k-1,k+1,,number_cols;
		}
	}
	matrix M = submat(redN,newrows,newcols);
	
	minorsize[1] = minorsize[1] - 1;	//internal note that the desired minorsize has decrease
	
	return(M);
}example{
	//Todo
}

proc skewsymmetric_gauss(matrix N, int number_rows, int number_cols)	//TODO: compute the map of abb
"USAGE: skewsymmetric_gauss(matrix N, int number_rows, int number_cols ); computes the gaussian steps in the resolution process.
RETURN: transformed matrix M
EXAMPLE: example skewsymmetric_gauss; shows an example
"
{		
	int i,j,k,l;
	intvec newcols, newrows;
	intvec coordinatesOfOne = 0,0;
	
	intvec cols = 1..number_cols;
	intvec rows = 1..number_rows;

	matrix redN = submat(N,rows,cols);
	//destroys the skewsymmetric structure :
	//matrix redN = rowred(colN);
	
	for(j = 1; j<= number_rows;j++){
		for(k = 1; k<= number_cols;k++){
			if(redN[j,k] == 1) {coordinatesOfOne = j,k;}				// 1 at position [j,k] -> choose submatrix without this entry
		} 
	}										
	if(coordinatesOfOne[1] == 0){~;}
	
	matrix Ntemp = redN;
	//[j,k] is the entry which equals 1 -> [k,j] equals -1
	for(i = 1; i <= number_rows; i++){									//row operations for the first 0-column
		for(l = 1; l<=number_cols; l++){
			if(i != coordinatesOfOne[1] and i != coordinatesOfOne[2]){
				redN[i,l] = Ntemp[i,l] - Ntemp[i,coordinatesOfOne[2]] * Ntemp[coordinatesOfOne[1],l];
			}
		}
	}
	Ntemp = redN;

	// let the column entries vanish:
	for(l=1;l<=number_cols;l++){
		if(coordinatesOfOne[2] != l){
			redN[coordinatesOfOne[1],l] = 0;
		}
	}
	Ntemp = redN;
	
	for(i = 1; i <= number_rows; i++){							//column operations for the second 0-row
		for(l = 1; l<=number_cols; l++){
			if(l!= coordinatesOfOne[2] and l!= coordinatesOfOne[1]){
				redN[i,l] = Ntemp[i,l] + Ntemp[i,coordinatesOfOne[1]] * Ntemp[coordinatesOfOne[2],l];
			}
		}
	}
	Ntemp = redN;
	
	// let the column entries vanish:
	for(i=1;i<=number_cols;i++){
		if(coordinatesOfOne[2] != i){
			redN[i,coordinatesOfOne[1]] = 0;
		}
	}
	Ntemp = redN;
	
	int changed = 0;
	for(i=1;i<=number_cols;i++){
		if(i != coordinatesOfOne[1] and i != coordinatesOfOne[2]){
			if(changed == 0){						// because we do not need a leading zero-entry in the intvec newcols
				newcols[1] = i;	
				changed = 1;
			}else{
				newcols = newcols,i;
			}	
		}
	}
	
	minorsize[1] = minorsize[1] - 2;	//internal note that the desired minorsize has decrease
	matrix M = submat(redN,newcols,newcols);
	return(M);
}example{
		//TODO
}

proc symmetric_gauss(matrix N, int number_rows, int number_cols)	//TODO: compute the map of abb
"USAGE: symmetric_gauss(matrix N, int number_rows, int number_cols ); computes the gaussian steps in the resolution process.
RETURN: transformed matrix M
EXAMPLE: example symmetric_gauss; shows an example
"
{		
	int i,j,k,l;
	poly epsilon;
	intvec newcols, newrows, cols, rows;
	intvec coordinatesOfOne;
	
	cols = 1..number_cols;
	rows = 1..number_rows;
	matrix redN = submat(N,rows,cols);
	
	for(j = 1; j<= number_rows;j++){
		for(k = 1; k<= number_cols;k++){
			if(redN[j,k] == 1) {coordinatesOfOne = j,k;}
		} 
	}										// 1 at position [j,k] -> choose submatrix without this entry
	
	epsilon = 1-redN[coordinatesOfOne[1],coordinatesOfOne[1]] * redN[coordinatesOfOne[2],coordinatesOfOne[2]];
	
	matrix Ntemp = redN;

	// distinguish diagonal and non-diagonal entries
	if(coordinatesOfOne[1] == coordinatesOfOne[2]){			
		for(i = 1; i <= number_rows; i++){							//row operations for the first 0-column
			for(l = 1; l <= number_cols; l++){
				if(i != coordinatesOfOne[1]){
					redN[i,l] = Ntemp[i,l] - Ntemp[i,coordinatesOfOne[1]] * Ntemp[coordinatesOfOne[1],l];
				}
			}
		}
		Ntemp = redN;

		// let the column entries vanish:
		for(i=1;i<=number_cols;i++){
			if(coordinatesOfOne[1] != i){
				redN[coordinatesOfOne[1],i] = 0;
			}
		}
		Ntemp = redN;
		minorsize[1] = minorsize[1] - 1;								//internal note that the desired minorsize has decrease
	}else{			//non-diagonal 1-entries [j,k] and [k,j]
		for(i = 1; i <= number_rows; i++){								//row operations for the first 0-column
			for(l = 1; l<=number_cols; l++){
				if(i != coordinatesOfOne[2]){
					redN[i,l] = Ntemp[i,l] - Ntemp[i,coordinatesOfOne[1]] * Ntemp[coordinatesOfOne[2],l];
				}
			}
		}
		Ntemp = redN;
		// let the column entries vanish:
		for(i=1;i<=number_cols;i++){
			if(coordinatesOfOne[1] != i){
				redN[coordinatesOfOne[2],i] = 0;
			}
		}
		Ntemp = redN;
		
		//Divide and multiply with epsilon:
		redN[coordinatesOfOne[1],coordinatesOfOne[2]] = 1;
		Ntemp = redN;
		
		for(i = 1;i<= number_rows; i++){
			if(i!=coordinatesOfOne[1] and i != coordinatesOfOne[2]){
				for(l=1; l<= number_cols; l++){
					if(l!=coordinatesOfOne[1] and l != coordinatesOfOne[2]){
						redN[i,l] = redN[i,l] * epsilon;
					}
				}
			}
		}
		
		Ntemp = redN;
		for(i = 1; i <= number_rows; i++){								//row operations for the second 0-column
			for(l = 1; l<=number_cols; l++){
				if(i != coordinatesOfOne[1]){
					redN[i,l] = Ntemp[i,l] - Ntemp[i,coordinatesOfOne[2]] * Ntemp[coordinatesOfOne[1],l];
				}
			}
		}

		Ntemp = redN;		
		// let the column entries vanish:
		for(i=1;i<=number_cols;i++){
			if(coordinatesOfOne[2] != i){
				redN[coordinatesOfOne[1],i] = 0;
			}
		}
		Ntemp = redN;
		minorsize[1] = minorsize[1] - 2;								//internal note that the desired minorsize has decrease
	}
	
	int changed = 0;
	for(i=1;i<=number_cols;i++){
		if(i != coordinatesOfOne[1] and i != coordinatesOfOne[2]){
			if(changed == 0){											// because we do not need a leading zero-entry in the intvec newcols
				newcols[1] = i;	
				changed = 1;
			}else{
				newcols = newcols,i;
			}	
		}
	}
	
	matrix M = submat(redN,newcols,newcols);
	return(M);
}example{
		//TODO
}


proc generic_transformation_of_variables(matrix M)
"USAGE: generic_transformaion(matrix M); computes the transformation of variables
RETURN: list of matrix M and the ideal of the minors of the desired size
EXAMPLE: example generic_transformation_of_variables; shows an example
"
{
	int i,j;
	
	int number_cols = ncols(M);
	int number_rows = nrows(M);
	int new_nvars = 1; 											
	matrix newM = M;
	
	for(i = 1; i<= number_rows; i++){							
		for(j = 1; j<= number_cols; j++){
			newM[i,j] = var(new_nvars);
			new_nvars++;
		}
	}
	ideal minorideal = minor(newM,minorsize[1]);					//Calculate minor ideal of the right size
					
	return(newM, minorideal);
}example{
		//TODO
}



proc skewsymmetric_transformation_of_variables(matrix M)
"USAGE: skewsymmetric_transformation_of_variables(matrix M); computes the transformation of variables
RETURN: list of matrix M and the ideal of the minors of the desired size
EXAMPLE: example skewsymmetric_transformation_of_variables; shows an example
"
{
	int i,j;
	
	int number_cols = ncols(M);
	int number_rows = nrows(M);
	int new_nvars = 1; 											
	matrix newM = M;

	for(i = 1; i<= number_rows; i++){							
		for(j = i+1; j<= number_cols; j++){
			if(M[i,j] != 0){
				newM[i,j] = var(new_nvars);
				newM[j,i] = -var(new_nvars);
				new_nvars++;
			}
		}
	}
	ideal minorideal = minor(newM,minorsize[1]);						//Calculate minor ideal of the right size
	return(newM, minorideal);	
}example{
	//TODO	
}

proc symmetric_transformation_of_variables(matrix M)
"USAGE: symmetric_transformation_of_variables(matrix M); computes the transformation of variables
RETURN: list of matrix M and the ideal of the minors of the desired size
EXAMPLE: example symmetric_transformation_of_variables; shows an example
"
{
	int i,j;
	
	int number_cols = ncols(M);
	int number_rows = nrows(M);
	int new_nvars = 1; 											
	matrix newM = M;

	for(i = 1; i<= number_rows; i++){							
		for(j = i; j<= number_cols; j++){
			if(M[i,j] != 0){
				newM[i,j] = var(new_nvars);
				newM[j,i] = var(new_nvars);
				new_nvars++;
			}
		}
	}
	ideal minorideal = minor(newM,minorsize[1]);						//Calculate minor ideal of the right size
	return(newM, minorideal);	
}example{
	//TODO	
}

proc generate_BOList(matrix M){
	//BO[1] ambient space Wi
	//BO[2] ideal defining the strict transform
	//BO[3] invariant ???
	//BO[4] exceptional divisors E
	//BO[5] ideal defining K[W] --> K[Wi]
	//BO[6] ???
	//BO[7] ???
	//BO[8] matrix ???
	//BO[9] ???
	//BO[10] center cannot split into connected components in the generic case!
	
	//auxiliary data:
	//cent defining the center
	//path module which describes the path matrix
	//lastMap ideal describing the preceding blow up leading to this chart
	list BO;
	BO[1] = W;					
	BO[2] = minor(M,minorsize);
	
	BO[4] = E;				//Todo: calculate list E of exceptional divisors 
	BO[5] = abb;			// Todo: calculate ideal defining the map

	return(BO);
}
//additional data in the determinantal case:
// correspondence between sublist of polynomials and position of the corresponding entry in the matrix
 
//----------------------------------------------------------------------

proc test_generic_vs_resolve(int m,int n){

	link l2 = ":w Testfaelle/resolve.txt";
	link l1 = ":w Testfaelle/generic_resolve.txt";
	
	list linklist = list(l1,l2);
	int i; int j;
	ring r = 0,(x(1..m*n)),dp;
	matrix M = genericmat(m,n);
	int minorsize = min(m,n);
	ideal I = minor(M,minorsize);		//maximal minors
	list blowuplist;
	
	list sum_runtime = list(0,0,0,0);
	list sum_endcharts = list(0,0,0,0);
	list sum_charts = list(0,0,0,0);
	int runningtime = 0;
	int whole_runningtime = 0;
	int tmp_runningtime = 0;
	
	//Test binomial-calculations:
	for(minorsize=3;minorsize<=min(m,n); minorsize++){
		//f = create_test_binomial(maxdegree, mode);
		I = minor(M,minorsize);
		tmp_runningtime = rtimer;
		blowuplist = generic_resolve(m,n,minorsize);
		runningtime = rtimer - tmp_runningtime;	
		//fprintf(linklist[i],"binomial: %l	endcharts: %s	charts: %s	runtime: %s",f,blowuplist[2],size(blowuplist[1]),blowuplist[4]);	
		fprintf(linklist[1]," Matrix: %s	minorsize: %s	endcharts: %s	charts: %s	running time: %s",M,minorsize,blowuplist[3],blowuplist[2], runningtime);	
		// only for later stats calculations:
		
		//sum_runtime[i] = sum_runtime[i] + blowuplist[4];
		//sum_endcharts[i] = sum_endcharts[i] + blowuplist[2];
		//sum_charts[i] = sum_charts[i] + size(blowuplist[1]);
		tmp_runningtime = rtimer;
		blowuplist = resolve(I);
		runningtime = rtimer - tmp_runningtime;	
		fprintf(linklist[2]," Matrix: %s	minorsize: %s	endcharts: %s	charts: %s	running time: %s", M,minorsize,size(blowuplist[1]),size(blowuplist[2]), runningtime);
		
	}
	
	
	//compute average values:
	//list average_runtime 	= list(sum_runtime[1] div binomialcount, sum_runtime[2] div binomialcount, sum_runtime[3] div binomialcount, sum_runtime[4] div binomialcount); 
	//list average_endcharts 	= list(sum_endcharts[1] div binomialcount, sum_endcharts[2] div binomialcount, sum_endcharts[3] div binomialcount, sum_endcharts[4] div binomialcount);
	//list average_charts 	= list(sum_charts[1] div binomialcount, sum_charts[2] div binomialcount, sum_endcharts[3] div binomialcount, sum_endcharts[4] div binomialcount);
	
	//compute the stats:
	//for(i = 1;i<=size(linklist);i++){
	//	fprintf(linklist[i],"average-endcharts: %s	average-charts: %s	average-runtime: %s",average_endcharts[i],average_charts[i],average_runtime[i]);	
	//}
	
	//close files:
	close(l1);
	close(l2);
	//close(l3);
	//close(l4);
}


proc test_skew_vs_resolve(int m){

	link l2 = ":w Testfaelle/resolve_skew.txt";
	link l1 = ":w Testfaelle/skew_generic.txt";
	
	list linklist = list(l1,l2);
	int i; int j;
	ring r = 0,(x(1..m*(m-1)div 2)),dp;
	matrix M = skewmat(m);
	int minorsize = m;
	ideal I = minor(M,minorsize);		//maximal minors
	list blowuplist;
	
	int runningtime = 0;
	int whole_runningtime = 0;
	int tmp_runningtime = 0;
	
	//Test binomial-calculations:
	for(minorsize=4;minorsize<=m; minorsize=minorsize+2){
		//f = create_test_binomial(maxdegree, mode);
		I = radical(std(minor(M,minorsize)));
		tmp_runningtime = rtimer;
		blowuplist = skewsymmetric_resolve(m,minorsize);
		runningtime = rtimer - tmp_runningtime;	
		//fprintf(linklist[i],"binomial: %l	endcharts: %s	charts: %s	runtime: %s",f,blowuplist[2],size(blowuplist[1]),blowuplist[4]);	
		fprintf(linklist[1]," Matrix: %s	minorsize: %s	endcharts: %s	charts: %s	running time: %s",M,minorsize,blowuplist[3],blowuplist[2], runningtime);	
		// only for later stats calculations:
		
		//sum_runtime[i] = sum_runtime[i] + blowuplist[4];
		//sum_endcharts[i] = sum_endcharts[i] + blowuplist[2];
		//sum_charts[i] = sum_charts[i] + size(blowuplist[1]);
		tmp_runningtime = rtimer;
		blowuplist = resolve(I);
		runningtime = rtimer - tmp_runningtime;	
		fprintf(linklist[2]," Matrix: %s	minorsize: %s	endcharts: %s	charts: %s	running time: %s", M,minorsize,size(blowuplist[1]),size(blowuplist[2]), runningtime);
		
	}
	
	
	//compute average values:
	//list average_runtime 	= list(sum_runtime[1] div binomialcount, sum_runtime[2] div binomialcount, sum_runtime[3] div binomialcount, sum_runtime[4] div binomialcount); 
	//list average_endcharts 	= list(sum_endcharts[1] div binomialcount, sum_endcharts[2] div binomialcount, sum_endcharts[3] div binomialcount, sum_endcharts[4] div binomialcount);
	//list average_charts 	= list(sum_charts[1] div binomialcount, sum_charts[2] div binomialcount, sum_endcharts[3] div binomialcount, sum_endcharts[4] div binomialcount);
	
	//compute the stats:
	//for(i = 1;i<=size(linklist);i++){
	//	fprintf(linklist[i],"average-endcharts: %s	average-charts: %s	average-runtime: %s",average_endcharts[i],average_charts[i],average_runtime[i]);	
	//}
	
	//close files:
	close(l1);
	close(l2);
	//close(l3);
	//close(l4);
}

proc test_skew(int m){
	link l1 = ":w Testfaelle/skew_generic_number_charts.txt";
	
	list linklist = list(l1);
	int i; int j;
	ring r = 0,(x(1..m*(m-1)div 2)),dp;
	matrix M = skewmat(m);
	int minorsize = m;
	ideal I = minor(M,minorsize);		//maximal minors
	list blowuplist;
	
	int runningtime = 0;
	int whole_runningtime = 0;
	int tmp_runningtime = 0;
	
	//Test binomial-calculations:
	for(minorsize=4;minorsize<=m; minorsize=minorsize+2){
		tmp_runningtime = rtimer;
		blowuplist = skewsymmetric_resolve(minorsize,minorsize);
		runningtime = rtimer - tmp_runningtime;	
	
		fprintf(linklist[1],"	minorsize: %s	endcharts: %s	charts: %s	running time: %s",minorsize,blowuplist[3],blowuplist[2], runningtime);	

	}

	close(l1);
}



proc binomial_test_generic_vs_resbinomial(int m){		//only 2-minors of generic jxj matrices for 2<=j<=m

	link l3 = ":w Testfaelle/resbinomial.txt";
	
	link l2 = ":w Testfaelle/binomial_resolve.txt";
	link l1 = ":w Testfaelle/binomial_generic_resolve.txt";
	
	list linklist = list(l1,l2,l3);
	int i; int j;
	ring r = 0,(x(1..m*2)),dp;
	matrix M = genericmat(m,2);
	int minorsize = 2;
	ideal I = minor(M,minorsize);		//maximal minors
	list blowuplist;
	
	list sum_runtime = list(0,0,0,0);
	list sum_endcharts = list(0,0,0,0);
	list sum_charts = list(0,0,0,0);
	int runningtime = 0;
	int whole_runningtime = 0;
	int tmp_runningtime = 0;
	
	//Test binomial-calculations:
	for(j=4;j<=m;j++){
		//f = create_test_binomial(maxdegree, mode);
		M = genericmat(j,2);
		I = minor(M,minorsize);
		tmp_runningtime = rtimer;
		blowuplist = generic_resolve(j,j,minorsize);
		runningtime = rtimer - tmp_runningtime;	
		//fprintf(linklist[i],"binomial: %l	endcharts: %s	charts: %s	runtime: %s",f,blowuplist[2],size(blowuplist[1]),blowuplist[4]);	
		fprintf(linklist[1]," Matrix: %s	minorsize: %s	endcharts: %s	charts: %s	running time: %s",M,minorsize,blowuplist[3],blowuplist[2], runningtime);	
		
		tmp_runningtime = rtimer;
		blowuplist = BINresol(I);
		runningtime = rtimer - tmp_runningtime;	
		fprintf(linklist[3]," Matrix: %s	minorsize: %s	endcharts: %s	charts: %s	running time: %s", M,minorsize,size(blowuplist[1]),size(blowuplist[2]), runningtime);

	}
	
	//close files:
	close(l1);
	close(l2);
	close(l3);

}


