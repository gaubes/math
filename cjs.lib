version=" "; // $Id$
category=" ";
info="
LIBRARY:  test_ring.lib 
AUTHOR:  Sabrina Alexandra Gaube, sabrina.gaube@uni-oldenburg.de


PROCEDURES:
	show_strict_transforms(list L);
	show_actual_chart();
	print_binomial_cjs(ideal I,int mode);
	ResTreeCJS(list re, list #);
	blowUp3(ideal J,ideal C,list #);
	
	binomial_cjs(I,L,mode); main method of recursive CJS. gets the actual chart and a binomial variety
	init_lists(I); initialize the list data-structure w.r.t the input binomialideal
	CopiesOfCharts(chartnumber,mode); copies data from a recursive CJS and transform data to the upper call of CJS
	gcd_of_polynomial_and_variable(f,x); returns the gcd(f,x) and the exponent of x in the gcd	
	elimparts_in_IX(); simplifies the generators of the ideal IX in order to make it checkable whether it is singular or nor
	labeling(list Y_new, ideal last_Center);
	OrderByLabel(list Y_new);
	create_tower_of_centers(ideal Y,list tower, list invariant, list boundary);
	SetAllBoundaryCompOld(list invariant, list invariant_new, list boundary, list tower);
	MaxOrdArithO(ideal IZ, ideal IX, ideal descended_IZ, list boundary, list #);
	isEndChart(); checks whether log-inv = (1,...,1,0) or IX = 1
	invariantHasImproved(invariant, invariant_new); checks whether invariant has improved
	
	
	
	EqualityOfIdeal(I,J); test if I equals J
	EqualToZero(I); test if I equals 0
	EqualToOneOverZp(I,p); test if I equals 1 over Zp
	EqualityOfList(l,k); test if l equals k
	MemberOfList(f,L); test if L cotains f
	AppendListToList(L1,L2); appends L2 to L1 without duplicates
	ListOfCoeffs(I); returns coefficients from I for calculate HasseDeriv
	IntersectionWithRingEqualZero(I); test if intersection of I and the ring equals 0
	IntersectionWithRing(I); computes intersection of I and the ring 
	HasseDeriv(IZ,IX,y,M) computes the Hasse-Schmidt derivation of IZ and IX with respect to y and M
	Codimension(I); computes Codimension of I
	ConditionOfL1(L1,JX,list #); test if JX satisfy conditions on a covering of L1 for maxord calculations
	GenerateL1(CoDimZ,JZ,IX,IZ,list # ); generates L1 with to respect to conditions on maxord calculations
	SystemOfParameters(member,colIndices,CoDimZ); computes a system of parameters with respect to conditions on maxord calculations
	PseudoDifferential(f,j,A,q,I,y); computes pseudodifferentials with respect to a system of parameters
	MaxOrd(IZ,IX); computes the locus of maximal order in geometric case
	InterestingPrimes(IZ,IX); computes the interesting primes in the arithmetic case
	ReplaceCoeffsMaxOrdArith(I,p); replaces coefficients of I with respect to p in the arithmetic maxord algorithm 
	newCoeff(oldCoeff,p); computes new coefficients for the replacecoeffsmaxordarith algorithm
	SearchMaxPower(c,p); computes highest power of p which divides c
	MaxOrdArith(IZ,IX); computes the locus of maximal order in the arithmetic case
	
";


LIB "elim.lib";
LIB "gitfan.lib";
LIB "linalg.lib";
LIB "general.lib";
LIB "primdecint.lib";
LIB "presolve.lib";

LIB "arr.lib"; //varNum
LIB "resolve.lib"; //blowUp2
LIB "sing.lib"; // slocus-method only for testing!


proc show_strict_transforms(list L){
	ring r = basering;
	
	int i;
	int sizeL = size(L);
	
	for(i=1; i<=sizeL; i++){
		if(defined(actual_chart)){kill actual_chart;} 
		def actual_chart = L[i];
		setring(actual_chart);
		print(i);
		sprintf("transform IZ: %s ",IZ);
		sprintf("transform IX: %s ",IX);
		sprintf("descending IZ: %s ",descended_IZ);
		if(defined(boundary)){
			sprintf("boundarylist: %s ",boundary);
		}
		if(defined(Center_of_this_chart)){
			sprintf("Center: %s ",Center_of_this_chart);
		}
		if(defined(Centerideal)){
			sprintf("image of center: %s ",Centerideal);
		}
		sprintf("lastmap: %s ",last_map);
		sprintf("totalmap: %s ",total_map);
		print("path:");
		printf("%p",matrix(path));
		if(defined(tower)){
			sprintf("tower: %s ",tower);
		}
		if(defined(MaxIX)){
			sprintf("MaxIX: %s ",MaxIX);
		}
		print("");
	}
	
	setring(r);
	return();
}

proc show_actual_chart(){
	print(i);
	sprintf("transform IZ: %s ",IZ);
	sprintf("transform IX: %s ",IX);
	sprintf("descending IZ: %s ",descended_IZ);
	if(defined(boundary)){
		sprintf("boundarylist: %s ",boundary);
	}
	if(defined(Center_of_this_chart)){
		sprintf("Center: %s ",Center_of_this_chart);
	}
	if(defined(Centerideal)){
		sprintf("Image of center: %s ",Centerideal);
	}
	sprintf("lastmap: %s ",last_map);
	sprintf("totalmap: %s ",total_map);
	sprintf("path:");
	sprintf("%p",matrix(path));
	if(defined(tower)){
		sprintf("tower: %s ",tower);
	}
	if(defined(MaxIX)){
		sprintf("invariante: %s ",string(MaxIX[1]));
		sprintf("MaxIX-locus: %s", MaxIX[2]);
	}
	print("");
	
	
	return();
}

proc print_binomial_cjs(ideal I,int mode){
	link l1 = ":w Testfaelle/binomi_cjs.txt";
	
	list L = binomial_cjs(I,mode);
	ring r = basering;
	
	int i;int j;
	int sizeL = size(L[1]);
	
	
	for(i=1; i<=sizeL; i++){
		
		if(defined(actual_chart)){kill actual_chart;} 
		def actual_chart = L[1][i];
		setring(actual_chart);
		fprintf(l1,"Chartnumber: %s",i);
		fprintf(l1,"transform IZ: %s ",IZ);
		fprintf(l1,"transform IX: %s ",mstd(IX)[2]);
		fprintf(l1,"descending IZ: %s ",descended_IZ);
		if(defined(boundary)){
			if(size(boundary)>0){
				fprintf(l1,"boundarylist: %s ",boundary);
				list oldcomps;
				for(j=1; j<=size(boundary[1][1]);j++){
					if(boundary[1][2][j] < 0){
					oldcomps = oldcomps +list(boundary[1][1][j]);	
					}
				}
				fprintf(l1,"old components: %s ",string(oldcomps));
			}
		}
		if(defined(Center_of_this_chart)){
			fprintf(l1,"Center: %s ",Center_of_this_chart);
		}
		if(defined(Centerideal)){
			fprintf(l1,"image of center: %s ",Centerideal);
		}
		fprintf(l1,"lastmap: %s ",last_map);
		fprintf(l1,"totalmap: %s ",total_map);
		fprintf(l1,"path:");
		fprintf(l1,"%p",matrix(path));
		if(defined(tower)){
			if(size(tower)>0){
				fprintf(l1,"tower: %s ",string(tower));
			}
		}
		if(defined(MaxIX)){
			fprintf(l1,"invariante: %s ",string(MaxIX[1]));
			fprintf(l1,"MaxIX-locus: %s", string(MaxIX[2]));
		}
		fprintf(l1,"");
	}
	
	setring(r);
	
	fprintf(l1,"Number of total charts: %s", sizeL);
	fprintf(l1,"Number of end charts: %s", size(L[2]));
	//fprintf(l1,"runtime: %s", L[3][1]);
	
	return();
}



//little changes from the original one, since the data representation differs a little bit:
proc ResTreeCJS(list re, list #)
"USAGE:  ResTree(L[,name][,mark]);
@*       L = list

@*       name = string
@*       mark = intvec
ASSUME:  - L is the output of 'binomial_cjs'

@*       - write permission in the current directory or in the
@*         directory in which the file with name 'name' resides
@*       - mark intvec of size size(L[2])
@*            mark[i]=0 (default) border of box black
@*            mark[i]=1 border of box red
CREATE:  file 'name.jpg' containing the tree of charts of L
@*       if filename is given
NOTE:    only available on UNIX-type systems and programs
@*       'display' (imagemagick package) and 'dot' (Graphviz package) need to
@*       be in the standard search PATH
RETURN:  nothing, only generating graphics output in separate window
EXAMPLE: not available (for technical reasons)
"
{
//-----------------------------------------------------------------------------
// Initialization and definition of the temporary filename
//-----------------------------------------------------------------------------
  int i,j,dimC,jsave;
  string tempstr;
  def R=basering;

  if(!defined(@rot))
  {
     intvec @rot;
     @rot[size(re)] = 0;
     //@rot[size(re[1])]=0;
  }
  string @filename = "Testfaelle/baum_cjs";
  link eing=":w Testfaelle/baum_cjs";
//----------------------------------------------------------------------------
// writing the input to the program dot into a file
//----------------------------------------------------------------------------
write(eing,"graph G{");
  tempstr="1[shape=box,label=\"chart 1\"];";
  write(eing,tempstr);
  for(i=2;i<=size(re[1]);i++)
  {
     tempstr=string(i)+"[shape=box,label=\"chart " + string(i)
            //+ "\\nE:"+string(simplify(boundary[1],2))
            + " \"";
     if(@rot[i]==1)
     {
        tempstr=tempstr + "color=\"red\"];";
     }
     else
     {
        tempstr=tempstr + "];";
     }
     write(eing,tempstr);
  }
  //for(i=2;i<=size(re[1]);i++)
  for(i=2;i<=size(re);i++)
  {
     def S = re[i];
     //def S=re[1][i];
     setring S;
     j=int(leadcoef(path[1,ncols(path)]));
     if(j!=jsave)
     {
		def T = re[j];
        //def T=re[1][j];
        setring T;
        if(defined(Center_of_this_chart)){
			dimC=dim(std(IZ+Center_of_this_chart));
		} else{
			dimC = dim(std(IZ));
		}
        
        
        setring S;
        kill T;
     }
     setring R;
     kill S;
     if(j!=jsave)
     {
        tempstr=string(j) + "--" + string(i) +"[label=\"d=" + string(dimC)
               + "\"];";
        jsave=j;
     }
     else
     {
       tempstr=string(j) + "--" + string(i) +";";
     }
     write(eing,tempstr);
  }
  write(eing,"}");
  close(eing);
//---------------------------------------------------------------------------
// Create the graphics output using the programs dot and display
//---------------------------------------------------------------------------
  string outfile=@filename + ".jpg";
  if(!find(outfile,"/"))
  {
//--- display needs fully qualified path to file
     outfile=system("getenv","PWD") + "/" + outfile;
  }
  j=system("sh", "dot -Tjpg " + @filename + " -o "+ outfile);
  j=system("sh","display " + outfile + "&");
//---------------------------------------------------------------------------
// Clean up public directories if necessary
//---------------------------------------------------------------------------
  "Currently showing graphics in separate window";
  "Press <Return> to continue";
  pause();
  if(find(@filename,"/tmp/"))
  {
//--- do not leave any garbage in the public directories
    j=system("sh","command rm " + @filename + ".jpg "+ @filename);
  }
  return();
}
/////////////////////////////////////////////////////////////////////////////



// blowUp with parameter in BlowUpB0(...,2) instead of 0:
proc blowUp3(ideal J,ideal C,list #)
"USAGE:  blowUp3(J,C[,W][,E]);
         W,J,C = ideals,
         E     = list
ASSUME:  J  = ideal containing W ( W = 0 if not specified)
@*       C  = ideal containing J
@*       E  = list of smooth hypersurfaces (e.g. exceptional divisors)
NOTE:    W the ideal of the ambient space, C the ideal of the center of
         the blowup and J the ideal of the variety
         Important difference to blowUp2:
         - the ambient space V(W) is blown up and V(J) transformed in it
@*         - V(C) is assumed to be non-singular
COMPUTE: the blowing up of W in C, the exceptional locus, the strict
         transform of J and the blowup map
RETURN:  list, say l, of size at most size(C),

         l[i] is the affine ring corresponding to the i-th chart
         each l[i] contains the ideals
         - aS, ideal of the blownup ambient space
         - sT, ideal of the strict transform
         - eD, ideal of the exceptional divisor
         - bM, ideal corresponding to the blowup map

         l[i] also contains a list BO, which can best be viewed with showBO(BO)
         detailed information on the data type BO can be viewed via the
         command showDataTypes();
EXAMPLE: example blowUp;  shows an example
"
{
  def S=basering;
  ideal W;
  list E;
  ideal abb=maxideal(1);
  intvec v;
  intvec bvec;
  intvec w=-1;
  matrix intE;
  if(size(#)>0)
  {
    if(typeof(#[1])=="ideal")
    {
      W=#[1];
    }
    if(typeof(#[1])=="list")
    {
      E=#[1];
    }
    if(size(#)>1)
    {
      if((typeof(#[2])=="list") && (size(E)==0))
      {
        E=#[2];
      }
      if((typeof(#[2])=="ideal") && (size(W)==0))
      {
        W=#[2];
      }
    }
  }
  list BO=W,J,bvec,E,abb,v,w,intE;
  int locaT;
  export locaT;
  list blow=blowUpBO(BO,C,2);	// the only change  with respect to the original blowUp(.)- method. 
  kill locaT;
  int i;
  for(i=1;i<=size(blow);i++)
  {
     def Q=blow[i];
     setring Q;
     ideal aS=BO[1];
     ideal sT=BO[2];
     ideal eD=BO[4][size(BO[4])];
     ideal bM=BO[5];
     kill lastMap;
     kill thisChart;
     export(aS);
     export(sT);
     export(eD);
     export(bM);
     blow[i]=Q;
     setring S;
     kill Q;
  }
  return(blow);
}
example
{"EXAMPLE:";
   echo = 2;
   ring R=0,(x,y),dp;
   ideal J=x2-y3;
   ideal C=x,y;
   list blow=blowUp3(J,C);
   def Q=blow[1];
   setring Q;
   aS;
   sT;
   eD;
   bM;
}
///////////////////////////////////////////////////////////////////////////////





///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
// Main Method of CJS-Algorithm:
proc binomial_cjs(ideal I,int mode, list #) //mode = 1 strict transform, mode = 2 weak transform, ideal Z describes the ambient space 
"USAGE: binomial_cjs(ideal I, int mode[, ideal Z]); computes the resolution of singularities of I, with cjs
RETURN: list(L list of rings, Endcharts list of rings, runtime)
EXAMPLE : binomial_cjs; shows an example		
"{
	link l1 = ":w Testfaelle/binomi_cjs.txt";

	int runtime = rtimer;
	def r = basering;
	ideal sI = std(I);
	list elimpart_list = elimpart(sI);
	sI = elimpart_list[1]+elimpart_list[3]; //schauen, ob  sich dim(IZ) verändert hat
	ideal IZ = 0;
	
	if(size(#)>0){
		if(typeof(#[1]) == "ideal"){
			IZ = #[1];
		}
	}
	
	export(IZ);				
	list L = init_lists(sI);
	
	int CounterEndCharts = 0;
	list EndCharts = list(); 
	export(EndCharts); //notwendig?
	int i; int j;int k; int l;
	int towersize;
		
	list invariant_new;

	ideal Y_new = 1;
	ideal last_Center;
	ideal last_MaxOrd;
	list ordered_Y_new;
	list tmp_Y; list IX_elimpart_list;
	int n = nvars(basering);

	//update ringtransformation with elimpart_list[5]:
	for(i = 1; i<=n; i++){
		total_map[i] = subst(total_map[i],var(i),elimpart_list[5][i]);
		last_map[i] = subst(last_map[i],var(i),elimpart_list[5][i]);
	}

	if(EqualityOfIdeal(descended_IZ,IX)){return(list(L,L,rtimer-runtime));}	//all charts, endcharts, runtime
	
	list MaxOrdOCalc;
	
	ideal Y = 1;
	for(i=1; i<=size(MaxIX[2]); i++){						//Y = Max(X)
		Y = intersect(Y, MaxIX[2][i][1]);					//glueing irred components together
	}
	
	if(EqualityOfIdeal(Y,IX) == 1){													// Y == X -> endchart
		return(list(L,L,rtimer-runtime));
	}

	if(isEndChart()){ 
		return(list(L,L,rtimer-runtime));
	}

	// in allen Karten bzw den Endkarten von CJS(Y) arbeiten und entsprechend notwendigviele Kopien anhängen!
	list towerRetList = create_tower_of_centers(Y,tower,MaxIX[1],boundary); 
	tower =  towerRetList[1];
	MaxIX[1] =  towerRetList[2];
	boundary = towerRetList[3];
	L = L + CopiesOfCharts(1,mode); 			//automatically blownup
		
		
	for(i = 2; i <= size(L);i++){									// CJS in every chart, loop of all charts
		
		if(defined(actual_chart)){kill actual_chart;} 
		def actual_chart = L[i];
		setring(actual_chart);

		
		if(EqualityOfIdeal(IX,1) == 1){								//obviously an endchart 			
			CounterEndCharts++;
			EndCharts[CounterEndCharts] = actual_chart;
			i++;
			continue;
		}

		//list MaxOrdRetList;
		invariant = MaxIX[1];										// old invariant of the parent chart
		if(size(MaxIX[2]) == 0){
			invariant[1] = delete(invariant[1], size(invariant[1])); 		// delete dummy-variable in invariant[1], in order to be able to store it in the ring 
			MaxIX[1] = invariant;
		}
		ideal last_Center = Centerideal;				
		elimparts_in_IX(i);											

		//if a level of boundarylist is empty 
		if(size(boundary) == 0){
			list boundary = list();
			boundary[1] = list(list(),list());
		}
		if(size(tower)>0){
			for(j=size(boundary)+1;j<=size(tower);j++){
				boundary[j] = list(list(),list());
			}
		}	
		for(j = size(invariant); j> size(tower)+1;j--){
			invariant = delete(invariant,k);
		}
		
	
		list MaxOrdOCalc = MaxOrdArithO(IZ,IX,descended_IZ,boundary[1],i); 
		
		descended_IZ = MaxOrdOCalc[2];
		invariant_new = list();											//overwrite the variable
		invariant_new[1] = MaxOrdOCalc[1][1];							//invariant in this chart
		
		//calculate new invariant in all other charts:
		for(j=2;j<=size(tower); j++){
			invariant_new[j] = MaxOrdArithO(IZ,IX,descended_IZ,boundary[j],i)[1][1]; 
		}
		
		MaxIX[1] = invariant_new;
		list MaxOrdCalculation = MaxOrdOCalc[1];
	
		list tmp_Y = MaxOrdCalculation[2];											//tmp_Y = Y_1 \cup ... \cup Y_r, irred decomp of Y:= MaxOrd(X)
		ideal Y_new = 1;																// in order to compute the union of the irred comp in tmp_Y
		for(j=1; j<=size(tmp_Y); j++){
			Y_new = intersect(Y_new,tmp_Y[j][2]);										// glueing irred components of MaxOrdArithO(...)[2][j][2], intersection of ideals		
		}

		if( invariantHasImproved(invariant[1], invariant_new[1]) == 1){ 
			if(defined(boundaryreturnlist)){
				kill(boundaryreturnlist);
			}
			list boundaryreturnlist = SetAllBoundaryCompOld(invariant, invariant_new,boundary,tower);		// if max ref-order has improved, set all components of the boundary to be old
			boundary = boundaryreturnlist[1];
			
			if(size(boundary)>0){									
				MaxOrdOCalc = MaxOrdArithO(IZ,IX,descended_IZ,boundary[1],i); 			// new calculation neccessary because of changing the set of old components				
				
			}else{
					
			}
			descended_IZ = MaxOrdOCalc[2];
			MaxOrdCalculation = MaxOrdOCalc[1];
			tmp_Y = MaxOrdCalculation[2];	

			MaxIX = list();
			MaxIX[1] = list();
			MaxIX[1][1] = MaxOrdCalculation[1];
			MaxIX[2] = list();
			for(j=1; j<=size(tmp_Y); j++){
				MaxIX[2][j] = list(tmp_Y[j][2],0);
			}
			
			if(isEndChart() == 1){			
				CounterEndCharts++;
				EndCharts[CounterEndCharts] = actual_chart;
				i++;
				continue;
			}else{
				if(defined(tower)){
					kill(tower);
				}
				list tower = list();
				export(tower);
				if(defined(boundary)!= 0){
					if (size(boundary)>0){
						list tmpList = boundary[1];
						boundary = list();
						boundary[1] = tmpList;
					}else{
						boundary = list();
					}
				} else{
					list boundary = list();
				}
				list towerRetList = create_tower_of_centers(IX,tower,invariant_new,boundary); 
				tower =  towerRetList[1];
				MaxIX[1] =  towerRetList[2];
				boundary = towerRetList[3];
				
				if(size(tower) > 0 and isEndChart() == 0){
					ideal Center_of_this_chart = tower [size(tower)] [1][1];
					L = L + CopiesOfCharts(i,mode);
					export(Center_of_this_chart);
				}
			}
		
		}else{	//invariant has not improved
			invariant = invariant_new; 						//possibly number of old components or invariant of an other level of recursion have changed
			MaxIX[1] = invariant_new;

			list boundaryreturnlist = SetAllBoundaryCompOld(invariant, invariant_new,boundary,tower);		// if max ref-order has improved, set all components of the boundary to be old
			boundary = boundaryreturnlist[1];
			invariant = boundaryreturnlist[2];
			MaxIX[1] = invariant;
			tower = boundaryreturnlist[3];

			if(isEndChart()==1){			
				CounterEndCharts++;
				EndCharts[CounterEndCharts] = actual_chart;
				i++;
				continue;
			} 

			ideal last_MaxOrd = 1;
			
			if(size(MaxIX[2]) == 0){							// case: locus of maximal log-ref-order is not defined, only invariant is defined
				MaxIX[2] = list();
				tmp_Y = MaxOrdCalculation[2];
				for(j=1; j<=size(tmp_Y); j++){
					MaxIX[2][j] = list(tmp_Y[j][2],0);
				}
			} else{											//MaxIX[2] is already defined
				for(j = 1; j<= size(MaxIX[2]);j++){
					last_MaxOrd = intersect(last_MaxOrd, MaxIX[2][j][1]);
				}
				
				
				//Maxord has changed?
				if(EqualityOfIdeal(Y_new,last_MaxOrd) == 0){
					for(k=1; k<=size(MaxIX[2]);k++){
						for(l=1; l<= size(tmp_Y); l++){
							if(EqualityOfIdeal(MaxIX[2][k][1], tmp_Y[l][2]) == 1){
								break;
							}
							if(l == size(tmp_Y)){		//MaxOrd component disappeared
								l = l+1;
							}
						}
						if(l > size(tmp_Y)){			//delete disappeared component
							MaxIX[2] = delete(MaxIX[2],k);
							MaxIX[1] = invariant_new;	//notwendig?
							k = k-1;					//start next loop run with same k
						}
					}
					
					//New comp in MaxOrd e.g. V(x,y,z,w) -> V(x,y,z) after old w gets new 
					for(l=1; l<= size(tmp_Y); l++){
						for(k=1; k<=size(MaxIX[2]);k++){
							if(EqualityOfIdeal(MaxIX[2][k][1], tmp_Y[l][2]) == 1){
								break;
							}
							if(k == size(MaxIX[2])){		//MaxOrd component disappeared
								k = k+1;
							}
						}
						if(k > size(MaxIX[2])){			//delete disappeared component
							MaxIX[2][size(MaxIX[2])+1] = list(tmp_Y[l][2],0);
							l = l-1;					//start next loop run with same l
						}
					}
				}		
			}

			if(defined(tower) == 0){												//first CJS-call (first list in centerlist)
				list tower = list();
				export(tower);
				towersize = 0;
			}
			if(size(tower) == 0){
				towersize = 0;
			}	
			if(size(tower)>0){
				towersize = size(tower);
				Y_new = 1;
				for(j=1; j<=size(tower[towersize]); j++){
					tmp_Y[j] = list(0,tower[towersize][j][1]);					// dummy value 0 in order to have the same form as below after a MaxOrdArith-call
					Y_new = intersect(Y_new,tower[towersize][j][1]);			// glueing irred comp					
				}
			}
			
			labeling(tmp_Y,last_Center);
			list ordered_Y_new = OrderByLabel(tmp_Y);							//label shift because list indicees in singular have to start with one instead of zero 
			ideal Y = 1;
			tower[towersize+1] = list();
			
			for(j=1; j<=size(ordered_Y_new); j++){
				if(size(ordered_Y_new[j]) != 0){ 
					for(k=1;k<=size(ordered_Y_new[j]); k++){
						Y = intersect(Y, ordered_Y_new[j][k]);					//glueing irred comp together
						tower[towersize+1][k] = list(ordered_Y_new[j][k],j-1);
					}
					j = size(ordered_Y_new)+1;
					break;
				}	
			}

			list towerRetList = create_tower_of_centers(Y,tower,invariant,boundary);				
			tower =  towerRetList[1];
			MaxIX[1] =  towerRetList[2];
			boundary = towerRetList[3];
				
			if(isEndChart() == 1){			
				CounterEndCharts++;
				EndCharts[CounterEndCharts] = actual_chart;
			}else{
				ideal Center_of_this_chart = tower [size(tower)] [1][1];
				export(Center_of_this_chart);
				L = L + CopiesOfCharts(i,mode);						
			}
		}
			
		kill(actual_chart);
	}
			
	setring(r);
	return(list(L, EndCharts, rtimer-runtime));
}

///////////////////////////////////////////////////////////////////////////////
proc init_lists(ideal I)
"USAGE: init_lists(ideal I); I = <fi> = <x^Ci(x^Ai+-x^Bi)> polynomialIdeal for i>=1 
RETURN: List l:
		L[i] represents the i-th chart of computation on I:
		L[i][1] intvec of powers of fj, with indeces from (j-1)*n+1 to j*n where last power represents the maximum ideal
		L[i][2] list of invariants of the ideal I -> list(1,...,1,maxord(I))
		L[i][3] list of (Center, list of (Y and it's irred components))
		L[i][4] matrix of path of the i-th chart
		L[i][5] IZ such that I is included in IZ //umgebender Raum
		L[i][6] latest transformation of the  variables of the ring
		L[i][7] readable output of the strict transforms
		L[i][8] transformation of ringvariables  // alle zusammen
		
EXAMPLE: example init_lists; shows an example
"{	
	def r = basering;
	int n = nvars(basering);
	int i; int j;
	int minimum;
	
	list boundary = list();
	boundary[1] = list();
	boundary[1][1] = list();
	boundary[1][2] = list();
	
	list MaxOrdArithReturn = list();
	
	ideal total_map = maxideal(1);
	ideal last_map = maxideal(1);

	ideal IX = I;
	if (defined(IZ)){
		ideal descended_IZ = IZ;
	} else{
		descended_IZ = 0;
	}
	list L = list();
	L[1] = r;
	list tower;
	list invariant;
	invariant[1] = list();
	list MaxIX;
	
	//Center calculations
	if(EqualityOfIdeal(0,I) == 0){
		MaxOrdArithReturn = MaxOrdArithO(IZ,IX,descended_IZ,boundary[1],1);
		list MaxOrdCenter = MaxOrdArithReturn[1];
		descended_IZ = MaxOrdArithReturn[2];
	
		invariant[1] = MaxOrdCenter[1];
		MaxIX = list();
		MaxIX[1] = invariant;
		MaxIX[2] = list();
	
		tower = list();
		tower[1] = list();
		for(i=1;i<=size(MaxOrdCenter[2]);i++){
			tower[1][i] = list(MaxOrdCenter[2][i][2],0);
			MaxIX[2][i] = list(MaxOrdCenter[2][i][2],0);
		}
	}								
	
	module path = [0,-1];										//path of the current chart, autoconverted to matrix
	
	export(IX);
	export(descended_IZ);
	export(invariant);
	export(tower);					
	export(MaxIX);
	export(last_map);
	export(total_map);
	export(boundary);
	export(path);
	return(L);
}
example
{ "EXAMPLE:"; echo = 2;
  ring r = integer,(x(1..7)),lp;

}
///////////////////////////////////////////////////////////////////////////////
proc ideal_to_list(ideal I)
"USAGE: ideal_to_list(ideal I); I = <fi> = <x^Ci(x^Ai+-x^Bi)> polynomialIdeal for i>=1 
RETURN: List L:
		L[1] represents the data of I as the chart data in a list L[i]:
		
EXAMPLE: ideal_to_list; shows an example
"{
int n = nvars(basering);
	int i; int j;
	int idealsize = ncols(I);	
	int minimum;	

	list A;list B;list C;		
	
	//init vectors A and B for each polynomial in I:
	for (i = 1; i<= idealsize; i++){
		if (size(I[i])==1){							// I[i] is monomial
			A[i] = 0:n;
			B[i] = -1:n;
			C[i] = leadexp(I[i]);
		} else {									// I[i] is polynomial
			A[i] = leadexp(I[i]);
			B[i] = leadexp(I[i]-lead(I[i]));
			C[i] = 0:n;
		}
	}

	//init vectors Ci for polynomial j in I 
	for(j=1; j<=idealsize; j++) {
		if (size(I[j])!=1){	
			for(i=1; i<= n; i++) {
				minimum = min(A[j][i],B[j][i]);
				C[j][i] = minimum;
				A[j][i] = A[j][i]-minimum;
				B[j][i] = B[j][i]-minimum;
			}
		}
	}
		
	list L;
	L[1] = list(A,B,C);
	return(L);					
}
example
{ "EXAMPLE:"; echo = 2;
  ring r=integer,(x(1..7)),lp;
  poly f = x(1)^2*x(4)-x(3)^3*x(5)^6; 
  poly g = x(1)*(x(7)^10*x(2)^2-x(4)^7*x(7)^12);
  ideal J = ideal(f,g);
  ideal I = ideal(f);
  ideal_to_list(J);
}
///////////////////////////////////////////////////////////////////////////////

proc CopiesOfCharts(int chartnumber,int mode)
"USAGE: CopiesOfCharts(int chartnumber); creates the successor charts with the data after the blowing up
RETURN: retList list of charts

EXAMPLE : CopiesOfCharts; shows an example		
"{
	def r = basering;
	list successor_list = list();
	
	if(size(tower) == 0){return(successor_list);}
			
	int i; int j; int k; int l; int n;
	int lowest_exponent; 
	int flag = 0;
	int Numb_center_components;

	ideal Centerideal = tower [size(tower)] [1][1]; 		//size of last list in Centerlist
	ideal Center_of_this_chart = Centerideal;
	export(Center_of_this_chart);
	
	int boundarysize = size(boundary[1][1]);
	
	int elimpart_flag = 0;
	
	successor_list = blowUp3(ideal(0),Centerideal);
	//set ambient space to A^n in order to not miss a dimension 
	
	Numb_center_components = size(successor_list);
	
	list tmpordlist1;list tmpordlist2;
	list invariant;

	int tmp_n;
	
	//Blowing up each of the data and mapping each of it into new successor ring:
	for(j = 1;j<=Numb_center_components; j++){
		if(defined(newring)){kill newring;}
		if(defined(elimring)){kill elimring;}
		def newring = successor_list[j];
		setring(newring);
		n = nvars(basering);
		tmp_n = n;
		map BlowUpMap = r,bM;
		

		ideal IX = sat(BlowUpMap(IX)+sT,eD[1])[1];			  // +sT since sT have not to be trivial
		export(IX);
		list elimpartlist = elimpart(IX);
		ideal elimvars1 = elimpartlist[1];
		ideal elimvars2 = elimpartlist[2];
		
		ideal tmpvar;
		tmpordlist1 = list();
		tmpordlist2 = list();
		if(EqualToZero(elimvars1) == 0 and EqualToZero(elimvars2) == 0){
			list rlist = ringlist(newring);
			//create varstr for new ring:
			
			for(i=1; i<=n; i++){
				tmpvar = var(rvar(rlist[2][i]));
				if(size(reduce(tmpvar,std(elimvars2))) == 0){
					tmpordlist1[size(tmpordlist1)+1] = rlist[2][i];
				}else{
					tmpordlist2[size(tmpordlist2)+1] = rlist[2][i];
				}
			}
			rlist[2] = tmpordlist1 + tmpordlist2;
			//create ordstr for new ring:
			rlist[3][1] = list("lp",1:size(elimvars2));
			rlist[3][2] = list("dp",1:(tmp_n-size(elimvars2)));
			
			
			elimpart_flag = 1;
			map elimmap = newring,elimpartlist[5];
			ideal bM_new = elimmap(bM);
			ideal eD_new = elimmap(eD);
			ideal sT_new = elimmap(sT);
			def elimring = ring(rlist);
			setring(elimring);
	
			ideal IX = imap(newring,IX);
			export(IX);
			list elimpartlist = imap(newring,elimpartlist);
			ideal bM = imap(newring,bM_new);
			ideal eD = imap(newring,eD_new);
			ideal sT = imap(newring,sT_new);
		}
		
		map BlowUpMap = r,bM;
		i = 1;

		ideal Centerideal = BlowUpMap(Centerideal);
		n = nvars(basering);

		ideal IZ = sat(BlowUpMap(IZ)+sT,eD[1])[1];

		ideal descended_IZ;

		
		if(mode == 1){
			IX = std(IX);
			if(elimpart_flag == 0){
				descended_IZ = IZ;

			}else{
				descended_IZ = IZ;
			}
		}
		if(mode == 2){
			ideal IX = BlowUpMap(IX);	
			
			lowest_exponent = gcd_of_polynomial_and_variable(IX[1],eD[1])[2];	
			for(k=1; k<=size(IX); k++){
				if(lowest_exponent > gcd_of_polynomial_and_variable(IX[k],eD[1])[2] ){
					lowest_exponent = gcd_of_polynomial_and_variable(IX[k],eD[1])[2];	
				}
			}
			
			IX = quotient(IX,eD[1]^lowest_exponent);								// analog to sat
					
			ideal descended_IZ = BlowUpMap(descended_IZ);
			lowest_exponent = gcd_of_polynomial_and_variable(descended_IZ[1],eD[1])[2];	
			for(k=1; k<=size(descended_IZ); k++){
				if(lowest_exponent > gcd_of_polynomial_and_variable(descended_IZ[k],eD[1])[2] ){
					lowest_exponent = gcd_of_polynomial_and_variable(descended_IZ[k],eD[1])[2];	
				}
			}
			descended_IZ = quotient(descended_IZ,eD[1]^lowest_exponent);
		}
		
	

		poly tmp_poly;
		ideal tmp_ideal;
		
		list MaxIX = BlowUpMap(MaxIX);	
		invariant = MaxIX[1];
		for(l=1; l<= size(MaxIX[2]); l++ ){			//outer center has other calculation rules and inner center is going to be deleted		
			tmp_ideal = 1;
			for(i = 1; i<= size(MaxIX[2][l][1]); i++){
				MaxIX[2][l][1] = sat(MaxIX[2][l][1],eD[1])[1];
			}
			tmp_ideal = intersect(tmp_ideal, MaxIX[2][l][1]);
			if(EqualityOfIdeal(tmp_ideal,1) == 1){
				MaxIX[2] = delete(MaxIX[2], l);
				MaxIX[1] = invariant;
				//continue;							//in order to start next loop with the same i
				l = l-1;
			}
		}

		if(size(MaxIX[2]) == 0){
			MaxIX[1][1] = MaxIX[1][1] + list(var(1));				// dummy-variable in order to store invariant in the ring/chart
		}
		


		ideal last_map = bM;
		ideal total_map = BlowUpMap(total_map);
		def path = imap(r,path);

		export(IZ);
		export(descended_IZ);
		export(MaxIX);
		export(Centerideal);
		path=path,[chartnumber,j];
		export(path);
				
		
		list tower = BlowUpMap(tower);
		//check whether tower components gets empty
		int towersize = size(tower);
		
			if(EqualityOfIdeal(eD,1) == 0){

				for(k=1; k<= size(tower)-1; k++ ){			//outer center has other calculation rules and inner center is going to be deleted		
					tmp_ideal = 1;
					for(l = 1; l<= size(tower[k]); l++){
						for(i = 1; i<= size(tower[k][l][1]); i++){
							//tmp_poly = tower[k][l][1][i];
							//tower[k][l][1][i] = tmp_poly / gcd_of_polynomial_and_variable(tmp_poly,eD[1])[1];
							tower[k][l][1] = sat(tower[k][l][1], eD[1])[1];
						}
						tmp_ideal = tower[k][l][1];
					
						if(EqualityOfIdeal(tmp_ideal,1) == 1){
							tower[k] = delete(tower[k],l);
							continue;							//in order to start next loop with the same i
						}
					}
					if(size(tower[k]) == 0){
						tower = delete(tower,k);
						continue;
					}
				}
				tower = delete(tower,size(tower));		//remove the innerst center of centerlist 

			} else{
				tower = list();
			}	
		
		//delete last tower component
		export(tower);

		
		if(boundarysize == 0){
			list boundary = list();
			boundary[1] = list(list(),list());
			
		} else{
			list boundary = BlowUpMap(boundary);
			for(l=1;l<=size(boundary);l++){
				//quotient with the exc div for the strict transform:
				for(i=1; i<= size(boundary[l][1]); i++){			// delete duplicates e.g. by elimpart-map //only for beautyful output
					boundary[l][1][i] = minAssZ(boundary[l][1][i])[1];
					boundary[l][1][i] = sat(ideal(boundary[l][1][i]),eD[1])[1];
				}
			}
		}


		//change boundary:
		for(l = 1; l<=size(boundary); l++){
			for(k = 1; k<= size(boundary[l][1]); k++){
				//check whether component gets empty:
				if(EqualityOfIdeal(boundary[l][1][k],1)){
					boundary[l][1] = delete(boundary[l][1],k);
					boundary[l][2] = delete(boundary[l][2],k);
					continue;
				}
				//if not empty:
				if(boundary[l][2][k] == 2){					//resetting last boundary component
					boundary[l][2][k] = 1;
				}
				if(boundary[l][2][k] == -2){
					boundary[l][2][k] = -1;
				}
				if(EqualityOfIdeal(boundary[l][1][k], eD[1]) == 1){	//find exceptional divisor in boundary components
					boundary[l][2][k] = 2;
					flag = 1;
				}
			}
		
			if(flag == 0){ 									// new boundary component
				boundary[l][1][size(boundary[l][1])+1] = minAssZ(eD[1])[1]; 			//add exceptionel divisor to the boundary
				boundary[l][2][size(boundary[l][2])+1] = 2;
			}
		}
		
		export(boundary);
		export(last_map);
		export(total_map);
		
		if(!defined(elimring)){
			successor_list[j] = newring;
		}else{
			successor_list[j] = elimring;	
		}	
		setring(r);
		
	}
	
	if(defined(newring)){kill newring;}
	if(defined(elimring)){kill elimring;}
	
	return(successor_list);
}
///////////////////////////////////////////////////////////////////////////////
proc gcd_of_polynomial_and_variable(poly f, poly x)
"USAGE: find_highest_exponent_in_polynomial(poly f, poly x); calculates the gcd of a ring variable x and a polynomial f
RETURN: list of the gdc and the exponent of x in the gcd

EXAMPLE : gcd_of_polynomial_and_variable; shows an example		
"{
	int i = 1;
	
	if(f/x == 0) {return(list(1,0));}
																//alternativ sooft x rausteilen, wie hoch die ordnung ist
	poly poly_with_highest_exponent = x; 
	while(f/poly_with_highest_exponent!=0 ){					//einzelne erzeuger prüfen ob ungleich 1
		poly_with_highest_exponent = poly_with_highest_exponent * x;
		i++;
	}
	i = i-1;
	poly_with_highest_exponent = poly_with_highest_exponent / x;
	return(list(poly_with_highest_exponent,i));
}



///////////////////////////////////////////////////////////////////////////////
proc elimparts_in_IX(list #)//should be superfluous
"USAGE: simplify the generators of the ideal IX in order to make it checkable whether it is singular or nor
RETURN: list L, with changed values in list(A,B,C), in the components of Max(X) and in the ringtransformation

EXAMPLE : elimparts_in_IX; shows an example		
"{
	int n = nvars(basering);
	if(size(#)>0){int chartnumber = #[1];}	
	int idealsize = size(IX);
	int i;int j; int k; int l;int m;
	int hasChanged = 0;

	list IX_elimpart_list;	
	ideal tmp_Center;
	
	poly substpoly;

	IX_elimpart_list = elimpart(IX);
	ideal tmp_IX = IX_elimpart_list[1] + IX_elimpart_list[3];
	ideal elimtransformation = IX_elimpart_list[5]; 

	int idealsize_new = size(tmp_IX);
	list MaxOrdOCalc; list MaxOrdCalculation;
	
	if(size(MaxIX)>0){
		list invariant  = MaxIX[1];
	}else{
		list invariant = MaxOrdArithO(IZ,IX,descended_IZ,boundary[1],chartnumber)[1];
	}
	
	int tmp_flag = 0;

	if(idealsize == idealsize_new){
		for(i=1; i<= idealsize; i++){
			tmp_flag = 0;
			for(j=1; j<=idealsize_new; j++){
				if(EqualityOfIdeal(IX[1],tmp_IX[j]) == 1){
					tmp_flag = 1;
				}
			}
			if(tmp_flag == 0){
				hasChanged = 1;
			}
		}
	} else{
		hasChanged = 1;
	}	

	if(hasChanged == 0){				//nothing to do
		return();						
	}
	
	ideal tmp_last_map = last_map;
	ideal tmp_total_map = total_map;
	list tmp_boundary = boundary;
	
	for(i = 1; i<=n; i++){
		if(i<= size(last_map)){
			last_map[i] = subst(tmp_last_map[i],var(i),elimtransformation[i]);
		}
		if(i<= size(total_map)){
			total_map[i] = subst(tmp_total_map[i],var(i),elimtransformation[i]);
		}
		
		if(EqualityOfIdeal(elimtransformation[i],1) == 0){
		
			for(j=1; j<= size(tmp_boundary[1]) ; j++){
				for(k = 1; k<=size(tmp_boundary[1]);k++){
					if(EqualityOfIdeal(boundary[1][j], var(i)) == 1  and EqualityOfIdeal(boundary[1][k], minAssZ(elimtransformation[i])[1] ) == 1 ){
						boundary[1][j] = minAssZ(subst(tmp_boundary[1][j],var(i),elimtransformation[i]))[1];
						boundary[2][j] = tmp_boundary[2][k];
					}
				}
			}
		}
		if(elimtransformation[i] != 0){
			//updating centerlist
			for(k = 1;k<=size(tower); k++){
				for(l=1; l<=size(tower[k]); l++){
					tmp_Center = 1;
					for(m=1; m<=size(tower[k][l][1]); m++){
						substpoly = subst(tower[k][l][1][m], var(i), elimtransformation[i]);			//substitute ideal in centerlist 
						if(substpoly != 0){
							tower[k][l][1][m] = substpoly;
						}
						tmp_Center = tmp_Center * tower[k][l][1][m];
					}
				
					//checks whether tower[k][l][1] is empty:
					if(EqualityOfIdeal(tmp_Center, 1) == 1){
						tower[k] = delete(tower[k],l);
						continue;	
					}
				}	
			}
			
			//updating MaxIX
			for(l=1; l<=size(MaxIX[2]); l++){
				tmp_Center = 1;
				for(m=1; m<=size(MaxIX[2][l][1]); m++){
					substpoly = subst(MaxIX[2][l][1][m], var(i), elimtransformation[i]);			//substitute ideal in centerlist 
					if(substpoly != 0){
						MaxIX[2][l][1][m] = substpoly;
					}
					tmp_Center = tmp_Center * MaxIX[2][l][1][m];
				}
				
				//checks whether tower[k][l][1] is empty:
				if(EqualityOfIdeal(tmp_Center, 1) == 1){
					MaxIX[2] = delete(MaxIX[2],l);
					MaxIX[1] = invariant;
					continue;
				}
			}	
		}
	}
		
	//updating MaxIX
	if(EqualityOfIdeal(IX,1) == 1){
		MaxIX[1] = list();
		for(i=1; i<=size(IZ+1); i++){
			MaxIX[1] = MaxIX[1] + list(1);
		}
	} else{
		if(size(MaxIX[2]) == 0){
			MaxOrdOCalc = MaxOrdArithO(IZ,IX,descended_IZ,boundary[1],chartnumber); 					
			MaxOrdCalculation = MaxOrdOCalc[1];
			MaxIX = list();
			MaxIX[1] = MaxOrdCalculation[1];
			MaxIX[2] = list();
	
			for(i = 1; i<=size(MaxOrdCalculation[2]); i++){
				MaxIX[1][i] = list(MaxOrdCalculation[2][i][2],0);
			}	
			descended_IZ = MaxOrdOCalc[2];
		}
	}
	return();
}





///////////////////////////////////////////////////////////////////////////////
proc labeling(list Y_new, ideal last_Center)
"USAGE: labeling(list L); calculates the labels of the irred components of Y_new
RETURN: list of irred components of Y_new with new labels and updated MaxOrd component L[i][2][2]

EXAMPLE : labeling; shows an example		
"{
	int i; 	int j; int k = 0; int flag;
	int n = nvars(basering);
	int maxlabel = ncols(path);				//number to high //only for cosmetical reasons

	ideal lastMaxOrdIdeal;
	int oldLabel;
	
	ideal excdiv_var; 					
	ideal tmp_center = std(last_Center); 	//should be the exc. divisor 
	
	for(i=1; i<=size(last_Center);i++){
		if(EqualityOfIdeal(last_Center[i],tmp_center[1]) == 0){
			last_Center[i] = last_Center[i] / tmp_center[1];
		}
	}
	
	if(size(MaxIX) == 2){
		for(i = 1; i<= size(MaxIX[2]);i++){
			lastMaxOrdIdeal = MaxIX[2][i][1];
			if(EqualityOfIdeal(lastMaxOrdIdeal,last_Center)){
				k = MaxIX[2][i][2];
			}
		}
	}

	for(i = 1; i<= size(boundary[1][1]); i++){
		if(boundary[1][2][i] == 2 or boundary[1][2][i] == -2){
			excdiv_var  = boundary[1][1][i];							//read last exc_div 
		}
	}

	if(size(MaxIX) == 2){
		for(j = 1; j<= size(MaxIX[2]); j++){
			if(size(reduce(excdiv_var,std(MaxIX[2][j][1]))) == 0){			// component of MaxOrd contained in exz div 
				if(size(reduce(  std(last_Center),std(MaxIX[2][j][1]) )) != 0 ){ // not dominating
					MaxIX[2][j][2] = maxlabel;
				}
			}
		}
	}

	if(size(tower) >= 1){
		for(j = 1; j<= size(tower[1]); j++){
			if(size(reduce(excdiv_var,std(tower[1][j][1]))) == 0){			// component of MaxOrd contained in exz div 
				if(size(reduce(  std(last_Center),std(tower[1][j][1])  )) != 0 ){ // not dominating
					tower[1][j][2] = maxlabel;
				}
			}
		}
	}

	return();
}

///////////////////////////////////////////////////////////////////////////////
proc OrderByLabel(list Y_new){			//creates an index shift in the label because of lists dont are allowed to have entries at index zero
	list ordered_list = list();
	int i; int j; int towersize = size(tower);
	ideal tmp_ideal;

	int maxlabel = ncols(path)+1;

	for(i=1; i<=maxlabel; i++){
		ordered_list[i] = list();			//otherwise it throws an exception in upper method, if ordered_list[i] does not exist
	}
	if(towersize==0 and size(MaxIX[2]) > 0){			
		for(i=1;i<=size(Y_new);i++){	
			for(j=1; j<=size(MaxIX[2]); j++){
				if(EqualityOfIdeal(Y_new[i][2],MaxIX[2][j][1])==1){
					ordered_list[MaxIX[2][j][2]+1][size(ordered_list[MaxIX[2][j][2]+1])+1] = Y_new[i][2];
				}
			}	
		}
	}else{
		for(i=1;i<=size(Y_new);i++){
			for(j=1; j<=size(tower[towersize]); j++){
				if(EqualityOfIdeal(Y_new[i][2],tower[towersize][j][1])==1){
					ordered_list[tower[towersize][j][2]+1][size(ordered_list[tower[towersize][j][2]+1])+1] = Y_new[i][2];
				}
			}	
		}
	}
	return(ordered_list);
}
///////////////////////////////////////////////////////////////////////////////
proc create_tower_of_centers(ideal Y,list tower, list invariant, list boundary)
"USAGE: create_tower_of_centers(list L, ideal Y); chart L and Y describes the locus of maximal order and MaxOrdComp describes 
 inserts a tower of CJS-Centers
RETURN: inputlist with changes at L[3]; there will be a list of nested CJS-Centers

EXAMPLE : 		
"{

	int i;int j; int k;
	ideal Y_old = 1;
	int sizeTower = size(tower);
	int flag = 0;														//flag whether we get in the while-loop or not, because of deleting last entry only in case of entering while-loop
	list MaxOrdCalculation;
	
	if(sizeTower > 0){
		for(i=1; i<=size(tower[sizeTower]); i++){						//innerst Center of Centerlist
			Y_old = intersect(Y_old, tower[sizeTower][i][1]);
		}	
	}

	ideal Y_new = 1;
	
	if(sizeTower > 0){
		for(i=size(boundary); i<=sizeTower;i++){
			if(i<sizeTower){
				boundary[i] = list();
				boundary[i] = list(list(),list());
			}
			if(i == sizeTower && size(boundary) < sizeTower){
				boundary[i] = list();
				boundary[i] = list(list(),list());			
			}
		}
	
		boundary[sizeTower+1] = list();
		boundary[sizeTower+1] = list(list(),list());

		if(size(boundary[sizeTower])> 0){
			for(i=1; i<=size(boundary[sizeTower][1]); i++){							// copy new boundary components in the boundary of the deeper recursion
				if(boundary[sizeTower][2][i] > 0){
					boundary[sizeTower+1][1][size(boundary[sizeTower+1][1])+1] = boundary[sizeTower][1][i];
					boundary[sizeTower+1][2][size(boundary[sizeTower+1][2])+1] = boundary[sizeTower][2][i];
				}
			}
		} else{
				boundary[sizeTower+1]= list();
				boundary[sizeTower+1] = list(list(),list());	
		}
		
	} 
	if(size(boundary)>0){
		MaxOrdCalculation = MaxOrdArithO(IZ,Y,IZ,boundary[sizeTower+1])[1];	// descended_IZ oder IZ ???
	}else{
		boundary[1] = list(list(),list());
		MaxOrdCalculation = MaxOrdArithO(IZ,Y,IZ,boundary[1])[1];				// descended_IZ oder IZ ???
	}

	j = size(tower)+1;
	tower[j] = list();
	for(i=1; i<=size(MaxOrdCalculation[2]); i++){						//Y = Max(X)
		Y_new = intersect(Y_new, MaxOrdCalculation[2][i][2]);
		tower[j][i] = list(MaxOrdCalculation[2][i][2] , 0);
	}
	
	//no new tower element:
	if(EqualityOfIdeal(Y,Y_new) == 1){									// delete duplicated values
		tower = delete(tower,size(tower));
		boundary = delete(boundary,size(boundary));
		if(j>1){
			for(i = 1; i<=size(tower[j-1]);i++){
				for(k=1; k<= size(MaxIX[2]); k++){
					if(EqualityOfIdeal(tower[j-1][i][1], MaxIX[2][k][1]) == 1){
						tower[j-1][i][2] = std(MaxIX[2][k][2]);			// copy label from MaxOrd 
					}
				}
			}
		}else{															// tower is empty
			return(tower,invariant,boundary);
		}
	} else{
		invariant[j] = MaxOrdArithO(IZ,Y,IZ,boundary[j])[1][1];			// invariant of Y_(j-1) in the j-th level of recursion
	}
	
	while(EqualityOfIdeal(Y,Y_new) == 0){
		flag = 1;
		Y = Y_new;
		j = size(tower)+1;
		
		boundary[j] = list(list(),list());
		for(i=1; i<=size(boundary[j-1][1]); i++){							// copy new boundary components in the boundary of the deeper recursion
			if(boundary[j-1][2][i] > 0){
				boundary[j][1][size(boundary[j][1])+1] = boundary[j-1][1][i];
				boundary[j][1][size(boundary[j][2])+1] = boundary[j-1][2][i];
			}
		}
		MaxOrdCalculation = MaxOrdArithO(IZ,Y,IZ,boundary[j])[1];
		invariant[j] = MaxOrdCalculation[1];									// invariant of Y_(j-1) in the j-th level of recursion
		Y_new = 1;
		tower[j] = list();
		for(i=1; i<=size(MaxOrdCalculation[2]); i++){						//Y = Max(X)
			Y_new = intersect(Y_new,MaxOrdCalculation[2][i][2]);
			tower[j][i] = list(MaxOrdCalculation[2][i][2] ,0);
		}
	}
	//last MaxOrdCalculation was superfluous -> remove last Center
	if(size(tower)>1 && flag == 1){
		tower = delete(tower,size(tower));
		invariant = delete(invariant,size(invariant));
		boundary = delete(boundary,size(boundary));
	}	
	return(tower, invariant, boundary);
}
///////////////////////////////////////////////////////////////////////////////

proc SetAllBoundaryCompOld(list invariant, list invariant_new, list boundary, list tower){
	int i; int j; int k; int n;
	int improved;
	int logimproved;

	
	for(j = 1; j<= size(invariant); j++){
		improved = 0;
		logimproved = 0;
		
		n = size(boundary[j][1]);
		//only set all boundary components to be old, if refined order and not only log-refined order improves
		if(size(invariant_new[j]) > size(invariant[j])){			//(1,...,1,maxord,|O|) has more one entries only if number of ones increases
			improved = 1;
			logimproved = 1;
		}
		for(i=1; i<=size(invariant[j]);i++){					// lexicographical comparison for all but the last entry, since considering refined order
			if(invariant[j][i] > invariant_new[j][i]){
				logimproved = 1;
				if(i< size(invariant[j])){
					improved = 1;
				}
			}
		}

		if(improved == 1){										//Set all boundary components to be old
			for(i=1; i<=n; i++){
				if(boundary[j][2][i] > 0){
					boundary[j][2][i] = boundary[j][2][i] * (-1);
				}
			}
			invariant_new[j][size(invariant_new)] = size(boundary[j][1]);
			//+ reset labeling of this tower level
			for(k=size(invariant_new); k>=j;k--){
				if(size(tower)>=k){
					tower = delete(tower,k);
				}
				if(j< k){
					if(size(boundary)>=k){
						boundary = delete(boundary,k);
					}
					if(size(invariant_new)>=k){
						invariant_new = delete(invariant_new,k);
					}
				}
			}
		} else{
			if(logimproved == 1){
				//reset tower of this level and below
				//all levels below are deleted, since log-invariant has improved
				for(k=size(invariant_new); k>=j;k--){
					if(size(tower)>=k){
						tower = delete(tower,k);
					}
					if(j < k){
						if(size(boundary)>=k){
							boundary = delete(boundary,k);
						}
						if(size(invariant_new)>=k){
							invariant_new = delete(invariant_new,k);
						}
					}
				}
			} // tower below this is calculated later in the main algorithm in case that the upperst invariant has not improved
			//otherwise this is not possible that we need labels
		}
	}
	
	return(list(boundary,invariant_new,tower));
}
///////////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////
proc MaxOrdArithO(ideal IZ, ideal IX, ideal descended_IZ, list boundary, list #)
"USAGE: MaxOrdArithO(ideal descended_IZ, ideal IX,list L); IZ and IX like in MaxOrdArith and L for the actual chart of the blowing up 
RETURN: locus of maximal order intersected with the global old components of the Boundary:
		
EXAMPLE: example MaxOrdArithO; shows an example
"{	

	int sizeIX = size(IX);
	ideal OldComps = 0;
	int i; int j; int k;
	int n = nvars(basering);
	
	
	list MaxOrdCalculation; list minAsslist;
	int maxord;
	ideal MaxOrdIdeal;
	list elimpartmaxordlist;
	//list MaxOrdRetList;
	
	//ideal descended_IZ = IZ;			
	int descending_counter;
	int flag = 0;
	ideal oldcomponent;
	list invariant;

	if(defined(boundary)){
		if(size(boundary[1]) > 0){
			for(i=1; i<= size(boundary[2]); i++){
				if(boundary[2][i] < 0){
					oldcomponent = boundary[1][i];
					if(size(ideal(matrix(reduce(IX,std(oldcomponent)))-matrix(IX)))==0){ // only consider old components which are still in the transform
						i++;
						continue;
					}
					if(EqualityOfIdeal(IX+boundary[1][i],1) == 1){	// only consider olc components which intersection with the transform is not empty
						i++;
						continue;
					}
					OldComps = OldComps + oldcomponent;
				}
			}
		}
	}
	
	if(size(#)>=1){
		if(typeof(#[1])== "int"){
			int chartnumber = #[1]; 
		} if(typeof(#[1])=="list"){
			list MaxOrdRetList = #[1];
		}
		if(size(#)>=2){
			if(typeof(#[2])== "int"){
				int chartnumber = #[2]; 
			} if(typeof(#[2])=="list"){
				list MaxOrdRetList = #[2];
			}	
		}
	}
	
	IX = std(IX);

	if(EqualityOfIdeal(descended_IZ,IX) == 0 and size(reduce(descended_IZ,IX,1)) == 0){			//neither IZ = IX nor IX subset IZ
		//MaxOrdCalculation = MaxOrdArith(descended_IZ,IX,0,MaxOrdRetList);
		MaxOrdCalculation = MaxOrdArith(descended_IZ,IX,0);
	//	MaxOrdRetList = MaxOrdCalculation[2];
		maxord = MaxOrdCalculation[1];
	} else{
		MaxOrdCalculation = list();
		MaxOrdCalculation[2] = list();
		MaxOrdCalculation[2][1] = list();
		MaxOrdCalculation[2][1][1] = 0;
		MaxOrdCalculation[2][1][2] = IX;
		maxord = 1;


		//if(EqualityOfIdeal(IZ,IX) == 1){
		//	MaxOrdCalculation[2][1][2] = OldComps;
		//	MaxOrdIdeal = OldComps;
		//}else{
		//minimize old elements
			MaxOrdIdeal = 1;
			for(j=1; j<=size(OldComps); j++){
				for(i = 1; i<= size(MaxOrdCalculation[2]);i++){
					if(EqualityOfIdeal(MaxOrdCalculation[2][i][2]+OldComps[j],1) == 1){
						OldComps = delete(OldComps,j);
						j--;
						i=size(MaxOrdCalculation[2]); 			//leaving innerst for-loop
					}
				}
			}
		
			//intersect Max-v with old boundary components
			for(i=1; i<=size(MaxOrdCalculation[2]); i++){
				elimpartmaxordlist = elimpart(MaxOrdCalculation[2][i][2] + OldComps);
				MaxOrdCalculation[2][i][2] = (elimpartmaxordlist[1]+elimpartmaxordlist[3]);
				MaxOrdIdeal = intersect(MaxOrdIdeal, MaxOrdCalculation[2][i][2]); 
			}
		
			// V(x,y) cup V(x,y,z) possible, if y old component and MaxOrd(IX) = V(x,y) cup V(x,z):
			//-> compute minAssZ
		
			minAsslist = minAssZ(MaxOrdIdeal);

			for(i=1; i<=size(minAsslist); i++){
				if(size(MaxOrdCalculation[2]) < i){
					MaxOrdCalculation[2][i] = list();
					MaxOrdCalculation[2][i][1] = 0;
				}
				MaxOrdCalculation[2][i][2] = minAsslist[i]; 
			}
			for(i = size(minAsslist)+1; i<= size(MaxOrdCalculation[2]); i++){
				MaxOrdCalculation[2] = delete(MaxOrdCalculation[2],i); 
			}
		//}
		//calculting invariant:
		descending_counter = size(descended_IZ) - size(IZ);
		for(i=1; i<=descending_counter; i++){
			invariant = invariant + list(1);
		}
		invariant[size(invariant)+1] = maxord;
		invariant[size(invariant)+1] = size(OldComps);
		MaxOrdCalculation[1] = invariant;
		return(list(MaxOrdCalculation,descended_IZ));
	}
	
	
	
	if(maxord == 0){
		maxord = 1;
	}
	if(size(MaxOrdCalculation[2]) > 0){
		if(maxord == 1){
			list descended_IZcomps = list();
			// only one irred. component of MaxOrdArith possible in case of one input binomial
			if(sizeIX==1){
				descended_IZ = IX;
			}else{	//calculate max-v(X) 					

				if(EqualityOfIdeal(descended_IZ,IX) == 0){
					//for minimizing Equality...-calls
					for(i=1;i<=size(IX);i++){
						if(EqualityOfIdeal(descended_IZ,descended_IZ+IX[i])==0){
							if(maxordgreaterthanlimit(descended_IZ,descended_IZ+IX[i],1) == 0){
								descended_IZ = std(descended_IZ +IX[i]);
								descended_IZcomps[size(descended_IZcomps)+1] = i;								
								if(EqualityOfIdeal(descended_IZ,IX) == 1){
									break;
								}
								if(maxordgreaterthanlimit(descended_IZ,IX,1)==1){
									break;
								}
							}
						}
					}
				}
				
				//overwrite MaxOrdCalculation:
				if(EqualityOfIdeal(descended_IZ,IX) == 0 and size(reduce(descended_IZ,IX,1)) == 0){
					//MaxOrdCalculation = MaxOrdArith(descended_IZ,IX,0,MaxOrdRetList);
					MaxOrdCalculation = MaxOrdArith(descended_IZ,IX,0);
					maxord = MaxOrdCalculation[1];
					//MaxOrdRetList = MaxOrdCalculation[2];

				} else{
					MaxOrdCalculation = list();
					MaxOrdCalculation[2] = list();
					MaxOrdCalculation[2][1] = list();
					MaxOrdCalculation[2][1][1] = 0;
					MaxOrdCalculation[2][1][2] = IX;
					
					//intersect Max-v with old boundary components
					MaxOrdIdeal = 1;
					for(j=1; j<=size(OldComps); j++){
						for(i = 1; i<= size(MaxOrdCalculation[2]);i++){
							if(EqualityOfIdeal(MaxOrdCalculation[2][i][2]+OldComps[j],1) == 1){
								OldComps = delete(OldComps,j);
								j--;
								i=size(MaxOrdCalculation[2]); 			//leaving innerst for-loop
							}
						}
					}
					for(i=1; i<=size(MaxOrdCalculation[2]); i++){
						elimpartmaxordlist = elimpart(MaxOrdCalculation[2][i][2] + OldComps);
						MaxOrdCalculation[2][i][2] = (elimpartmaxordlist[1]+elimpartmaxordlist[3]);
						MaxOrdIdeal = intersect(MaxOrdIdeal, MaxOrdCalculation[2][i][2]); 	//intersect
					}
					// V(x,y) cup V(x,y,z) possible, if y old component and MaxOrd(IX) = V(x,y) cup V(x,z):
					//-> compute minAssZ
		
					minAsslist = minAssZ(MaxOrdIdeal);
					for(i=1; i<=size(minAsslist); i++){
						if(size(MaxOrdCalculation[2]) < i){
							MaxOrdCalculation[2][i] = list();
							MaxOrdCalculation[2][i][1] = 0;
						}
						MaxOrdCalculation[2][i][2] = minAsslist[i]; 
					}
					for(i = size(minAsslist)+1; i<= size(MaxOrdCalculation[2]); i++){
						MaxOrdCalculation[2] = delete(MaxOrdCalculation[2],i); 
					}
					//calculting invariant:
					descending_counter = size(descended_IZ) - size(IZ);
					for(i=1; i<=descending_counter; i++){ 	// only count the number of descents
						invariant = invariant + list(1);
					}
					invariant[size(invariant)+1] = maxord;
					invariant[size(invariant)+1] = size(OldComps);
					MaxOrdCalculation[1] = invariant;
					return(list(MaxOrdCalculation,descended_IZ));
				}
			}
		}
	
		//intersect Max-v with old boundary components
		MaxOrdIdeal = 1;
		for(j=1; j<=size(OldComps); j++){
			for(i = 1; i<= size(MaxOrdCalculation[2]);i++){
				if(EqualityOfIdeal(MaxOrdCalculation[2][i][2]+OldComps[j],1) == 1){
					OldComps = delete(OldComps,j);
					j--;
					i=size(MaxOrdCalculation[2]); 			//leaving innerst for-loop
				}
			}
		}
		for(i=1; i<=size(MaxOrdCalculation[2]); i++){
			elimpartmaxordlist = elimpart(MaxOrdCalculation[2][i][2] + OldComps);
			MaxOrdCalculation[2][i][2] = (elimpartmaxordlist[1]+elimpartmaxordlist[3]);
			MaxOrdIdeal = intersect(MaxOrdIdeal, MaxOrdCalculation[2][i][2]); 
		}
		// V(x,y) cup V(x,y,z) possible, if y old component and MaxOrd(IX) = V(x,y) cup V(x,z):
		//-> compute minAssZ
		if(EqualityOfIdeal(MaxOrdIdeal,1) == 0){
			minAsslist = minAssZ(MaxOrdIdeal);
			for(i=1; i<=size(minAsslist); i++){
				if(size(MaxOrdCalculation[2]) < i){
					MaxOrdCalculation[2][i] = list();
					MaxOrdCalculation[2][i][1] = 0;
				}
				MaxOrdCalculation[2][i][2] = minAsslist[i]; 
			}
			for( i = size(minAsslist)+1; i<= size(MaxOrdCalculation[2]); i++){
				MaxOrdCalculation[2] = delete(MaxOrdCalculation[2],i); 
			}
		}else{
			MaxOrdCalculation = list();
			MaxOrdCalculation[2] = list();
			MaxOrdCalculation[2][1] = list();
			MaxOrdCalculation[2][1][1] = 0;
			MaxOrdCalculation[2][1][2] = 1;
		}
	}else{
		MaxOrdCalculation = list();
		MaxOrdCalculation[2] = list();
		MaxOrdCalculation[2][1] = list();
		MaxOrdCalculation[2][1][1] = 0;
		if(size(OldComps)>0){
			MaxOrdCalculation[2][1][2] = OldComps;
		}else{
			MaxOrdCalculation[2][1][2] = IX;
		}
	}
	
	
	//calculating invariant:
	descending_counter = size(descended_IZ) - size(IZ);
	for(i=1; i<=descending_counter; i++){
		invariant = invariant + list(1);
	}
	invariant[size(invariant)+1] = maxord;
	if(EqualityOfIdeal(MaxOrdCalculation[2][1][2],1) == 0){
		invariant[size(invariant)+1] = size(OldComps);
	} else{
		invariant[size(invariant)+1] = 0;
	}
	MaxOrdCalculation[1] = invariant;
	
	//return(list(MaxOrdCalculation,descended_IZ,MaxOrdRetList));
	return(list(MaxOrdCalculation,descended_IZ));
}


///////////////////////////////////////////////////////////////////////////////
proc isEndChart()
"USAGE: isEndChart(); for hypersurfaces: checks whether maxord == 1 and whether there are no old components anymore 
for binomialideals: checks whether IX contains IZ, checks whether inv = 1,...,1 and there are no old components  
RETURN: 1, if L is endchart
		0, otherwise
		
EXAMPLE: example isEndChart; shows an example
"{

	list invariant = MaxIX[1][1];
	int maxord = invariant[size(invariant)-1];
	int NumbOldComps = invariant[size(invariant)];
	list list_of_exponents = ideal_to_list(IX)[1];
	list A = list_of_exponents[1];
	list B = list_of_exponents[2];
	int n = nvars(basering);
	int i; int j;
	int allAzero = 1;
	int allBzero = 1;
	int flag = 1;
	int idealsize = size(A);

	if(EqualityOfIdeal(1,IX) == 1){
		return(1);
	}
	
	if(size(reduce(IZ,IX,1)) > 0) {            // IZ not in IX
		return(1);
	}

	//maxord >1 or NumbOldComps > 0
	if(maxord > 1 or NumbOldComps >0){				//maxord not equal to 1 or there are still old components
		return(0);
	}
	
	if(EqualityOfIdeal(descended_IZ,IX) == 1){
		return(1);
	}
	
	for(j = 1; j<= idealsize; j++){	
		allAzero = 1;
		allBzero = 1;
		for(i = 1; i<=n; i++){		//maxord == 0
			if(A[j][i] > 0){
				allAzero = 0;
			}
			if(B[j][i] > 0){
				allBzero = 0;
			}			
		}
		if(allAzero == 0 and allBzero == 0){
			flag = 0;
			break;
		}
	}
	if(flag == 1){
		return(1);
	}
	
	// for binomial ideals:
	if(EqualityOfIdeal(descended_IZ,IX) == 1){
		return(1);
	}
	if(EqualityOfIdeal(0,IX) == 1){			// only possible if maxord(IZ) == 1
		return(1);
	}
	

	
	return(1);

}
///////////////////////////////////////////////////////////////////////////////
proc ChangeListForSTDCalculation(){

	ideal sI = std(IX);
	IX = sI;
	MaxIX[1] = compute_invariants(IX,IZ); 

	return(list(IX,MaxIX));
}
///////////////////////////////////////////////////////////////////////////////
proc compute_invariants(IX,IZ)
"USAGE: compute_invariants(list activeList, int index); activeList: chart of blowUp, index: number of polynomial which defines the invariant calculation
RETURN: list of invariants: 
	a_max: max entry in list A[index],
	counter_a_max: number of entries equal to a_max,
	b_max: max entry in list B[index], 
	counter_b_max: number of entries equal to b_max
"{
	return (MaxOrdArithO(IZ,IX,descended_IZ,0)[1][1]);						
}
///////////////////////////////////////////////////////////////////////////////
proc invariantHasImproved(list invariant, list invariant_new){
	int i; int j;
	
	if(size(invariant_new) > size(invariant)){			//(1,...,1,maxord) more one entries
		return(1);
	}
	if(size(invariant_new)< size(invariant)){
		print("Something strange happens with the invariant");
		if(EqualityOfIdeal(IX,1) == 1){return(0);}
		~;
	}
	
	for(i=1; i<=size(invariant);i++){					// lexicographical comparison
		if(invariant[i] > invariant_new[i]){
			return(1);
		}if(invariant[i] < invariant_new[i]){
			print("Invariante ist gestiegen!");
			return(0);
		}
	}
	return(0);
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
///////////////////////////////////////////////////////////////////////////////
//Max Ord Berechnungen
///////////////////////////////////////////////////////////////////////////////
//
///////////////////////////////////////////////////////////////////////////////

LIB "elim.lib";
LIB "gitfan.lib";
LIB "linalg.lib";
LIB "general.lib";
LIB "primdecint.lib";
///////////////////////////////////////////////////////////////////////////////


//--------------------------------------EqualityofIdeals----------------

proc EqualityOfIdeal(ideal I, ideal J)
"USAGE: EqualityOfIdeal(ideal I, ideal J); I,J ideals
RETURN: 1 if ideals are equal, 0 otherwise
EXAMPLE: example EqualityOfIdeal; shows an example
"
{    // gibt 1 zurück, wenn Ideale gleich, sonst 0
	ideal sI = std(I);
	ideal sJ = std(J);
 
	if(size(reduce(I,sJ,1)) > 0) {            // I not in J
		return(0);
	}
	if(size(reduce(J,sI,1)) > 0) {            // J not in I
		return(0);
	}
	return(1);                                // Equal
}
example
{ "EXAMPLE:"; echo = 2;
  ring r=0,(x,y,z),dp;
  poly f1=(x2+y2+z2-6)*(x-y)*(x-1);
  poly f2=(x2+y2+z2-6)*(x-z)*(y-2);
  poly f3=(x2+y2+z2-6)*(x-y)*(x-z)*(z-3);
  ideal I=f1,f2,f3;
  poly g1=(x2+y2+z2-6)*(x-1);
  poly g2=(x2+y2+z2-6)*(y-2);
  poly g3=(x2+y2+z2-6)*(z-3);
  ideal J=g1,g2,g3;
  EqualityOfIdeal(I,J);
  EqualityOfIdeal(J,J);
}
///////////////////////////////////////////////////////////////////////////////

proc EqualToZero(ideal I)
"USAGE: EqualToZero(ideal I); I ideal
RETURN:1 if I is equal zero, 0 otherwise
EXAMPLE: example EqualToZero; shows an example
"
{                
	if (size(reduce(I,std(0),1)) > 0) {  		// I==0?
		return(0); 
	}
	return(1);
}
example
{ "EXAMPLE:"; echo = 2;
  ring r = 0,(x,y,z),dp;
  poly f1 = (x2+y2+z2-6)*(x-y)*(x-1);
  poly f2 = (x2+y2+z2-6)*(x-z)*(y-2);
  poly f3 = (x2+y2+z2-6)*(x-y)*(x-z)*(z-3);
  ideal I = ideal(f1,f2,f3);
  ideal J = 0;
  EqualToZero(I);
  EqualToZero(J);
}
///////////////////////////////////////////////////////////////////////////////

proc EqualToOneOverZp(ideal I, int p)
"USAGE: EqualToOneOverZp(ideal I, int p); I ideal, p prime
RETURN:1 if I is equal one over Zp, 0 otherwise
EXAMPLE: example EqualToOneOverZp; shows an example
"
{
	ideal sI = std(I);
 
	if (EqualityOfIdeal(sI,1)) {
		return(1);
	} 
	if (!IntersectionWithRingEqualZero(I) ) {				//I \cap Ring != <0>
		int Constant = int (IntersectionWithRing(sI)[1]);  
		if (Constant % p != 0) {
			return(1);
		}  
	}
	return(0);
}
example
{ "EXAMPLE:"; echo = 2;
  ring r = integer,(x,y,z),dp;
  ideal I = ideal(3*z,14);
  ideal J = (5*x,6);
  EqualToOneOverZp(I,3);
  EqualToOneOverZp(J,3);
}
///////////////////////////////////////////////////////////////////////////////
//--------------------------------------EqualityofLists----------------
proc EqualityOfList(list l, list k)
"USAGE: EqualityOfList(list l,list k); l,k lists
RETURN:1 if l and k are equal, 0 otherwise
EXAMPLE: example EqualityOfList; shows an example
"
{
	int i;
	int listlength = size(l);
	if( listlength != size(k)) {				//lists have same size?
		return(0);
	}
	
	for(i = 1; i<= listlength; i++) {			//compare every listmember
		if(l[i] != k[i]) {
			return(0);
		}
	}
	return(1);  
}
example
{ "EXAMPLE:"; echo = 2;
  ring r = integer,(x,y,z),dp;
  list L1 = 1,2,3;
  list L2 = 4,5,6;
  list L3 = 1,2,3;
  EqualityOfList(L1,L2);
  EqualityOfList(L1,L3);
}
///////////////////////////////////////////////////////////////////////////////
proc MemberOfList( poly f, list L)
"USAGE: MemberOfList(poly f, list L); f poly, L list 
RETURN:1 if f is member of L[1], 0 otherwise
EXAMPLE: example MemberOfList; shows an example
"
{
	int length = size(L[1]);
	int i;
	for(i = 1; i <= length; i++) {
		if(L[1][i] == f) {
			return(1);
		}
	}
	return(0);
}
example
{ "EXAMPLE:"; echo = 2;
  ring r = integer,(x,y,z),dp;
  poly f = 3x2 + 4x+5;
  poly g = 3x+7;
  poly h = 7y-4x;
  poly i = 24;
  list L;
  L[1] = list(f,g,i);
  MemberOfList(f,L);
  MemberOfList(h,L);
}

///////////////////////////////////////////////////////////////////////////////
//-----------------------------Append to List---------------------------
//Nur einfuegen wenn nicht bereits vorhanden
proc AppendListToList(list L1, list L2)
"USAGE: AppendListToList(list L1, list L2); L1,L2 lists
RETURN: a list which contains L1 with appended elements of list L2 without doublelising 
EXAMPLE: example AppendListToList; shows an example
"
{
	list returnList = L1;
	int i; int j; int contained;
  
	for(j = 1; j <= size(L2);j++) {						//check which members of L2 should append to L1
		contained = 0;
		for (i =1; i<=size(L1); i++) {
			if (L1[i] == L2[j]) {contained = 1;}
		}
		if(contained == 0) {							//only append if current member of L2 is not contained in L1
			returnList[size(returnList)+1] = L2[j];
		}
	}
  
  return(returnList);
}
example
{ "EXAMPLE:"; echo = 2;
  list L1 = 1,2,3;
  list L2 = 4,5,6;
  list L3 = 5,2,4;
  AppendListToList(L1,L2);
  AppendListToList(L1,L3);
}
///////////////////////////////////////////////////////////////////////////////
//---------------------------List of Coeffizient -----------------------
proc ListOfCoeffs(ideal I) 
"USAGE: ListOfCoeffs(ideal I) ; I ideal
RETURN: list of coefficients of I for calculate HasseDeriv
EXAMPLE: example ListOfCoeffs; shows an example
"
{
	int n = nvars(basering);  
	int tmp; int i;
	poly ProductOfVars = 1;
  
	for(tmp = 1; tmp <=n; tmp++) {       			//Product of t(i) 
		ProductOfVars = ProductOfVars * var(tmp);
	}
  
  
	list CoeffsI;
	for (i = 1; i<= size(I); i++) {
		matrix CoeffsFtemp = coef(I[i], ProductOfVars);    
		for (tmp = 1; tmp <= ncols(CoeffsFtemp); tmp++) {
			if(CoeffsFtemp[2,tmp]!=0) {
				CoeffsI[size(CoeffsI)+1] = CoeffsFtemp[2,tmp];      
			}
		}
	}
	return(CoeffsI);
}
example
{ "EXAMPLE:"; echo = 2;
  ring R = integer,(x,y,z),dp;
  ideal I = ideal(3x2,7y,z);
  ListOfCoeffs(I);
}
///////////////////////////////////////////////////////////////////////////////
//---------------------------Ideal geschnitten Z -----------------------
proc IntersectionWithRingEqualZero(ideal I)
"USAGE: IntersectionWithRingEqualZero(ideal I) ; I ideal
RETURN: 1 if the intersection of I and the ring is equal to zero, 0 otherwise
EXAMPLE: example IntersectionWithRingEqualZero; shows an example
"
{       //needs global order
	ideal J = I;
	int n = nvars(basering);
	int i;
	for (i = 1; i <= n; i++) {                       // eliminate one Variable after another  
		J = eliminate(J,var(i));                       
	}
  
	return(EqualToZero(J));
}
example
{ "EXAMPLE:"; echo = 2;
  ring R = integer,(x,y,z),dp;
  ideal I = ideal(3x2,7y,z,5);
  ideal J = ideal(3x2,7y,z);
  IntersectionWithRingEqualZero(I);
  IntersectionWithRingEqualZero(J);
}
///////////////////////////////////////////////////////////////////////////////
proc IntersectionWithRing(ideal I)
"USAGE: IntersectionWithRing(ideal I); I ideal
RETURN: ideal J which represent the intersection of I and the ring
EXAMPLE: example IntersectionWithRing; shows an example
"
{
	ideal J = I;
	int n = nvars(basering);
	int i;
	for (i=1; i<=n; i++) {                       // eliminate one Variable after another    
		J = eliminate(J,var(i));                 
	}
	return(J);	
}
example
{ "EXAMPLE:"; echo = 2;
  ring R = integer,(x,y,z),dp;
  ideal I = ideal(3x2,7y,z,5);
  ideal J = ideal(3x2,7y,z);
  IntersectionWithRing(I);
  IntersectionWithRing(J);
}

///////////////////////////////////////////////////////////////////////////////


//----------------------------------------------------------------------
//
//----------------------Hasse Derivation--------------------------------
//
//----------------------------------------------------------------------


proc HasseDeriv(ideal IZ, ideal IX, list y, matrix M)
"USAGE: HasseDeriv(ideal IZ, ideal IX, list y, matrix M) ; IZ, IX ideals, y system of parameters, M matrix
RETURN: list L, so that L[i] contains the i-th Hasse-Schmidt derivations
EXAMPLE: example HasseDeriv; shows an example
"
{
	//check whether input is correctly
	if(EqualityOfIdeal(IZ,IX)) {ERROR("IZ und IX duerfen nicht identisch sein!");}
	if(size(reduce(IZ,std(IX),1)) > 0) {            // IZ nicht in IX
		~;
		ERROR("IZ muss in IX enthalten sein");
	}
  
	def Ring = basering; 
	int n = nvars(Ring);                        // number of variables
	int t = size(IZ);							// number of generators of IZ
	list RetList;								// List which will contain the HasseDerivs
  
	ideal Idealf = std(reduce(IX,std(IZ)));		//for calculating f_i in Hasse-Schmidt derivationalgorithm
	int r = size(IX);
	int j; int i;
  
	if(EqualToZero(IZ)) {                    		//IZ==0  
		execute("ring RADRING=(0),("+varstr(basering)+",t(1..n)),("+ordstr(basering)+",dp(n));");    // wechsel nach Q, weil JET nicht für Z implementiert ist
		ideal IZ = imap(Ring, IZ);
		ideal IX = imap(Ring,IX); 						//IX = <f1,...,fr>
		list F;

    
		for (j=1; j <=r; j++) {
			F[j] = IX[j];
			for (i=1; i<=n; i++) {
				F[j] = subst(F[j],var(i),var(i)+t(i)); 	//Fj(y,t) = fj(x1+t1,....,xn+tn);
			}
		}

		i = 1;
		list tempid;
    
		for (j=1; j<=t; j++) {      				//tempid = g1,...,gt,f1,...,fr
			tempid[j] = IZ[j];
		}
		for (j=1; j<=r; j++) {
			tempid[t+j] = IX[j];
		}
    
    
		int tmp; 
		poly ProductOfVars = 1;
		for(tmp = 1; tmp <= n; tmp++) {       //Product of t(i) 
			ProductOfVars = ProductOfVars * t(tmp);
		}
		intvec weights = 0:n,1:n;
		poly tmpJeti;
		matrix CoeffsT;
		// erster schleifendurchlauf garantiert, erst danach gibt es RetList[i-1]-> pruefen am ende der whileschleife -> break
		while(1) {  
			RetList[i] = tempid;
			weights = 0:n,1:n;            // vektor mit n Nullen gefolgt von n Einsen/ Gewichte fuer Jet
      
			//for (...){tempid= tempid, ...}
			for(j=1; j<=r; j++) {                                 
				tmpJeti = jet(F[j],i,weights) - jet(F[j],i-1,weights); //homogenes polynom vom grad i in t1,...,tn
				CoeffsT = coef(tmpJeti, ProductOfVars);    				//koeffizienten von t^alpha:
				for (tmp = 1; tmp <= ncols(CoeffsT); tmp++) {
					if(CoeffsT[2,tmp]!=0) {
						tempid[size(tempid)+1] = CoeffsT[2,tmp];      
					}
				}
			}
			i++;
      
			if( EqualityOfList(tempid, RetList[i-1])) {       //Leavingcondition while
				break;
			}
		}
    
    
		if (r > 0) {
			setring(Ring);                                //zurueck zum alten ring, falls es Ringwechsel gab
			list RetList = imap(RADRING,RetList);
			if(defined(RADRING)){kill RADRING;} 
			return(RetList);
		}
	} else {											//case IZ!=0
																
		r = size(Idealf);                                          
		poly detM = det(M);
		matrix A = inverse_L(M)[1];   					//Matrix of Cofactors of M
		ideal Itemp = IX;
		intvec Nullvektor = 0:size(y);					
		intvec note = 0:size(y);
		list L;
	
	
		for (i = 1; i <=r; i++) {
			L[i] = list(Idealf[i],Nullvektor);                 // L[i] = fi,(0,....,0)
		}
  
		int old = 0;
		int cur = r;
		poly ftemp;
  
		while(IntersectionWithRingEqualZero(Itemp)) {
			ftemp=0;      
			for(i=old+1; i<= cur; i++) {     					          
				for(j=1;j <= size(y);j++) {					//(ftemp,note) = L[i]
					ftemp = L[i][1];
					note = L[i][2];
					note[j] = note[j]+1;
					ftemp = PseudoDifferential(ftemp,j,A,detM,IZ,y) / note[j];
        
					if(ftemp != 0){    							//only append to list L if derivation is not null
						L[size(L)+1] = list(ftemp,note);
						Itemp = Itemp + ideal(ftemp);
					}
				}
			}
					
			Itemp = sat(Itemp,detM)[1];         			// eliminate elements in V(q) 
			RetList[size(RetList)+1] = Itemp;
			old = cur;										// dont calculate the same Derivations twice
			cur = size(L);
		}
	}	//end case IZ !=0
	
	return(RetList);
}
example
{ "EXAMPLE:"; echo = 2;
  ring R = integer,(x(1..4)),dp;
  ideal IX = ideal(3*x(2),4*x(4)^3);
  ideal IZ = 0;
  list y = x(1..4);
  matrix M = 0;
  HasseDeriv(IZ,IX,y,M);
  IZ = ideal(x(1));
  IX = IZ + ideal(3*x(2),4*x(4)^3);
  y = x(2..4);
  M = 1;
  HasseDeriv(IZ,IX,y,M);
}


//--------------------------------------CoDim---------------------------

//////////////////////////////////////////////////////////////////////////////
proc Codimension(ideal I)
"USAGE: Codimension(ideal I); I ideal
RETURN: the codimension of I
EXAMPLE: example Codimension; shows an example
"
{
	ideal J = std(I);
	int NumbOfVars = nvars(basering);
	int DimJ = dim(J);
  
	if (charstr(basering)== "ZZ"){ 				//basering == integer?
		return( NumbOfVars - DimJ+1);
	} else {  									//basering is a field
		return(NumbOfVars - DimJ); 
	}
}
example
{ "EXAMPLE:"; echo = 2;
  ring R = integer,(x,y,z,a,b),dp;
  ideal I = ideal(3x2,7y);
  Codimension(I);
  ring R2 = 0,(x,y,z,a,b),dp;
  ideal I = ideal(3x2,7y);
  Codimension(I);
}
//////////////////////////////////////////////////////////////////////////////
//-----------------------------Bedingung an L1--------------------------
proc ConditionOfL1(list L1, ideal JX, list #)
"USAGE: ConditionOfL1(list L1,ideal JX); L1 list of matrices, JX ideal, list primelist
RETURN: 1 if ConditionOfL1 is satisfied, 0 otherwise
EXAMPLE: example ConditionOfL1; shows an example
"
{
	int i;
	if(size(#) == 0){
		ideal tmp = det(L1[1]);
  
		for (i=2; i<= size(L1); i++) {
			tmp = tmp,det(L1[i]);
		}
		//option(prot);
		if (size(reduce(1,std(JX+tmp))) == 0) { 	// X geschnitten tmp = leere Menge
			return(1);
		}
		return(0);
	}else{
		
		list primelist = #;
		poly primeproduct = 1;
		for (i=1; i<= size(primelist); i++) {
			primeproduct = primeproduct * primelist[i];
		}
		ideal tmp = det(L1[1]),primeproduct;
  
		for (i=2; i<= size(L1); i++) {
			tmp = tmp,det(L1[i]),primeproduct;
		}
		//option(prot);
		ideal JXDp = JX,primeproduct;
		if (size(reduce(primeproduct,std(JXDp+tmp))) == 0) { 	// X geschnitten tmp = leere Menge
			return(1);
		}
		return(0);
	}
  return(0);
}
example
{ "EXAMPLE:"; echo = 2;
  ring R = integer,(x,y,z),dp;
  ideal JX = ideal(x2,y);
  list L1 = 2x,2y;
  ConditionOfL1(L1,JX);
}
//-----------------------------L1 erzeugen------------------------------

// Erst werden Codim(Z)-Teilmengen der Spalten und Zeilen gebildet. 
// Dann werden alle quadratischen Untermatrizen der Codim(Z) von JZ durch Spaltenweises (danach Zeilenweise) gebildet
// Dabei wird nach jedem Hinzufuegen geprueft, ob die Bedingung bereits erfuellt ist
  
proc GenerateL1(int CoDimZ, matrix JZ, ideal IX, ideal IZ, list #)
"USAGE: GenerateL1(int CoDimZ, matrix JZ, ideal IX[, string optionname, list primelist]); L1 list of matrices, IX, IZ ideal[, string optionname, list primelist]
RETURN: list L1 with to respect to conditions on maxord calculations and indices of the colomns of JZ
EXAMPLE: example GenerateL1; shows an example
"
{
	list L1;
	int maxcol = ncols(JZ);
	int maxrow = nrows(JZ);

	int i; int j; int k;

	if(size(#)> 0){
		list primefactorlist = #;
	}
	//check whether Jacobian matrix has a single one
	// and manipulate JZ
	poly hi;
	int positionOfOne_col = 0; int positionOfOne_row = 0;
	int containsOne = 0;
	for (i=1; i<=maxrow; i++) {
		for (j=1; j<=maxcol; j++){
			if(JZ[i,j]==1){
				containsOne = 1;
				positionOfOne_col = j;
				positionOfOne_row = i;

				hi = var(j) - IZ[i];				//hi = x_j -fi
				for(k=1; k<=maxrow; k++) {
					if(k != i){
						IZ[k] = subst(IZ[k],var(j),hi);		// fk(xj -> hi) for all k != i
					}
				}
			}
			if(containsOne == 1) {break;}			// for only finding a single one
		}
		if(containsOne == 1) {break;}				// for only finding a single one
	}
	JZ = jacob(IZ);
	
	maxcol = ncols(JZ);
	maxrow = nrows(JZ);
	//end manipulation on JZ


	list colIndices = subsets(maxcol,CoDimZ);  		//benoetigt LIB "gitfan.lib";
	list rowIndices = subsets(maxrow,CoDimZ);
  
	intvec rowIndex = 0:CoDimZ;
	intvec colIndex = 0:CoDimZ;
  
	int NumbColIndices = size(colIndices); 
	int NumbRowIndices = size(rowIndices);   
  
	list vectorsL1 = list(); 					// format: [i][1] zeilenvektor [i][2] spaltenvektor
	
  
	for (i=1; i<= NumbRowIndices;i++) {  			//Zeilenweise indicelisten zum Intvec konvertieren

		for(j =1; j<= CoDimZ;j++) {
			rowIndex[j] = int(rowIndices[i][j]);  	//naechsten rowVector nehmen
		}
		for(j = 1; j<= NumbColIndices; j++) { 		//rowVector (zeile) fest, colvektor (spalte) veraendern
			
			for(k = 1; k <= CoDimZ; k++) {     		//naechsten ColVector (spalte) nehmen
				colIndex[k] = int(colIndices[j][k]); 
			}
			
			if(det(submat(JZ,rowIndex,colIndex)) == 0){
				j++;
				continue;
			}
			if(positionOfOne_row != 0){
				if( MemberOfList(poly(positionOfOne_row),colIndex) && MemberOfList(poly(positionOfOne_col),rowIndex) ) {		//es wurde 1 in JZ gefunden -> beachte nur untermatrizen mit diesem eintrag
					L1[size(L1)+1] = submat(JZ,rowIndex,colIndex);
					vectorsL1[size(vectorsL1)+1] = list(rowIndices[i],colIndices[j]);
					//end of optimizing
				}else{
					j++;
					continue;
				}
			} else { 			// keine optimierung moeglich -> fuege alle hinzu
				L1[size(L1)+1] = submat(JZ,rowIndex,colIndex);     //Erzeugen der Menge L //NICHT EXPLIZIT NOTWENDIG 
				vectorsL1[size(vectorsL1)+1] = list(rowIndices[i],colIndices[j]);
			}
			if(size(L1)!=0){
				if(size(#) == 0){
					if(ConditionOfL1(L1,IX)) {return(list(L1,vectorsL1));}
				} else{
					if(ConditionOfL1(L1,IX,primefactorlist)) {return(list(L1,vectorsL1));}
				}
			}
		}
		//if(size(L1)!=0){
		//	if(size(#) == 0){
		//		if( ConditionOfL1(L1,IX)) {break;}   		 // Falls man so nur aus der innen for-schleife rauskommt
		//	} else{
		//		if( ConditionOfL1(L1,IX,primefactorlist)) {break;}
		//	}
		//}
	}
	return(list(L1,vectorsL1));
	//return(list(L1,colIndices));
	//return(list(L1,rowIndices));
}
example
{ "EXAMPLE:"; echo = 2;
  ring R = integer,(x,y,z),dp;
  ideal IZ = x2;
  int codimZ = Codimension(IZ);
  matrix JZ = jacob(IZ);
  ideal IX = IZ + ideal(y);
  GenerateL1(codimZ,JZ,IX,IZ);
}

//////////////////////////////////////////////////////////////////////////////
//----------------------y Menge erzeugen -------------------------------
proc SystemOfParameters(int member, list vectorsL1, int CoDimZ)
"USAGE: SystemOfParameters(int member, list colIndices, int CoDimZ); member integer, colIndices list, CoDimZ codimension of IZ
RETURN: list which ist a system of parameters with respect to conditions on maxord calculations
EXAMPLE: example SystemOfParameters; shows an example
"
{
	list y;
	list Spaltenvector = vectorsL1[member][2];
	int j; int k; int equal;    
	
	for(j = 1; j <= nvars(basering); j++) {
		equal = 0;
		for(k = 1; k <= CoDimZ; k++) {
			if(j	==	Spaltenvector[k]){equal = 1;}
		}
		if(equal == 0){
			y[size(y)+1]= var(j);   					 // j is not in indices, append xj to y
		}
	}    
  
  return(y);
}
example
{ "EXAMPLE:"; echo = 2;
  ring R = integer,(x(1..8)),dp;
  int member = 1;
  list colIndices;
  colIndices[1]= list(2,3,4,5,6,7,8);
  int CoDimZ = 1;
  SystemOfParameters(member,colIndices,CoDimZ);
}

//----------------------------------------------------------------------
//-------------Derivates with respect to parametersystem----------------

proc PseudoDifferential(poly f, int j, matrix A, poly q, ideal I, list y)
"USAGE: PseudoDifferential(poly f, int j, matrix A, poly q, ideal I, list y); f,q poly, j integer, A Matrix, I ideal, y system of parameters
RETURN: poly which is the pseudodifferential of f with respect to a system of parameters
EXAMPLE: example PseudoDifferential; shows an example
"
{
	poly RetPoly = q * diff(f,y[j]);
	poly SubPoly;
	poly F = reduce(f,std(I));              
	int NumbOfVar = nvars(basering);
	list OtherVar;					//List of Variables which aren't in parametersystem y
	int VarInY;						//bool for check whether current variable is in parametersystem y
	int k; int i; int l;
	
	for (k = 1; k<= NumbOfVar; k++){
		VarInY = 0;
		for (i = 1; i<= size(y); i++) {
			if(y[i] == var(k)) {
				VarInY=1;
			}
		}
		if(!VarInY) {
			OtherVar[size(OtherVar)+1] = var(k);	//append xk to list of variables which are not in y
		}
	}
	
	for (k = 1; k <= ncols(A); k++) {				// See formular in remark 4.2
		for (l = 1; l<= nrows(A);l++) {
			SubPoly = diff(I[l], y[j]) * A[l][k] * diff(F,OtherVar[k]);
			SubPoly = reduce(SubPoly, std(I)); 
			RetPoly = RetPoly - SubPoly;
		}
	}

	return(RetPoly);
}
example
{ "EXAMPLE:"; echo = 2;
  ring R = integer,(x(1..8)),dp;
  poly f = x(1)^2+3*x(2);
  int j = 2;
  ideal IZ = ideal(x(2));
  ideal JX = ideal(x(1)^2,x(2));
  list y = SystemOfParameters(3,list(1,2,3,4,5,6,7,8),1);
  matrix M = 1;
  poly detM = det(M);
  matrix A = inverse_L(M)[1];
  PseudoDifferential(f,j,A,detM,IZ,y);
}
//----------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////////////
//----------------------------------------------------------------------
//
//----------------------MaxOrd Char K = 0-------------------------------
//
//----------------------------------------------------------------------
proc MaxOrd (ideal IZ, ideal IX, list #)
"USAGE: MaxOrd (ideal IZ, ideal IX); IZ,IX ideals
RETURN: list of the maximal order and the ideal of the locus of maximal order in geometric case
EXAMPLE: example MaxOrd; shows an example
"
{
	//check whether input is correctly
	//if(EqualityOfIdeal(IZ,IX)) {ERROR("IZ und IX duerfen nicht identisch sein!");} //rausgenommen fuer Beispiel 1
	if(size(reduce(IZ,std(IX),1)) > 0) {            // IZ nicht in IX
		~;ERROR("IZ muss in IX enthalten sein");
	}
	int i; int j; 
	
	int limit_order = 0;
	list OldMaxOrdList = 0;
	ideal OldMaxOrdIdeal = 1;
	ideal OldImaxComp = 1;
	ideal NewImaxComp = 1;
	int OldMaxOrdDefined = 0;
	
	//read optional input
	if(size(#)> 0){
		if(typeof(#[1])=="int"){
			limit_order = #[1];
		}
		if(typeof(#[1])=="list"){
			OldMaxOrdList = #[1];
			for(i=1; i<=size(OldMaxOrdList);i++){
				OldMaxOrdIdeal = OldMaxOrdIdeal * OldMaxOrdList[i]; //not intersect in order to have the same order as in the following calculation 
			}
			OldMaxOrdDefined = 1;
		}
	}
	
	ideal Itemp = IX;
	ideal Imax = 1;
	int maxord = 0;
	int r = size(IX);
	int n = nvars(basering);
  
	ideal f;
  
	if (EqualToZero(IZ)) {									//case IZ ==0
		while (!EqualityOfIdeal(Itemp,1)) {
			Imax = Itemp;
			r = size(Itemp);
			f = Itemp;
			for (i = 1; i<=r;i++) {
				for (j = 1; j<=n; j++) {
					Itemp = Itemp + ideal ( diff( f[i],var(j) ));  
				}
			}
			maxord = maxord+1;
			if(limit_order != 0){
				if(maxord > limit_order){
					return(list(0,0,0,1));		//trivial true value
				}
			}
		}
		
		list Imaxneu;
		// for a better representation of the output:
		if(OldMaxOrdDefined == 1){
			//for a faster minAssZ-call:
			if(size(reduce(Imax,OldMaxOrdIdeal)) == 0){ // all old components plus the new components
				NewImaxComp = quotient(Imax,OldMaxOrdIdeal);
				Imaxneu = minAssZ(NewImaxComp) + OldMaxOrdList;
			} else{
				if(size(reduce(OldMaxOrdIdeal,Imax)) == 0){
					OldImaxComp = quotient(OldMaxOrdIdeal,Imax);
					Imaxneu = OldImaxComp;
				} else{ // no optimation on minAssZ-calls possible
					Imaxneu = minAssZ(Imax);
				}
			}
		}else{
			Imaxneu = minAssZ(Imax);
		}
		
		list RetList;
		ideal Itmp;
		
		for (i = 1;i <= size(Imaxneu); i++){
			Itmp = ideal(Imaxneu[i]);
			RetList[i] = Itmp;
		}
		
		
	} else {												//case IZ != 0

		int CoDimZ = Codimension(IZ);
		//Berechnung der Menge L:
		matrix JZ = jacob(IZ);
		list GeneratorList = GenerateL1(CoDimZ, JZ,IX,IZ);
		list L1 = GeneratorList[1];
		list vectorsL1 = GeneratorList[2];
  
		ideal polynomialFi;
		maxord = 1;
		int thisord = 0;
		Imax = 1;
		int s; poly detM; list y; int member;
		matrix M;
		matrix A;
		ideal Iold;
		
		for (member = 1; member <= size(L1); member++){ 	 //member stimmt mit i aus L und indices ueberein
			M = L1[member];
			detM = det(M);
			Iold = 0;
		    thisord = 0;
			if(detM != 0){									//only need calculations if detM != 0
				y = SystemOfParameters( member, vectorsL1, CoDimZ);  
				s = size(y);
				Itemp = IX;
				A = inverse_L(M)[1]; 				//A is matrix of cofactors of M
    
				while(!EqualityOfIdeal(Itemp+IZ,1)) {
					Iold = Itemp;
					//polynomialFi = simplify(reduce(Itemp,std(IZ)),2);                  // nach remark 4.2
					polynomialFi = std(reduce(Itemp,std(IZ)));
					r = size(polynomialFi);
					Iold = Itemp;
        
					for (i = 1; i<=r; i++ ) {
						for (j = 1; j<=s; j++) {
							Itemp = Itemp + ideal(PseudoDifferential(polynomialFi[i],j,A,detM,IZ,y));   //derivation with respect to parametersystem y
						}  
					}
    
					Itemp = sat(Itemp,det(M))[1];   //eliminate factor q in derivations
					thisord = thisord+1;
					
					if(limit_order != 0){
						if(maxord > limit_order){
							return(list(0,0,0,1));		//trivial true value
						}
					}
					
				}
					//check whether its nessecary to glue components
				if (thisord >= maxord) {
					if (thisord == maxord) {		//glue components
						Imax = intersect(Imax,Iold);
					} else {						//change maxord and ideal of maxorderlocus
						maxord = thisord;
						Imax = Iold;
					}  
				}
			}
		} 
		
		if(limit_order == 0){ // only necessary if we need the output
			
			// for a better representation of the output:
			list Imaxneu;
			//for a faster minAssZ-call:
			if(OldMaxOrdDefined == 1){
				//for a faster minAssZ-call:
				if(size(reduce(Imax,OldMaxOrdIdeal)) == 0){ // all old components plus the new components
					NewImaxComp = quotient(Imax,OldMaxOrdIdeal);
					Imaxneu = minAssZ(NewImaxComp) + OldMaxOrdList;
				} else{
					if(size(reduce(OldMaxOrdIdeal,Imax)) == 0){
						OldImaxComp = quotient(OldMaxOrdIdeal,Imax);
						Imaxneu = OldImaxComp;
					} else{ // no optimation on minAssZ-calls possible
						Imaxneu = minAssZ(Imax);
					}
				}
			}else{
				Imaxneu = minAssZ(Imax);
			}
			
			list RetList;
			ideal Itmp;
			for (i=1;i<=size(Imaxneu);i++){
				Itmp = ideal(Imaxneu[i]);
				RetList[i] = Itmp;
			}
		}else{ 	// theoretically zero ideal as possible as this ideal, since we do not need any calculation of the locus here
			list RetList;
			for (i=1;i<=size(Imax);i++){
				RetList[i] = ideal(Imax[i]);
			}
		}
		
	}
	if(limit_order != 0){
		return(list(maxord,Imax,RetList,0));
	}
	return(list(maxord,Imax,RetList));						// return for both cases
	
}
example
{ "EXAMPLE:"; echo = 2;
  ring R = 0,(x(1..8)),dp;
  ideal IZ = 0;
  ideal IX = ideal(3*x(4)^5);
  MaxOrd(IZ,IX);
  IZ = ideal(x(1)*x(2)-1);
  IX = IZ+ideal(3*x(4)^5);
  MaxOrd(IZ,IX);
}
//////////////////////////////////////////////////////////////////////////////
//---------------------------------qadic Expansion ---------------------

proc qAdicExpansion(int q, int c)
"USAGE: qAdicExpansion(int q, int c); q,c int
RETURN: the q-adic expansion of c 
EXAMPLE: example qAdicExpansion; shows an example
"
{
	int m = nvars(basering);   //m  Nummer der letzten variable Q
	poly expansion = poly(c);
	int absc = absValue(c);                    // - als rechenzeichen betrachten
	int i;

	while(1) {
		for (i = 0; i <= absc; i++) {      //find highest exponent of q
			if( (q^i <= absc ) && (q^(i+1)> absc )) {
				break;
			}
		}
		if (i==0) { break;}
			absc = absc - q^i;
			if (c<0) {
				expansion = expansion + q^i - var(m)^i; 
			} else {
				expansion = expansion - q^i + var(m)^i;
		}
		
		//expansion;
		if(absc == 0){
			return(expansion);
		}
	}
	return(expansion);
}
example
{ "EXAMPLE:"; echo = 2;
  ring R = integer,(x(1),x(2),Q),dp;
  int q = 3;
  int c = 17;
  qAdicExpansion(q,c);
  q = 3;
  c = -17;
  qAdicExpansion(q,c);
}
//////////////////////////////////////////////////////////////////////////////
//--------------------Calculate List of Coefficients--------------------
proc CalculateListOfPrimefactors(ideal IZ)
"USAGE: CalculateListOfPrimefactors(ideal IZ); IZ = ideal(g_1,...,g_t) ideal
RETURN: primefactors of coefficients appearing in g_1,...,g_t
EXAMPLE: example ReplaceCoeffsIntPrimesNEW; shows an example
"
{
	int i;int j;
	list primefactorlist;
	list tmp_primefactors;
	poly coefficient;
	
	for(i=1; i<=size(IZ);i++){
		for(j=1; j<=size(IZ[i]);j++){	//IZ[i][j] are monomials appering in IZ
			coefficient = IZ[i][j] div leadmonom(IZ[i][j]);
			if(int(coefficient) != 1){
				tmp_primefactors = primefactors(bigint(coefficient))[1];
				if(size(primefactorlist) == 0){
					primefactorlist = tmp_primefactors;
				}else{
					primefactorlist = AppendListToList(primefactorlist, tmp_primefactors);
				}
			}
		}
	}

	return(primefactorlist);
}



//////////////////////////////////////////////////////////////////////////////
//---------------------------Replace Coeffs in Ideal--------------------

//--------------------Coefficient Replace in INTPRIMES------------------
proc ReplaceCoeffsIntPrimesNEW(ideal I)
"USAGE: ReplaceCoeffsIntPrimesNEW(ideal I); I ideal
RETURN: Ideal J which is like ideal I with replaced coefficients with respect to NEW Construction 4.4 in Interesting Primes
EXAMPLE: example ReplaceCoeffsIntPrimesNEW; shows an example
"
{
	ideal J;
	poly ftemp;           //aktueller Erzeuger
	poly TempMonom; poly currentTwoAdicExpansion; poly ReplacedPolyCQ;
	list PrimefactorsOfCoef;
	int deltafactor;			//1 or -1 
	int ai; int pi; int currentcoef;
 
	int i; int j; int k; list F; list EmptyList;
	
	for (i = 1; i<= size(I);i++) {
		F = EmptyList;                        //F als Liste von Monomen auf leere Liste zurücksetzen
		ftemp = I[i];
		for (j = 1; j<= size(ftemp); j++) {
			F[size(F)+1] = ftemp[j]; 
		}
    
    //Ersetzung eines Koeffizienten:
		for(j = 1; j<= size(F); j++) {           //Coeffs ersetzen           
			currentcoef = int(leadcoef(F[j]));     // c aus ZZ in Construction 4.4.
			TempMonom = leadmonom(F[j]);
      
			PrimefactorsOfCoef = primefactors(currentcoef);
			deltafactor = PrimefactorsOfCoef[3];
			ReplacedPolyCQ = 1;					//fuer jeden coefficient bei 1  starten
      	
			for(k = 1; k<=size(PrimefactorsOfCoef[1]); k++){  
				ai = PrimefactorsOfCoef[2][k];
				pi = PrimefactorsOfCoef[1][k];
				currentTwoAdicExpansion = qAdicExpansion(2, pi);					//P_i(Q) 
				ReplacedPolyCQ = ReplacedPolyCQ * ((currentTwoAdicExpansion)^ai);	
			}
			F[j] = deltafactor * ReplacedPolyCQ * TempMonom; 
		}
    
		J[i] = 0;
		for (j=1; j<= size(F); j++) {
			J[i]= J[i] + F[j];                        //Polynome zusammenpuzzeln
		}
	}
	return(J);
}
example
{ "EXAMPLE:"; echo = 2;
  ring R = integer,(x,y,z,Q),dp;
  ideal I = ideal(5*x,42*y,40z);
  ReplaceCoeffsIntPrimesNEW(I);
}

//////////////////////////////////////////////////////////////////////////////
//--------------------------Horizontal Decomposition--------------------

proc HorizontalDecomposition (ideal I)
"USAGE: HorizontalDecomposition(ideal I); I ideal
RETURN: list of primdecomposition and the indices of horizontal and vertical components
EXAMPLE: example HorizontalDecomposition; shows an example
"
{
	def OLDRING = basering;
	
	execute("ring RATIONALS=(0),("+varstr(basering)+"),("+ordstr(basering)+");"); 
	ideal I = imap(OLDRING,I);
	list primdec = imap(OLDRING,primdec);
	int length = size(primdec);
	list HorizontalIndices; list VerticalIndices;
  
	int i;
  
	for (i=1; i<= length; i++) {
		if(!EqualityOfIdeal( IntersectionWithRing(primdec[i][2]), 1)) {  		// faserprodukt mit Q ueber Z ungleich leere Menge
			HorizontalIndices[size(HorizontalIndices)+1] = i;
		}else {
			VerticalIndices[size(VerticalIndices)+1] = i;
		}
	}
	
	setring(OLDRING);
	list primdec = imap(RATIONALS,primdec);
	if(defined(RATIONALS)){kill RATIONALS;}  
	return(list( primdec, HorizontalIndices, VerticalIndices ));
}
example
{ "EXAMPLE:"; echo = 2;
  ring R = integer,(x,y,z),dp;
  ideal I = ideal(3x2,7y);
  ideal J = ideal(5);
  HorizontalDecomposition(I);
  HorizontalDecomposition(J);
}



//----------------------------------------------------------------------
//
//----------------------InterestingPrimes-------------------------------
//
//----------------------------------------------------------------------



proc InterestingPrimes (ideal IZ, ideal IX)
"USAGE: InterestingPrimes(ideal IZ, ideal IX); IZ = ideal(g_1,...,g_t),IX = ideal(g_1,...,g_t,f_1,...,f_r) ideals
RETURN: list of interesting primes
EXAMPLE: example InterestingPrimes; shows an example
"
{
	//check whether input is correct
	if(EqualityOfIdeal(IZ,IX)) {ERROR("IZ und IX duerfen nicht identisch sein!");}    
	if(size(reduce(IZ,std(IX),1)) > 0) {            // IZ nicht in IX
		ERROR("IZ muss in IX enthalten sein");
	}
  
	list resultlist;
	ideal Itemp = std(reduce(IX,std(IZ)));  // Itemp = ideal(f_1,...,f_r)
	ideal Iint;	
	int r;
	int n = nvars(basering);
  
	int i; int j;
	ideal f;
  
	Iint = IntersectionWithRing(std(IZ));
	if(EqualityOfIdeal(Iint, 0 ) == 0 ){
		resultlist = primefactors(bigint(Iint[1]))[1];  //nur die primfaktoren von Iint[1], da hauptideal ggf stdbasis von Iint
		return(resultlist);
	}
	
	Iint = 0;
	if (EqualToZero(IZ)) {								// case: IZ == 0
		while(EqualToZero(Iint)) {
			r = size(Itemp);
			f = Itemp;
			for (i = 1; i<=r ; i++) {					//optimization: only calculate diff of the f[i] generated in last pass through the loop 
				for (j = 1; j<=n; j++) {
					Itemp = Itemp + ideal ( diff( f[i],var(j) ));
				}
			}
		Iint = IntersectionWithRing(std(Itemp));
		}
		resultlist = primefactors(bigint(Iint[1]))[1];  //nur die primfaktoren von Iint[1], da hauptideal ggf stdbasis von Iint
	} else {  											// case IZ != 0
  

  
		resultlist = CalculateListOfPrimefactors(IZ);
		int CoDimZ = Codimension(IZ);
		matrix JZ = jacob(IZ);
		
		list GeneratorList = GenerateL1(CoDimZ, JZ,IX,IZ,resultlist);
		list L1 = GeneratorList[1];

		list vectorsL1 = GeneratorList[2];

		
		int s; int member; poly detM; list y;
		matrix M; matrix A;
		ideal Fi;

		//Derivation with respect to a system of parameters
		for (member = 1; member <= size(L1); member++){
			M = L1[member];
			detM = det(M);

			//only calculations needed if detM != 0
			if (detM != 0) {
				y = SystemOfParameters( member, vectorsL1, CoDimZ);
				s = size(y);
				Itemp = std(reduce(IX,std(IZ)));  // Itemp = ideal(f_1,...,f_r)	 
				Iint = 0;
				A = inverse_L(M)[1]; 			//Matrix of cofactors
				while(EqualToZero(Iint)) {
					Fi = std(reduce(Itemp,std(IZ)));              // nach remark 4.2
					r = size(Fi);
      
					for (i = 1; i<=r; i++ ) {
						for (j = 1; j<=s; j++) {
							Itemp = Itemp + ideal(PseudoDifferential(Fi[i],j,A,detM,IZ,y));
							Itemp = sat(Itemp,det(M))[1];		//eliminate components in V(detM)
						}  
					}
					Iint = IntersectionWithRing(Itemp+IZ);
				}
				if(EqualityOfIdeal(Iint,1) == 0){
					resultlist = AppendListToList(resultlist, primefactors( int(Iint[1]) ) [1]); //nicht doppelt einfuegen
				}
		
			}	
		}                                                              
	}
	return(resultlist);								//output for both cases
}
example
{ "EXAMPLE:"; echo = 2;
  ring R = integer,(x,y,z),dp;
  ideal IZ = ideal(x-4y+6z);
  ideal IX = IZ+ideal(3x-y+7z);
  InterestingPrimes(IZ,IX);
  IZ = ideal(z);
  IX = IZ + ideal(11^2+xy);
  InterestingPrimes(IZ,IX);
}
//////////////////////////////////////////////////////////////////////////////
//---------------------------Replace Coeffs in Ideal--------------------
proc ReplaceCoeffsMaxOrdArith(ideal I, int p)
"USAGE: ReplaceCoeffsMaxOrdArith(ideal I, int p); I ideal, p prime
RETURN: Ideal J which is like ideal I with replaced coefficients with respect to p in MaxOrdArith algorithm
EXAMPLE: example ReplaceCoeffsMaxOrdArith; shows an example
"
{
	ideal J;
	poly ftemp;
	list newCoeffs; //kommen woanders her
  
	list TempMonom; list EmptyList; list F;
	int i; int j;
	
	//split generators to monomials
	for (i = 1; i <= size(I); i++) {
		F = EmptyList;      //F als Liste von Monomen
		ftemp = I[i];
		for (j = 1; j<= size(ftemp); j++) {
			F[j] = ftemp[j]; 
		}
	
		//Coeffs ersetzen
		for(j = 1; j <= size(F); j++) {           
			TempMonom[1] = leadcoef(F[j]);
			TempMonom[2] = leadmonom(F[j]);
			TempMonom[1] = newCoeff(int(TempMonom[1]),p);  
			F[j] = TempMonom[1] * TempMonom[2];
		}
    
		//Polynome zusammenpuzzeln
		J[i] = 0;
		for (j=1; j<= size(F); j++) {
			J[i]= J[i] + F[j];                        
		}
	}
	return(J);
}
example
{ "EXAMPLE:"; echo = 2;
  ring R = integer,(x(1),x(2),Q),dp;
  ideal I = ideal (5*x(2),100*x(1));
  int p = 5;
  ReplaceCoeffsMaxOrdArith(I,p);
}
//////////////////////////////////////////////////////////////////////////////
//---------------------------Build new Coeffs---------------------------
proc newCoeff(int oldCoeff, int p)
"USAGE: newCoeff(int oldCoeff, int p); I ideal, p prime
RETURN: new coefficient for the replacecoeffsmaxordarith algorithm
EXAMPLE: example newCoeff; shows an example
"
{
	int m = nvars(basering);
	int l = SearchMaxPower(oldCoeff,p);
	return((oldCoeff div (p^ l)) * var(m)^l);      // Neue Variable P ist die letzte Variable des neuen Rings
}
example
{ "EXAMPLE:"; echo = 2;
  ring R = integer,(x(1..2),Q),dp;
  int oldCoeff = 25;
  int p = 3;
  newCoeff(oldCoeff,p);
  p = 5;
  newCoeff(oldCoeff,p);
}
//////////////////////////////////////////////////////////////////////////////
//---------------------------Search max l-------------------------------
proc SearchMaxPower( int c , int p)
"USAGE: SearchMaxPower(int c , int p); c int, p prime
RETURN: highest power of p which divides c
EXAMPLE: example SearchMaxPower; shows an example
"
{
	int MaxPower = 0;
	int absc = absValue(c);
 
	//teilerfremdheit:
	if( (absc%p) != 0 ) {
		return(0);
	}
	int i;
  
	//finde hoechsten teiler
	for (i = 1; i <= absc ; i++) {
		if (  (absc% (p^i)) == 0) {
			MaxPower = i;
		} else{ break;}
	}
	
  return(MaxPower);
}
example
{ "EXAMPLE:"; echo = 2;
  ring R = integer,(x(1..4)),dp;
  int c = 39;
  int p = 3;
  SearchMaxPower(c,p);
  c = 81;
  p = 3;
  SearchMaxPower(c,p);
}

//----------------------------------------------------------------------
//
//----------------------MaxOrdArith-------------------------------------
//
//----------------------------------------------------------------------


proc MaxOrdArith(ideal IZ, ideal IX, list #) 
"USAGE: MaxOrdArith(ideal IZ, ideal IX[,int checkIZ, int limit_order]); IZ,IX ideals, checkIZ = 0 to skip checking order of IZ, limit_order to check whether max. order is greater than limit_order
RETURN: list of the maximal order and a list of primes over which we can find the locus of maximal order and the locus of maximal order in the arithmetic case
EXAMPLE: example MaxOrdArith; shows an example
"
{
	
	int m; int p; int j; int i; int k; int member;
	//check whether input is allowed
	if(EqualityOfIdeal(IZ,IX)) {ERROR("IZ und IX duerfen nicht identisch sein!");}
	if(size(reduce(IZ,std(IX),1)) > 0) {            // IZ nicht in IX
		print(reduce(IZ,std(IX),1));
		~;
		print(reduce(IZ,std(IX)));
		ERROR("IZ muss in IX enthalten sein");
	}
	int checkIZ = 1;
	int limit_order = 0;
	list OldMaxOrdList;
	list OldMaxOrdListWithPrimes;
	int primedetected = 0;
	int OldMaxOrdDefined = 0;
	
	// check optional parameter
	if (size(#)!= 0){
		checkIZ = #[1];
		if (size(#) >= 2){
			if(typeof(#[2]) == "int"){
				limit_order = #[2];
			}
			if(typeof(#[2]) == "list"){
				OldMaxOrdList = #[2];
				if(size(OldMaxOrdList)>0){
					OldMaxOrdDefined = 1;
					for(i=1;i<=size(OldMaxOrdList);i++){
						primedetected = 0;
						for(j=1; j<=size(OldMaxOrdListWithPrimes);j++){
							if(OldMaxOrdListWithPrimes[j][1] == OldMaxOrdList[i][1]){
								primedetected = 1;
								OldMaxOrdListWithPrimes[j][2] = OldMaxOrdListWithPrimes[j][2] + OldMaxOrdList[i][2];
							}
						}
						if(primedetected == 0){
							OldMaxOrdListWithPrimes[size(OldMaxOrdListWithPrimes)+1] = OldMaxOrdList[i];
						}
					}
				}
			}
		}	
	}
	
	if(checkIZ == 1) {		//check whether input is permissible
		if(!EqualToZero(IZ)){
			int OrderOfIZ = MaxOrdArith(ideal(0),IZ,0)[1];
			if(OrderOfIZ > 1) {
				ERROR("IZ ist nicht zulässig");
			}
		}
	}

	def R = basering;
	int n = nvars(R);
	//ideal OldMaxOrdIdeal = 1;
	list tmpOldMaxOrdList;
	
	if(OldMaxOrdDefined == 1){
		for(i = 1; i<=size(OldMaxOrdListWithPrimes); i++){
			if(OldMaxOrdListWithPrimes[i][1] == 0){
				tmpOldMaxOrdList = delete(OldMaxOrdListWithPrimes[i],1);		//without the 0 at the beginning
			}
		}
	}
	int sizetmplist = size(tmpOldMaxOrdList);
	
	execute("ring RADRINGQ=(0),("+varstr(basering)+"),("+ordstr(basering)+");");
	//ideal IZ = imap(R,IZ);
	//ideal IX = imap(R,IX);
	ideal IZ = fetch(R,IZ);
	ideal IX = fetch(R,IX);
	if(sizetmplist > 0){
		list tmpOldMaxOrdList = fetch(R,tmpOldMaxOrdList);
	}
	if(limit_order != 0){
		list MaxOrd0 = MaxOrd(IZ,IX,limit_order);  //via imap nach Q
		if(MaxOrd0[4] == 1){
			return(1);
		}
	} else{
		if(sizetmplist > 0){
			list MaxOrd0 = MaxOrd(IZ,IX, tmpOldMaxOrdList);  //via imap nach Q
		}else{
			list MaxOrd0 = MaxOrd(IZ,IX);		//no optimation in minAssZ-call possible
		}
	}
	
	int maxord = MaxOrd0[1];
	
	if(limit_order > 0){
		if(maxord > limit_order){
			return(1);
		}
	}
	
	ideal Imax = MaxOrd0[2];
	list ImaxZerlegt;          // damit, falls MaxOrd(Char K = 0) nichts zurückgibt liste leer ist
	ImaxZerlegt = MaxOrd0[3];  // für ausgabe wenn horizontale komponenten im ort maximaler ordnung
  
	setring(R);
	
	ideal Imax = imap(RADRINGQ,Imax);     //Geschnitten Z[x]
	list RetList;
	RetList[1]= list(0,Imax);
	list PrimeList = InterestingPrimes(IZ,IX);
  
	list DiffList;
	
  
	execute("ring RADRING=("+charstr(basering)+"),("+varstr(basering)+",P),("+ordstr(basering)+",dp(1));");  //nur ein ringwechsel fuer alle for-schleifen notwendig.
	ideal IZ = imap(R, IZ);
	ideal IX = imap(R, IX);
	ideal Imax = imap(R,Imax);
	list RetList = imap(R,RetList);
	list IdealRetList; // stores values before calculating minAssZ in the end; entries: (p,Imax)
	list EmptyList;
  
	ideal JX; ideal JZ; ideal TmpIdeal;
	int locord; int s; int CoDimZ;
	matrix M; list y; matrix JJZ;
	list GeneratorList; list L1; list vectorsL1; list xP;

	ideal Itmp;
	list Imaxneu;
	
	for (j = 1; j <= size(PrimeList); j++) {
		p = PrimeList[j];
  
		JX = ReplaceCoeffsMaxOrdArith(std(IX),p);
		JZ = ReplaceCoeffsMaxOrdArith(IZ,p);
		if(EqualToZero(IZ)) {										//case IZ == 0
			for(i = 1; i<= nvars(RADRING); i++) {
				xP[i]=var(i);
			} 
			DiffList = HasseDeriv(JZ,JX,xP,0);
			m = size(DiffList);
			
			for (i = 1; i <= m; i++) {
				TmpIdeal = 0;
				for (k = 1; k <= size(DiffList[i]); k++) {
					DiffList[i][k] = ideal(subst(DiffList[i][k],var(n+1),p));
					TmpIdeal = TmpIdeal + ideal(DiffList[i][k]);
				}
				DiffList[i] = TmpIdeal;
			}
      
			while(EqualToOneOverZp(DiffList[m],p)) {
				m = m-1;
			}
			
			
			//Imaxneu = minAssZ(Imax); // readable output //redundante rechnung, da es in if-abfrage überschrieben wird???
			//check whether we have to glue or to substitute locus of max order
			if (m >= maxord) {
				Imax = DiffList[m];
				//substitute:
				if (m > maxord) {
					if(limit_order != 0){
						if(m > limit_order){
							return(1);
						}
					}
						
					IdealRetList = EmptyList;
					RetList = EmptyList;
					maxord = m;
					//RetList[1] = list(p,Itmp);
					IdealRetList[1] = list(p,Imax);
				//glueing:
				} else {
					//maxbe faster if we take the RetList size:
					if(size(RetList) == 0){				//only consider horiontal elements if there are some
						IdealRetList[size(IdealRetList)+1] = list(p,Imax);
					}
				}	
			}
      
		}else {														//case IZ !=0
		
			CoDimZ = Codimension(JZ);
        
			//Berechnung der Menge L:
			JJZ = jacob(JZ);
			//GeneratorList = GenerateL1(CoDimZ, JJZ,IX);
			GeneratorList = GenerateL1(CoDimZ, JJZ,JX,JZ);
			L1 = GeneratorList[1];
			vectorsL1 = GeneratorList[2];
      
			locord = 1;
			
			for (member = 1; member <= size(L1); member++) {
				M = L1[member];
				if (det(M) != 0) {
					//Parametersystem wie in char K = 0 
					y = SystemOfParameters(member, vectorsL1, CoDimZ);  
					DiffList = HasseDeriv(JZ,JX,y,M);
					m = size(DiffList);  
        
					for (i = 1; i<= m; i++) {
						DiffList[i] = ideal(subst(DiffList[i],P,p));
					}
          
					while(EqualToOneOverZp(DiffList[m],p)) {    //an Zp , zusätzlich prüfen, ob konstanter Teil des Ideals teilbar durch p, wenn nein, dann einheit.
						m = m-1;
						if (m == 0) {break;}
					} 
					m=m+1;
					//substitute Imax:
					if (m > locord) {
						Imax = DiffList[m-1];
						locord = m;
						
						if(limit_order != 0){
							if(locord > limit_order){
								return(1);
							}
						}
						
					} else {
						//glueing:
						if( m == locord) {
							Imax = intersect(Imax,DiffList[m]);
						}
					}
				}
				
			}
      
			if(limit_order == 0){ // only necessary if we need the output
				//better output:
				if (locord >= maxord) {
					if (locord > maxord) {
						RetList = EmptyList;
						IdealRetList = EmptyList;
						maxord = locord;
						IdealRetList[1] = list(p,Imax);
						//RetList[1] = list(p,Itmp);
					} else {
						if(size(RetList)==0){
							IdealRetList[size(IdealRetList)+1] = list(p,Imax);
						}
					}
				}
			}
		
		}//end case IZ != 0
	}// end for (InterestingPrimes)

	//calculate the minimal associated primes only once:
	if(limit_order == 0){		//only necessary if we are interested in the locus
		if(OldMaxOrdDefined == 0){
			for(i=1;i<= size(IdealRetList);i++){
				p = IdealRetList[i][1];
				Imaxneu = minAssZ(IdealRetList[i][2]);
				for(k=1; k<=size(Imaxneu); k++){
					Itmp = Imaxneu[k];
					RetList[size(RetList)+1] = list(p,Itmp);
				}
			}
		} else{
			//Optimization of minAssZ-call
			list OldMaxOrdListWithPrimes = imap(R,OldMaxOrdListWithPrimes);
			ideal OldMaxOrdIdeal = 1;
			ideal NewImaxComp = 1;
			ideal OldImaxComp = 1;
			for(i=1;i<= size(IdealRetList);i++){
				primedetected = 0;
				p = IdealRetList[i][1];
				OldMaxOrdIdeal = 1;
				NewImaxComp = 1;
				OldImaxComp = 1;
				for(j=1;j<= size(OldMaxOrdListWithPrimes);j++){
					if(OldMaxOrdListWithPrimes[j][1] == p){			//old component over the same prime 
						primedetected = 1;
						for(k=2; k<=size(OldMaxOrdListWithPrimes[j]);k++){ 
							OldMaxOrdIdeal = OldMaxOrdIdeal * OldMaxOrdListWithPrimes[j][k];	//calculating the corresponding ideal// no intersect ! because of ordering  
						}
					}
					if(primedetected == 1){		//comp over the fiber over p
						if(size(reduce(Imax,std(OldMaxOrdIdeal))) == 0){ // all old components plus the new components
							NewImaxComp = quotient(Imax,OldMaxOrdIdeal);
							Imaxneu = minAssZ(NewImaxComp);
							for(k=2;k<=size(OldMaxOrdListWithPrimes[j]);k++){
								Imaxneu = Imaxneu + list(OldMaxOrdListWithPrimes[j][k]);
							}
						} else{
							if(size(reduce(OldMaxOrdIdeal,std(Imax))) == 0){
								OldImaxComp = quotient(OldMaxOrdIdeal,Imax);
								Imaxneu = OldImaxComp;
							} else{ // no optimation on minAssZ-calls possible
								Imaxneu = minAssZ(Imax);
							}
						}
					}else{			//no old component over these fiber, no optimization possible
						Imaxneu = minAssZ(IdealRetList[i][2]);
					}
					for(k=1; k<=size(Imaxneu); k++){
						Itmp = Imaxneu[k];
						RetList[size(RetList)+1] = list(p,Itmp);
					}
				}
				
			}
		}
	}


	//ring OLDRING2 = R;                                //zurueck zum alten ring
	setring R;
	list TempList = imap(RADRING,RetList);
	RetList = imap(RADRING,RetList);

	
	if(!defined(ImaxZerlegt)){							//Für Beispiel 1, da lebt ImaxZerlegt überall und ist nicht am RADRINGQ gebunden
		list ImaxZerlegt = imap(RADRINGQ,ImaxZerlegt);
	}
	if(defined(RADRINGQ)){kill RADRINGQ;} 
	if(defined(RADRING)){kill RADRING;} 
	//replace locus of maximal order if there are horizontal components:
	if (TempList[1][1] == 0){
		TempList[1][2] = ImaxZerlegt;
		RetList = EmptyList;
		for(i = 1; i <= size(TempList[1][2]); i++){
			RetList[i] = list(0,TempList[1][2][i]);
		}
	}
	if(limit_order != 0){
		return(0);
	}
	return(list(maxord,RetList));
}
example
{"EXAMPLE:"; echo = 2;
  ring R = integer,(x,y,z),dp;
  ideal IZ = 0;
  ideal IX = ideal(7*z^3);
  MaxOrdArith(IZ,IX);

  IZ = ideal(x-4y+6z);
  IX = IZ+ideal(3x-y+7z);
  MaxOrdArith(IZ,IX);
}




proc maxordgreaterthanlimit(ideal IZ, ideal IX, int limit_order){
	int i = MaxOrdArith(IZ,IX,0,limit_order);
	return(i);
}

//----------------------------------------------------------------------

