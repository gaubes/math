version=" "; // $Id$
category=" ";
info="
LIBRARY:  hualgorithm.lib 
AUTHOR:  Sabrina Alexandra Gaube, sabrina.gaube@uol.de

PROCEDURES:
	HuAlgorithm(M); Hu's centercalculation starting with a matrix M
	ListForHU(M); converts Matrix with at most locally monomial entries of the form 1-x^A, x into a list
	HuCalc (L); calculates a sequence of centers in the sence of the Hu algorithm
	CalculateIntersectionLattice(L); calculates the intersection lattice of L as a list
	CalculateIntersectionLatticeIdeal(IntersectionLattice[i][j]); calculates the ideal to a corresponding intersection lattice entry
	
	deleteEmptyIntersections(SubsetList, EmptySubsetIndices); list S... list E... where we want to delete sublists of S which contains entries of E as sublist
	removeDuplicates(L); remove duplicate elements from a list L
";

LIB "maxord.lib";
LIB "redcgs.lib";			//sublists
LIB "primdec.lib";
LIB "resolve2.lib";			//transversalT

proc HuAlgorithm(matrix M)
"USAGE: HuAlgorithm(matrix M); M matrix
RETURN: the intersetion lattice of Hu's algorithm
EXAMPLE: example HuAlgorithm; shows an example
"
{
	list L;
	L = ListForHU(M);
	list IntersectionLattice = HuCalc(L);
	
	
	//TODO:
	// Add nongenerators to coveringlist
	// store last label components for the later covering:
	list coveringlist = IntersectionLattice[size(IntersectionLattice)];
	return(list(IntersectionLattice,coveringlist));
}
example
{ 	ring r = 0,(x,y),dp;
	matrix M[1][5] = x-1,y-1,xy-1,1,xy-1;
	HuAlgorithm(M);
}


proc ListForHU(matrix M)
"USAGE: ListForHU(matrix M); M matrix
RETURN: converts locally monomial entries of a matrix into a list without duplicates and without 1-entries
EXAMPLE: example ListForHU; shows an example
"
{						
	list L;
	int i,j;

	int ncol = ncols(M);
	int nrow = nrows(M);
	poly f;

	for(i = 1;i<= nrow; i++){
		for(j=1;j<=ncol; j++){
			f = radical(M[i,j])[1];

			if(MaxOrd(0,f)[1] == 1){					// f = 1-x^A or x
				if(f != 1){		
					L = AppendListToList(L,list(f));	//no duplicates
				}
			}else{
				if(size(f) == 1 and f!= 1){
					L = AppendListToList(L,list(f));	//no duplicates
				}
			}	
		}
	}

	int sizeMinAss;
	list MinAss;
	int sizeL = size(L);
														//change non-irreducible entries: [n]: xy-> [n]: x, [last]: y
	for(j=1; j<=sizeL; j++){							// Do not change sizeL in the for-loops for not consider the newest elements
		MinAss = minAssGTZ(L[j]);
		sizeMinAss = size(MinAss);
		if(sizeMinAss > 1){
			L[j] = poly(MinAss[1][1]);
			for(i=2; i<=sizeMinAss; i++){
				L[size(L)+1] = poly(MinAss[i][1]);
			}
		}
	} 
	print("HuListe");
	print(L);
	return(L);											
}
example
{ "EXAMPLE:"; echo = 2;
	ring r = 0,(x,y),dp;
	matrix M[1][6] = x-1,y-1,xy-1,1,xy-1,xy;
	ListForHU(M);
}





proc HuCalc (list L)
"USAGE: HuCalc(list L); list L of locally monomials
RETURN: Calculates the intersection Lattice in the sense of Hu
EXAMPLE: example HuCalc; shows an example
"
{
	list IntersectionLattice = CalculateIntersectionLattice(L);
	list Centerlist = list();
	int level = size(IntersectionLattice);
	int i, j, k;

	//Init Data structure and CenterList:
	for(i =1;i<=level; i++){
		Centerlist[i] = list();
		for(j=1;j<=size(IntersectionLattice[i]);j++ ){
			Centerlist[i][j] = CalculateIntersectionLatticeIdeal(IntersectionLattice[i][j]);	 
		}
	}
	return(Centerlist);
}example
{ "EXAMPLE:"; echo = 2;
	ring r = 0,(x,y),dp;
	list L = list(x-1,y-1,xy-1);
	HuCalc(L);
}


proc CalculateIntersectionLattice(list L1)
"USAGE: CalculateIntersectionLattice(list L); list L of locally monomials
RETURN: Calculates the intersection Lattice as a list of lists
EXAMPLE: example CalculateIntersectionLattice; shows an example
"{
	list IntersectionLattice = list();
	IntersectionLattice[1] = list();
	ideal IntersectionLatticeIdeal;
	int i = 1;
				
	int emptyOrOrigin = 0;
	int j = 1; int k;
	list L = removeDuplicates(L1);						//remove duplicates
	
	int sizeL = size(L);
	ideal ListIdeal;
	
	for(j=1;j<=sizeL;j++){
		ListIdeal = ListIdeal+ poly(L[j]);
	}
		
	//int n = nvars(basering);	//change to codimension of the ideal generated by the list L1			
	int n = Codimension(ListIdeal);
	int NotEmpty = 0;

	for(j=1;j<=sizeL; j++){								//remove 1-Entries of L
		if(L[j] == 1){
			L = delete(L,j);
			sizeL = size(L);
			j--;
		}
	}
	
	int sizeMinAss;
	list MinAss;
														//change non-irreducible entries: [n]: xy-> [n]: x, [last]: y
	for(j=1; j<=sizeL; j++){							// Do not change sizeL in the for-loops for not consider the newest elements
		MinAss = minAssGTZ(L[j]);
		sizeMinAss = size(MinAss);
		if(sizeMinAss > 1){
			L[j] = poly(MinAss[1][1]);
			print("MinAss");
			print(MinAss);
			for(k=2; k<=sizeMinAss; k++){
				L[size(L)+1] = poly(MinAss[k][1]);
			}
		}
	} 
	
	L = removeDuplicates(L);								//maybe new duplicates were constructed
	sizeL = size(L);
	
	for(j=1;j<=sizeL;j++){
		IntersectionLattice[i][j] = L[j];
		if (NotEmpty == 0 and L[j] != 1){
			NotEmpty = 1;
		}
	}

	if(NotEmpty == 0){
		emptyOrOrigin = 1;
		return(IntersectionLattice);
	}

	i++;
	list SubsetList = list();
	int sizeSubsetList = size(SubsetList);
	list EmptySubsetIndices = list();									//for optimization: store the maximal indices with an empty intersection
	
	int current_size;
	while(emptyOrOrigin == 0){
		// HIer abbrechen, wenn snc -> für 2 hyperflächen reicht  hier paarweise transversal und glatt
		NotEmpty = 0;
		emptyOrOrigin = 0;	
		// calculate IntersectionLattice 
		SubsetList = subsets(sizeL,i);    		// list of tuples of indices
		SubsetList = deleteEmptyIntersections(SubsetList,EmptySubsetIndices);
		
		sizeSubsetList = size(SubsetList);		// only need to be calculated once 
		IntersectionLattice[i] = list();
		
		for(j=1;j<=sizeSubsetList;j++){
			current_size = size(IntersectionLattice[i])+1;
			IntersectionLattice[i][current_size] = list();
			for(k=1; k<= i; k++){
				//if (L[SubsetList[j][k]] != 1){
					IntersectionLattice[i][current_size][size(IntersectionLattice[i][current_size])+1] = L[SubsetList[j][k]];	// Add polynomial with the right index
				//}
			}
			
			IntersectionLatticeIdeal = CalculateIntersectionLatticeIdeal(IntersectionLattice[i][current_size]);
			if(EqualityOfIdeal(IntersectionLatticeIdeal,1) == 1){
				//delete empty ideal
				IntersectionLattice[i] = delete(IntersectionLattice[i],current_size);
				EmptySubsetIndices[size(EmptySubsetIndices)+1] = SubsetList[j];										
			}
			
		}
		//j--;								// else: out of range
		//IntersectionLatticeIdeal = CalculateIntersectionLatticeIdeal(IntersectionLattice[i][j]);
		//if(EqualityOfIdeal(IntersectionLatticeIdeal,1) == 0){
		if(size(IntersectionLattice[i]) > 0){
			print("Set not empty");
			print(IntersectionLattice);
			print(i);
			NotEmpty = 1;
		}
		
		//}
		
		
		//Hierwird zu viel gelöscht!!!
		if(NotEmpty == 0 or (size(L) == i)){		//Termination
			emptyOrOrigin = 1;
			if(NotEmpty == 0){
				print("Lösche letztes IntersectionLattice element");
				print(IntersectionLattice);
				print("------------");
				IntersectionLattice = delete(IntersectionLattice,size(IntersectionLattice));
				print("Letztes element gelöscht:");
				print(IntersectionLattice);
				print("------------");
			}
		}	
		i++;
	}

	print("Intersectionlattice complete:");
	print(IntersectionLattice);

	//Delete superfluent components with less or equal n Elements
	for(i=1;i<=n;i++){
		if(size(IntersectionLattice)>=i){
			for(j=1;j<=size(IntersectionLattice[i]);j++){
				print("all pairwise list");
				print(IntersectionLattice[i]);
				if(allPairwiseTransversal(IntersectionLattice[i][j])){
				// snc component
					IntersectionLattice[i] = delete(IntersectionLattice[i],j);
					j--;
				}
			}
		}
	}
	
	list EmptyList = list();
	print(IntersectionLattice);
	print("Lösche emtpylists aus Hu");
	
	
	// A single empty list at the beginning is enough!
	for(i=1;i<n;i++){
		sizeL = size(IntersectionLattice);
		if(size(IntersectionLattice) == 1){ break; }
		if((EqualityOfList(IntersectionLattice[1],EmptyList) ==1) and (EqualityOfList(IntersectionLattice[2],EmptyList) ==1)){
			IntersectionLattice = delete(IntersectionLattice,2);
		}
	}

	return(IntersectionLattice);
}example
{ "EXAMPLE:"; echo = 2;
	ring r = 0,(x,y,z),dp;
	//list L = list(x-1,y-1,xy-1,1,xy-1);
	//CalculateIntersectionLattice(L);
	list L;
	//L = list(x-1,y-1,xy-1,xy);
	//CalculateIntersectionLattice(L);
	L = list(x-1,y-1,xy-1);
	CalculateIntersectionLattice(L);
}

proc allPairwiseTransversal(list L){
	int i,j;
	int sizeL = size(L);
	int pairwiseTransversal = 1;
	list tmplist;

	for (i=1; i<=sizeL; i++){
		tmplist = delete(L,i);
		if(transversalT(L[i],tmplist) == 0){
			pairwiseTransversal = 0;
			return(pairwiseTransversal);
		}
	}
	return(pairwiseTransversal);
}

proc CalculateIntersectionLatticeIdeal(list IntersectionLattice)
"USAGE: CalculateIntersectionLatticeIdeal(list IntersectionLattice); entry of the Intersectionlattice for which we want to calculate the ideal corresponding to 
RETURN: Calculates an ideal corresponding to an entry of the IntersectionLattice
EXAMPLE: example CalculateIntersectionLatticeIdeal; shows an example
"{
	ideal IntersectionLatticeIdeal = IntersectionLattice[1];
	int i;

	for(i=2;i<= size(IntersectionLattice); i++){
		IntersectionLatticeIdeal = ideal(IntersectionLatticeIdeal) + ideal(IntersectionLattice[i]);
	}

	return(IntersectionLatticeIdeal);
}example
{ "EXAMPLE:"; echo = 2;
	ring r = 0,(x,y),dp;
	list L = list(x-1,y-1,xy-1);
	list IntersectionLattice = CalculateIntersectionLattice(L);
	CalculateIntersectionLatticeIdeal(IntersectionLattice[2][2]);
}


proc deleteEmptyIntersections(list SubsetList, list EmptySubsetIndices)
"USAGE: deleteEmptyIntersections(list SubsetList, list EmptySubsetIndices); list S... list E... where we want to delete sublists of S which contains entries of E as sublist
RETURN: SubsetList without sublists which contains entries of EmptySubsetIndices
EXAMPLE: example deleteEmptyIntersections; shows an example
"{
	int i,j,k;
	
	for(i=1; i<=size(EmptySubsetIndices); i++){
		for(j=1;j<=size(SubsetList);j++){
			if(subset(EmptySubsetIndices[i], SubsetList[j]) == 1){										//is E... a sublist of S...?
				SubsetList = delete(SubsetList,j);
				j--;
			}
		}
	}
	
	
	return(SubsetList);
}example
{ "EXAMPLE:"; echo = 2;
	ring r = 0,(x,y),dp;
	list S = subsets(4,3); 
	list E = list(3,4);
	deleteEmptyIntersections(S,E);
}

proc removeDuplicates(list L)
"USAGE: removeDuplicates(list L); list L with or without duplicates
RETURN: same list without duplicates
EXAMPLE: example removeDuplicates; shows an example
"{
	int i,j;
	for(i=2;i<=size(L);i++){
		for(j=1; j<i; j++){
			if(L[i] == L[j]){
				L = delete(L,i);
				i--;
			}
		}
	}
	
	return(L);
}example
{ "EXAMPLE:"; echo = 2;
	ring r = 0,(x,y),dp;
	list L = list(x-1,y-1,xy-1,1,xy-1,1);
	removeDuplicates(L);
}
