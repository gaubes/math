version=" "; // $Id$
category=" ";
info="
LIBRARY:  resbinomial_neu.lib 
AUTHOR:  Sabrina A. Gaube, sabrina.gaube@uol.de

PROCEDURES:
	resbinomial2(ideal J); resolves a binomial ideal J

	DescendInDimension(list BO); calculates the coefficient ideals; apply induction on dimension 
	descend_finished(list CoeffBO); checks whether the descend in dimension is finished
	isSmooth(list BO);	checks whether BO[2] is smooth.  
	
	SuccessorsCharts(list BO, ideal cent, int chartnumber); blow up method which fill the necessary data in the successor chart
	
	proc UpdateBO7(intvec new_b,intvec old_b,list BO);	update the information about the interesting exceptional divisors
";


LIB "resolve2.lib";
LIB "maxord.lib";

proc resbinomial2(ideal J)
"USAGE: resbinomial2(ideal J); resolves a binomial ideal J
RETURN: a list of final charts and whole charts of the resolution process
EXAMPLE: example resbinomial2; shows an example
"
{
	def r = basering;
	list BlowUpTree;
	BlowUpTree[1] = r;
	list EndCharts = list();
	int i,j,k;
	
	list BO = createBO(J);
	list descend = DescendInDimension(BO);
	list descend_BOlist = descend[1];
	intvec b = descend[2];
	//BO[3] = b;
	BO = descend_BOlist[1];
	//descend_BOlist[1][3] = b;			//GGF überall einen b-eintrag  mit entsprechend kleinerer größe einfügen
	ideal center = descend[3];
	//ideal center = resbinomialCenter(BO,b);
	//ideal center = descend_BOlist[size(descend_BOlist)][2];
	
	if(EqualityOfIdeal(center,1) == 1){								//Reicht das als abbruch Bedingung?
		EndCharts[1] = BlowUpTree[1];
	}else{
		BlowUpTree = BlowUpTree + SuccessorsCharts(BO, center, 1);
	}
	//TODO
	for(i=2; i<= size(BlowUpTree); i++){
		print(i);
		if(defined(actual_chart)){kill actual_chart;} 
		def actual_chart = BlowUpTree[i];
		setring(actual_chart);
		
		intvec b_old = BO[3];
		list descend = DescendInDimension(BO);
		list descend_BOlist = descend[1];
		intvec b_new = descend[2];
		ideal center = descend[3];
		//BO[7] = UpdateBO7(b_new,b_old,BO); // hier das unterste!!! BO nehmen um die Anzahl der exzeptionellen Divisoren zu erhalten!!!					
		// auf jeder Stufe im Abstieg BO7 hinzufügen
		//WO im Code?
		//for(j=1;j<=size(descend_BOlist);j++){
		//	descend_BOlist[j][7] = list();
		//	for(k=j;size(descend_BOlist);k++){
		//		descend_BOlist[j][7][size(descend_BOlist[j])+1] = BO[7][k];
		//	}
		//}
		b = b_new;
		BO[3] = b_new;
		
		//ideal center = resbinomialCenter(BO,b);
		//ideal center = descend_BOlist[size(descend_BOlist)][2];
		//if(finished(BO))
		if(EqualityOfIdeal(center,1) == 1){								//Reicht das als abbruch Bedingung?
			EndCharts[size(EndCharts)+1] = BlowUpTree[i];
		}else{
			BlowUpTree = BlowUpTree + SuccessorsCharts(BO, center, i);
		}
	}

	
	return(EndCharts,BlowUpTree);
}example{
	ring r = 0,(x,y,z),dp;
	ideal J = z2-x2y2;
	resbinomial2(J);
}


proc DescendInDimension(list BO) // TODO: combine Update BO and DescendInDimension!
"USAGE: DescendInDimension(list BO); calculates the coefficient ideals; apply induction on dimension 
RETURN: a list basic objects corresponding to the different coefficient ideals and an intvec b with the values of the correspoding orders 
EXAMPLE: example DescendInDimension; shows an example
"{
	int j,k;
	list CoeffBOList;
	CoeffBOList[1] = BO;
	list BOtmp = BO;
	intvec b_old = BO[3];
	
	list DList = DeltaList(BOtmp);
	int btmp = size(DList);
	ideal center = DList[btmp];
	intvec b  = btmp;	
	int counter = 0;
	list E;
	intvec BO7new;
	intvec BO7old = BO[7];
	
	
	int orderdecreased = 0;
	if(b[1] == b_old[1]){
		BO7new[1] = BO7old[1];
	}	
	if(b[1] < b_old[1]){
		BO7new[1] = size(BOtmp[4]);
		orderdecreased = 1;
	}
	
	BOtmp[7] = BO7new;
	list E = inters_E(BOtmp);
	CoeffBOList[1][2] = mstd(E[1]^b[1] + CoeffBOList[1][2])[2];
	center = std(DList[btmp]+E[1]);
	
	while(descend_finished(DList, CoeffBOList[size(CoeffBOList)], counter) == 0){	
		//TODO: Nochmal neu schreiben! Reihenfolge beachten und BO7 mitsetzen!			
		BOtmp = Coeff(BOtmp,b[size(b)]);
		CoeffBOList[size(CoeffBOList)+1] = BOtmp;

		// Erst Deltalist und b berechnen, dann schneiden dann coeff berechnen!!!!
		DList = DeltaList(BOtmp);
		btmp = size(DList);		
		b[size(b)+1]  = btmp;
		//BO7 auf jeder Stufe hinzufügen für inters_E
		//hier irgendwie BO7 anpassen....
		if(orderdecreased == 0 and (size(b_old) >= counter+2)){ 
			if(b[counter+2] == b_old[counter+2]){
				BO7new[counter + 2 ] = BO7old[counter + 2];
			}
		
			if(b[counter+2] < b_old[counter+2]){						//TODO!!!! Wann BO7 updaten und wann schneiden??? indexshift???
				BO7new[counter+1] = size(BOtmp[4]);						//Kreisabhaengigkeit?!?!
				orderdecreased = 1;
				BO7new[counter+2] = -1;
			}
		} else{
			BO7new[counter + 2 ] = -1;
		}
		
		BOtmp[7][1] = BO7new[counter + 2 ];
		E = inters_E(BOtmp);
		CoeffBOList[counter+2][2] = mstd(E[1]^b[counter+2] + CoeffBOList[counter+2][2])[2];
		center = std(DList[btmp]+E[1]);
		counter++;
	}
	if(EqualityOfIdeal(center, BO[2])){					//Reicht das?
		center = 1;
	}

	//BO7 und b auf allen Leveln neusetzen:
	for(j=1;j<=size(BO7new);j++){
		CoeffBOList[j][7] = intvec(BO7new[j..size(BO7new)]);
	}
	for(j=1;j<=size(b);j++){
		for(k=1;k<=size(b);k++){	
			CoeffBOList[j][3][k] = b[k];
		}
	}
			

	return(CoeffBOList,b,center);						//TODO: Schauen, ob wir oberstes BO auch in der Liste haben wollen
		
}

proc descend_finished(list DList, list CoeffBO, int descentdim)
"USAGE: descend_finished(list CoeffBO); requires the last coefficient basic object as input 
RETURN: 0, if the descend is not finished, 1 if the potential center  is a point, 2 if the input was zero, 3 if the correct center was calculated in the step before, 4 if the potential center is smooth and snc with the exceptional divisors
EXAMPLE: example descend_finished; shows an example
"{	

	//ToDo: zentrum muss punkt in hyperfläche maximalen kontakts sein!!!!!!!
	
	int btmp = size(DList);
	ideal ctemp = DList[btmp];					
	//if(dim(ctemp) - descentdim == 0)							// point -> correct center
	if(dim(ctemp) == 0){
		return(1);
	}
	if(EqualityOfIdeal(CoeffBO[2],0) == 1){					// input was zero
		return(2);
	}
	if(EqualityOfIdeal(CoeffBO[2],1) == 1){					// correct center was calculated in the step before
		return(3);
	}
	if(btmp == 1  && normalCross(ctemp,CoeffBO[4]) == 1){			// isSmooth(C) and snc(C,E);
		return(4);
	}
	return(0);												// not finished
}

proc isSmooth(btmp)		//TODO wie die ordnung abfangen?
"USAGE: isSmooth(list BO); checks whether BO[2] is smooth 
RETURN: 1, if it is smooth, 0 otherwise
EXAMPLE: example isSmooth; shows an example
"
{								//TODO: so oder anders?
	
	if(btmp == 1){
		return(1);
	}
	return(0);
}


//Blowing up each of the data and mapping each of it into new successor ring:
proc SuccessorsCharts(list BO, ideal cent, int chartnumber)
"USAGE: SuccessorsCharts(list BO, ideal cent, int chartnumber); Basic object BO, center cent and the number of the current chart chartnumber
RETURN: a list of successor charts with the corresponding data
EXAMPLE: example SuccessorsCharts; shows an example
"
{	
	int i,j,k,n;

	def r = basering;
	list successor_list = list();
	//TODO define: int numb_predecessor for the path matrix 
	// intmat path [2][numb_predecessor+1];
	successor_list = blowUpBO(BO,cent,2);
	int Numb_sucessors = size(successor_list);
	
	

	// construct successorlist
	for(j = 1;j<=Numb_sucessors; j++){
		if(defined(newring)){kill newring;}
		def newring = successor_list[j];
		setring(newring);
		n = nvars(basering);
		//tmp_n = n;
		ideal bM=BO[5];	//aus resolve.lib abgeschrieben
		map BlowUpMap = r,bM;
		//TODO: Was muss alles übertragen werden?
		ideal last_map = bM;
		//ideal total_map = BlowUpMap(total_map);
		//def path = imap(r,path);
		//path=path,[chartnumber,j];
		//TODO: mehr exportieren?
		//export(path);
		export(last_map);
		//export(total_map);
	}

	setring(r);
	
	if(defined(newring)){kill newring;}	
	return(successor_list);
}





proc UpdateBO7(intvec b_new,intvec b_old,list BO){
	int i,j;
	// ersetze BO-list im Input durch den gesamten Abstieg? -> Dann ist hier auch klar, dass wir das originale BO in der Abstiegsliste brauchen
	// auf jeder Stufe im Abstieg BO7 hinzufügen!
	list E = BO[4]; // TODO!!!! wir brauchen eigentlich das 'richtige E' von position b_decrease_pos hier!!!!

	
	//finding position in b_new where the order drops
	int b_decrease_pos; 
	for(i=1;i<=size(b_new);i++){
		if(b_new[i] < b_old){
			b_decrease_pos = i;
		}
	}
	//if b_new is shorter than b_old???
	if(b_decrease_pos == 0){print("Ordnung ist nicht gefallen!"); ~;}
	

	intvec BO7 = BO[7];
	intvec newBO7;
	//copy first values of BO7 where the order is constant
	for(i = 1; i<b_decrease_pos; i++){
		newBO7[i] = BO7[i];
	}
	

	//set BO[7][b_decrease_pos]
	newBO7[b_decrease_pos] = size(E);
	
	//update last values of BO[7]
	for(i = b_decrease_pos +1; i<= size(b_new);i++){
		newBO7[i] = -1;
	}	
	
	BO[7] = newBO7;
	return(BO)
}

proc resbinomialCenter(list BO,intvec b){
	//not necessary 
}
