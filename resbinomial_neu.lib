version=" "; // $Id$
category=" ";
info="
LIBRARY:  resbinomial_neu.lib 
AUTHOR:  Sabrina A. Gaube, sabrina.gaube@uol.de

PROCEDURES:
	resbinomial2(ideal J); resolves a binomial ideal J

	DescendInDimension(list BO); calculates the coefficient ideals; apply induction on dimension 
	descend_finished(list CoeffBO); checks whether the descend in dimension is finished
	isSmooth(list BO);	checks whether BO[2] is smooth.  
	
	SuccessorsCharts(list BO, ideal cent, int chartnumber); blow up method which fill the necessary data in the successor chart
	
	proc UpdateBO7(intvec new_b,intvec old_b,list BO);	update the information about the interesting exceptional divisors
";


LIB "resolve2.lib";
LIB "maxord.lib";


proc resbinomial2(ideal J)
"USAGE: resbinomial2(ideal J); resolves a binomial ideal J
RETURN: a list of final charts and whole charts of the resolution process
EXAMPLE: example resbinomial2; shows an example
"
{
	def r = basering;
	module path = [0,-1];										//path of the current chart, autoconverted to matrix
	export(path);
	list BlowUpTree;
	BlowUpTree[1] = r;
	list EndCharts = list();
	int i,j,k;
	
	list BO = createBO(J);
	list descend = DescendInDimension(BO);
	list descend_BOlist = descend[1];
	intvec b = descend[2];
	//BO[3] = b;
	BO = descend_BOlist[1];
	//descend_BOlist[1][3] = b;			//GGF überall einen b-eintrag  mit entsprechend kleinerer größe einfügen
	ideal center = descend[3];
	
	if(EqualityOfIdeal(center,1) == 1){								//Reicht das als abbruch Bedingung?
		EndCharts[1] = BlowUpTree[1];
	}else{
		BlowUpTree = BlowUpTree + SuccessorsCharts(BO, center, 1);
	}
	for(i=2; i<= size(BlowUpTree); i++){
		print(i);
		if(defined(actual_chart)){kill actual_chart;} 
		def actual_chart = BlowUpTree[i];
		setring(actual_chart);
		
		if(EqualityOfIdeal(BO[2],1) == 1){
			ideal center = 1;		//finished
		}else{	
			if(i==3){~;}
			list descend = DescendInDimension(BO);
			list descend_BOlist = descend[1];
			intvec b_new = descend[2];
			ideal center = descend[3];
			
			//if (i == 4 or i == 10 or i == 20){
			print("center:");
			print(center);
			descend_BOlist;
			//}
		}
		print(path);
		if(EqualityOfIdeal(center,1) == 1){								//Reicht das als abbruch Bedingung?
			EndCharts[size(EndCharts)+1] = BlowUpTree[i];
		}else{
			BlowUpTree = BlowUpTree + SuccessorsCharts(descend_BOlist[1], center, i);
			if(i == 3 or i == 5){center;}
		}
	}

	
	return(EndCharts,BlowUpTree);
}example{
	ring r = 0,(x,y,z),dp;
	ideal J = z2-x2y2;
	resbinomial2(J);
}

proc DescendInDimension(list BO) 
"USAGE: DescendInDimension(list BO); calculates the coefficient ideals; apply induction on dimension 
RETURN: a list basic objects corresponding to the different coefficient ideals and an intvec b with the values of the correspoding orders 
EXAMPLE: example DescendInDimension; shows an example
"{
	int j,k;
	list CoeffBOList;
	CoeffBOList[1] = BO;
	list BOtmp = BO;
	intvec b_old = BO[3];	
	list DList = DeltaList(BOtmp);
	int btmp = size(DList);
	ideal center = DList[btmp];
	intvec b;
	b[1] = btmp;	
	int counter = 0;
	intvec BO7new;
	intvec BO7old = BO[7];
	
	
	int orderdecreased = 0;
	if(b[1] == b_old[1]){
		BO7new[1] = BO7old[1];
	}	
	if(b[1] < b_old[1]){
		BO7new[1] = size(BOtmp[4]);
		orderdecreased = 1;
	}
	
	BOtmp[7] = BO7new;
	list E = inters_E(BOtmp);
	CoeffBOList[1][2] = mstd(E[1]^b[1] + CoeffBOList[1][2])[2];
	center = std(DList[btmp]+E[1]);
	
	list CoeffList;
	ideal Icontrol;
	list BOcontrol;
	int casenumber;
	
	while(descend_finished(center, btmp, CoeffBOList[size(CoeffBOList)], counter) == 0){		
		CoeffList = Coeff(BOtmp,b[size(b)]);
		BOtmp = CoeffList[1];
		Icontrol = CoeffList[2];

		BOcontrol = BOtmp;
		BOcontrol[2] = Icontrol;
		BOcontrol[3] = size(DeltaList(BOcontrol));
		CoeffBOList[size(CoeffBOList)+1] = BOtmp;
		casenumber = IsMonomialCase(BOtmp,DList,counter);
		
		if(casenumber == 2){
			//Intersection of basic objects (W,(\overline{J},b'),E) \cap (W,(J,b),E) =  (W,(\overline{J}^b+J^{b'},bb'),E) 
			BOtmp[2] = BOtmp[2]^BOcontrol[3] + BOcontrol[2] ^b[size(b)];
			BOtmp[3] = b[size(b)] * BOcontrol[3];
		}


		if(casenumber == 1 or casenumber == 2){				
			// Erst Deltalist und b berechnen, dann schneiden dann coeff berechnen!!!!
			DList = DeltaList(BOtmp);
			btmp = size(DList);		
			b[size(b)+1]  = btmp;
			//BO7 auf jeder Stufe hinzufügen für inters_E
			if(orderdecreased == 0 and (size(b_old) >= counter+2)){ 
				if(b[counter+2] == b_old[counter+2]){
					BO7new[counter + 2 ] = BO7old[counter + 2];
					
				}
		
				if(b[counter+2] < b_old[counter+2]){						
					BO7new[counter+1] = size(BOtmp[4]);						//too many intersections but not a problem
					orderdecreased = 1;
					BO7new[counter+2] = 0;		//ggf aendern. vorher war hier -1
				}
			} else{
				BO7new[counter + 2 ] = -1;
			}
		
			BOtmp[7][1] = BO7new[counter + 2 ];
			E = inters_E(BOtmp);
			CoeffBOList[counter+2][2] = mstd(E[1]^b[counter+2] + CoeffBOList[counter+2][2])[2];
			center = std(DList[btmp]+E[1]);
			counter++;
		}
		if(casenumber == 3){
			center = monomialCase(BOcontrol,DList);
		}
	}
	if(EqualityOfIdeal(center, BO[2])){					//Reicht das als Abbruchkriterium???
		center = 1;
	}

	//reset BO7 and b in all levels of descend in dimension:
	for(j=1;j<=size(BO7new);j++){
		CoeffBOList[j][7] = intvec(BO7new[j..size(BO7new)]);
	}
	for(j=1;j<=size(b);j++){
		for(k=1;k<=size(b);k++){	
			CoeffBOList[j][3][k] = b[k];
		}
	}

	return(CoeffBOList,b,center);						
		
}

proc descend_finished(ideal ctemp, int btmp, list CoeffBO, int descentdim) 
"USAGE: descend_finished(list CoeffBO); requires the last coefficient basic object as input 
RETURN: 0, if the descend is not finished, 1 if the potential center  is a point, 2 if the input was zero, 3 if the correct center was calculated in the step before, 4 if the potential center is smooth and snc with the exceptional divisors
EXAMPLE: example descend_finished; shows an example
"{	

	//ToDo: zentrum muss punkt in hyperfläche maximalen kontakts sein!!!!!!!
	
	//int btmp = size(DList);
	//ideal ctemp = DList[btmp];					
	//if(dim(ctemp) - descentdim == 0)							// point -> correct center
	if(dim(ctemp) == 0){
		return(1);
	}
	if(EqualityOfIdeal(CoeffBO[2],0) == 1){					// input was zero
		return(2);
	}
	if(EqualityOfIdeal(CoeffBO[2],1) == 1){					// correct center was calculated in the step before
		return(3);
	}
	if(btmp == 1  && normalCross(ctemp,CoeffBO[4]) == 1){		//isSmooth passt noch nicht!!!	// isSmooth(C) and snc(C,E);
		return(4);
	}
	return(0);												// not finished
}

proc IsMonomialCase(list BO, list DList, int counter){		//Change to: detectCase und return 1,2,3 like in BEV
 	int b = size(DeltaList(BO));
 	//Situation 1:
 	if(b >= factorial(size(DList))){
		return(1);
	}
	 //Situation 2: 
 	if(1 < b and b < size(DList)){
		return(2);
	}
 	
	//Monomial case: // eigentlich reicht hier direkt ein else return(3)
	if(EqualityOfIdeal(BO[2],1) == 1){
		return(3);
	}	
	ideal J = DList[size(DList)];
	int sizeJ = size(J);
	if(sizeJ == 1){					// only one generator
		if(size(J[1]) == 1){		//the single generator is a monomial
			return(3);	
		}
	} 
}
//TODO: Change the names of the different lists!!!
proc monomialCase(list BO, list DList){				//requires that DList.last is generated by a single monomial 
	def r = basering;
	int n = nvars(r);
	int j,k,l;
	
	int b = BO[3][1]; 				// steht hier das richtige b drin?
	
	ideal J = std(reduce(BO[2],BO[1]));
	list Explist = leadexp(J[1]);
	list retListtmp;
	retListtmp[1] = list();
	list tmplist;

	for (j=1; j<= n;j++){
		retListtmp[1][j] = Explist[1][j]; 
	}

	if (SumList(retListtmp[1]) > b ){
		for(l = 1; l<= n;l++){														//im schlimmsten fall n-mal ausnullen
			for(k=1;k<=size(retListtmp);k++){										//in jeder Liste
				for(j=1; j<= n;j++){												//nulle eintrag j aus, sofern notwendig
					if(retListtmp[k][j] != 0){
						if(SumList(retListtmp[k]) >= (b + retListtmp[k][j])){			//entry [k][j] superfluent
							tmplist = retListtmp[k];
							tmplist[j] = 0;
							retListtmp[size(retListtmp)+1] = tmplist;
						}
					}
				}
			}
		}
	} else{		//only one unique center is possible
		ideal center;
		for(j=1; j<=size(retListtmp[1]); j++){
			if(retListtmp[1][j] != 0){
				//center[j] = var(j)^retListtmp[1][j];		//warum potenz setzen?
				center[j] = var(j);
			}
		}
		//add ambient space to center
		center = center + BO[1];
		return(center);
	}

	//Delete entries of not minimal codimension:
	list retList = list();
	int minCodim = NumbNotZeroEntries(retListtmp[1]);
	
	for(k = 2; k<= size(retListtmp); k++){
		if(NumbNotZeroEntries(retListtmp[k]) == minCodim){
			retList[size(retList)+1] = retListtmp[k];
		}
		if(NumbNotZeroEntries(retListtmp[k]) < minCodim){
			minCodim = NumbNotZeroEntries(retListtmp[k]);
			retList = list();
			retList[1] = retListtmp[k];
		}
	}

	//Only keep the ones with maximal exponents:
	int maxsum;
	list tmplist;
	for (k = 1;k<=size(retList); k++){
		if(SumList(retList[k]) == maxsum){
			tmplist[size(tmplist)+1] = retList[k];
		}
		if(SumList(retList[k]) > maxsum){
			maxsum = SumList(retList[k]);
			tmplist = list();
			tmplist[1] = tmplist[k];
		}
	}
	
	//calculate indexlists for l(\xi) in the monomial case of Villamayor
	list indexlists = CreateIndexListsMonomialcase(tmplist);
	// berechne k, welches lexikographisch maximal unter den indexlisten ist
	list smallestlist = indexlists[1];
	int currentindex = 1;
	for(k=2;k<= size(indexlists);k++){
		smallestlist = smallerList(indexlists[k],smallestlist);
		if(smallestlist[2] == 1){
			currentindex = k;
		}
	}
	//in indexlists the entry currentindex is the minimal entry, so tmplist[currentindex] is the minimal leadexp
	// transformiere anschließend zurück zu k-ter irreduzibler komponente, welche dem Zentrum entspricht!
	ideal center;
	for(j=1; j<=size(indexlists[currentindex]); j++){
		if(indexlists[currentindex][j] != 0){
			center[j] = var(j)^indexlists[currentindex][j];
		}
	}
	print("vorher");
	center;
	//add ambient space to center
	center = center + BO[1];
	print("nachher");
	center;	
	
	return(center);
}


proc CreateIndexListsMonomialcase(list L){ 		//retlist[k] corresponds to L[k]!
	def r = basering;
	int n = nvars(r);
	int j,k;
	list retlist = list();
	
	for(k = 1;k<=size(L);k++){
		retlist[k] = list();
		for(j=1;j<=n;j++){
			if(L[k][j] != 0){
				retlist[k][size(retlist[k])+1] = j;
			}
		}
	}
	return(retlist);	
}


proc SumList(list L){
	int sum = 0;
	int i;
	for(i=1;i<=size(L);i++){
		sum = sum + L[i];
	}
	return(sum);
}

proc NumbNotZeroEntries(list L){
	int counter = 0;
	int i;
	
	for(i=1; i<=size(L); i++){
		if(L[i] != 0){
			counter++;
		}
	}
	return(counter);
}


proc smallerList(list L1, list L2){
	int i;
	int minsize = min(size(L1),size(L2));
	for (i = 1;i<= minsize; i++){
		if(L1[i]< L2[i]){
			return(L1,1);
		}
		if(L2[i] < L1[i]){
			return(L2,2);
		}
	}
	if(size(L1)<size(L2)){
		return(L1,1);
	}
	return(L2,2);
}


proc isSmooth(btmp)		//TODO via slocus?
"USAGE: isSmooth(list BO); checks whether BO[2] is smooth 
RETURN: 1, if it is smooth, 0 otherwise
EXAMPLE: example isSmooth; shows an example
"
{								//TODO: anders
	if(btmp == 1){
		return(1);
	}
	return(0);
}


//Blowing up each of the data and mapping each of it into new successor ring:
proc SuccessorsCharts(list BO, ideal cent, int chartnumber)
"USAGE: SuccessorsCharts(list BO, ideal cent, int chartnumber); Basic object BO, center cent and the number of the current chart chartnumber
RETURN: a list of successor charts with the corresponding data
EXAMPLE: example SuccessorsCharts; shows an example
"
{	
	int i,j,k,n;

	def r = basering;
	list successor_list = list();
	successor_list = blowUpBO(BO,cent,2);
	int Numb_sucessors = size(successor_list);
	
	

	// construct successorlist
	for(j = 1;j<=Numb_sucessors; j++){
		if(defined(newring)){kill newring;}
		def newring = successor_list[j];
		setring(newring);
		n = nvars(basering);
		//tmp_n = n;
		ideal bM=BO[5];	//aus resolve.lib abgeschrieben
		map BlowUpMap = r,bM;
		//TODO: Was muss alles übertragen werden?
		ideal last_map = bM;
		//ideal total_map = BlowUpMap(total_map);
		def path = imap(r,path);
		path=path,[chartnumber,j];
		//TODO: mehr exportieren?
		export(path);
		export(last_map);
		//export(total_map);
	}

	setring(r);
	
	if(defined(newring)){kill newring;}	
	return(successor_list);
}


//ueberfluessig!
proc UpdateBO7(intvec b_new,intvec b_old,list BO){
	int i,j;
	// ersetze BO-list im Input durch den gesamten Abstieg? -> Dann ist hier auch klar, dass wir das originale BO in der Abstiegsliste brauchen
	// auf jeder Stufe im Abstieg BO7 hinzufügen!
	list E = BO[4]; // TODO!!!! wir brauchen eigentlich das 'richtige E' von position b_decrease_pos hier!!!!

	
	//finding position in b_new where the order drops
	int b_decrease_pos; 
	for(i=1;i<=size(b_new);i++){
		if(b_new[i] < b_old){
			b_decrease_pos = i;
		}
	}
	//if b_new is shorter than b_old???
	if(b_decrease_pos == 0){print("Ordnung ist nicht gefallen!"); ~;}
	

	intvec BO7 = BO[7];
	intvec newBO7;
	//copy first values of BO7 where the order is constant
	for(i = 1; i<b_decrease_pos; i++){
		newBO7[i] = BO7[i];
	}
	

	//set BO[7][b_decrease_pos]
	newBO7[b_decrease_pos] = size(E);
	
	//update last values of BO[7]
	for(i = b_decrease_pos +1; i<= size(b_new);i++){
		newBO7[i] = -1;
	}	
	
	BO[7] = newBO7;
	return(BO)
}
