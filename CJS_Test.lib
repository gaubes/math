version=" "; // $Id$
category=" ";
info="
LIBRARY:  determiantal_resolve.lib 
AUTHOR:  Sabrina Alexandra Gaube, sabrina.gaube@uol.de

PROCEDURES:

	determinantal_resolve(matrix M, int r);
	
	calculate_process_of_center_calculation(matrix M); returns the status of the algorithm as a string
	isSimultaneouslyLocallyMonomial(matrix M); returns if the entries of M are simultaneously locally monomial
	isLocallyMonomial(matrix M); returns if the entries of M are locally monomial
	isMonomial(matrix M); returns if the entries of M are monomial
	isresolvedMonomial(matrix M); returns if the entries of M are monomial and the monomial ideal generated by the entries is non-singular

	GenerateListOfBinomials(matrix M); return a list of entries of M which are not locally monomial
	UpdateListofBinomials(list L); where L is a list which was generated by GenerateListOfBinomials(M) and where we have to delete entries after some blow ups
	CreateBinomialFromMonomialMatrix(matrix M); calculate the binomial ideal (in the monomial case) which determines via black box the resolution process 


	blowUp3(J, C, #); same like blowUp2 but with the subcall blowUpBO(BO,C,2) instead of blowUpBO(BO,C,1);
	main_generic_resolve(mode, m, #); main method for resolution of all generic matrices, with string parameter mode
	generic_resolve(m, n, #); call method for resolution of generic mxn matrices
	skewsymmetric_resolve(m); call method for resolution of generic skewsymmetric mxm matrices
	symmetric_resolve(m); call method for resolution of generic ymmetric mxm matrices
	
	CopyDataInNextChartsAndBlowUp(M, Center, chartnumber); blow up method which copies data in the successor charts
	weakTransformOfMatrix(N); given a blown up matrix N it calculates the weak transform of a matrix with respect to rows and columns 
	
	generic_gauss(N, number_rows, number_cols); calculates the gaussian steps for the generic case
	skewsymmetric_gauss(N, number_rows, number_cols); gaussian steps for the skewsymmetric case 
	symmetric_gauss(N, number_rows, number_cols); gaussian steps for the symmetric case
	
	generic_transformation_of_variables(M); transformation of variables for the generic case
	skewsymmetric_transformation_of_variables(M); transformation of variables for the skewsymmetric case
	symmetric_transformation_of_variables(M); transformation of variables for the symmetric case
	
";



LIB "test_ring.lib";
//LIB "resbinomial_neu.lib"; //only for performancetests
LIB "resolve.lib";

//only surfaces
proc test_cjs(list ideallist){		//only 2-minors of generic jxj matrices for 2<=j<=m
	link l1 = ":w CJS_Testfaelle/binomial_cjs.txt";
	//link l2 = ":w CJS_Testfaelle/resbinomial2.txt";
	
	list linklist = list(l1);
	int i; int j;
	ideal J;
	list blowuplist;
	int runningtime = 0;
	int whole_runningtime = 0;
	int tmp_runningtime = 0;
	
	
	list sum_runtime = list(0,0,0,0);
	list sum_endcharts = list(0,0,0,0);
	list sum_charts = list(0,0,0,0);
	for(i=1; i<=size(ideallist);i++){
		J = ideal(ideallist[i]);
	
		runningtime = 0;
		whole_runningtime = 0;
		tmp_runningtime = 0;
		tmp_runningtime = rtimer;
		blowuplist = binomial_cjs(J,1);
		runningtime = rtimer - tmp_runningtime;	
		fprintf(linklist[1]," Ideal: %s	endcharts: %s	charts: %s	running time: %s", J,size(blowuplist[1]),size(blowuplist[2]), runningtime);
		
//		tmp_runningtime = rtimer;
//		blowuplist = resbinomial2(J);
//		runningtime = rtimer - tmp_runningtime;	
//		fprintf(linklist[2]," Ideal: %s	endcharts: %s	charts: %s	running time: %s", J,size(blowuplist[1]),size(blowuplist[2]), runningtime);


	}
	//close files:
	close(l1);
	//close(l2);
}


proc test_resolve(ideal J){		//only 2-minors of generic jxj matrices for 2<=j<=m
	link l1 = ":w CJS_Testfaelle/binomial_resolve.txt";
	//link l2 = ":w CJS_Testfaelle/resbinomial2.txt";
	
	list linklist = list(l1);
	int i; int j;
	ideal J;
	list blowuplist;
	int runningtime = 0;
	int whole_runningtime = 0;
	int tmp_runningtime = 0;
	
	
	list sum_runtime = list(0,0,0,0);
	list sum_endcharts = list(0,0,0,0);
	list sum_charts = list(0,0,0,0);
	
	
		runningtime = 0;
		whole_runningtime = 0;
		tmp_runningtime = 0;
		tmp_runningtime = rtimer;
		blowuplist = resolve(J);
		runningtime = rtimer - tmp_runningtime;	
		fprintf(linklist[1]," Ideal: %s	endcharts: %s	charts: %s	running time: %s", J,size(blowuplist[1]),size(blowuplist[2]), runningtime);
	
	//close files:
	close(l1);

}

proc test_resbinomial(ideal J){		//only 2-minors of generic jxj matrices for 2<=j<=m
	link l1 = ":w CJS_Testfaelle/resbinomial.txt";
	//link l2 = ":w CJS_Testfaelle/resbinomial2.txt";
	
	list linklist = list(l1);
	int i; int j;
	ideal J;
	list blowuplist;
	int runningtime = 0;
	int whole_runningtime = 0;
	int tmp_runningtime = 0;
	
	
	list sum_runtime = list(0,0,0,0);
	list sum_endcharts = list(0,0,0,0);
	list sum_charts = list(0,0,0,0);
	
	
		runningtime = 0;
		whole_runningtime = 0;
		tmp_runningtime = 0;
		tmp_runningtime = rtimer;
		blowuplist = resbinomial2(J);
		runningtime = rtimer - tmp_runningtime;	
		fprintf(linklist[1]," Ideal: %s	endcharts: %s	charts: %s	running time: %s", J,size(blowuplist[1]),size(blowuplist[2]), runningtime);
		

	
	//close files:
	close(l1);

}
